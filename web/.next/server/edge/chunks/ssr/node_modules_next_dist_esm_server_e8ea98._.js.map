{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/internal-utils.ts"],"sourcesContent":["import type { NextParsedUrlQuery } from './request-meta'\n\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n\nconst INTERNAL_QUERY_NAMES = [\n  '__nextFallback',\n  '__nextLocale',\n  '__nextInferredLocaleFromDefault',\n  '__nextDefaultLocale',\n  '__nextIsNotFound',\n  NEXT_RSC_UNION_QUERY,\n] as const\n\nconst EDGE_EXTENDED_INTERNAL_QUERY_NAMES = ['__nextDataReq'] as const\n\nexport function stripInternalQueries(query: NextParsedUrlQuery) {\n  for (const name of INTERNAL_QUERY_NAMES) {\n    delete query[name]\n  }\n}\n\nexport function stripInternalSearchParams<T extends string | URL>(\n  url: T,\n  isEdge: boolean\n): T {\n  const isStringUrl = typeof url === 'string'\n  const instance = isStringUrl ? new URL(url) : (url as URL)\n  for (const name of INTERNAL_QUERY_NAMES) {\n    instance.searchParams.delete(name)\n  }\n\n  if (isEdge) {\n    for (const name of EDGE_EXTENDED_INTERNAL_QUERY_NAMES) {\n      instance.searchParams.delete(name)\n    }\n  }\n\n  return (isStringUrl ? instance.toString() : instance) as T\n}\n"],"names":["NEXT_RSC_UNION_QUERY","INTERNAL_QUERY_NAMES","EDGE_EXTENDED_INTERNAL_QUERY_NAMES","stripInternalQueries","query","name","stripInternalSearchParams","url","isEdge","isStringUrl","instance","URL","searchParams","delete","toString"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,0CAAyC;;AAE9E,MAAMC,uBAAuB;IAC3B;IACA;IACA;IACA;IACA;oMACAD,uBAAAA;CACD;AAED,MAAME,qCAAqC;IAAC;CAAgB;AAErD,SAASC,qBAAqBC,KAAyB;IAC5D,KAAK,MAAMC,QAAQJ,qBAAsB;QACvC,OAAOG,KAAK,CAACC,KAAK;IACpB;AACF;AAEO,SAASC,0BACdC,GAAM,EACNC,MAAe;IAEf,MAAMC,cAAc,OAAOF,QAAQ;IACnC,MAAMG,WAAWD,cAAc,IAAIE,IAAIJ,OAAQA;IAC/C,KAAK,MAAMF,QAAQJ,qBAAsB;QACvCS,SAASE,YAAY,CAACC,MAAM,CAACR;IAC/B;IAEA,IAAIG,QAAQ;QACV,KAAK,MAAMH,QAAQH,mCAAoC;YACrDQ,SAASE,YAAY,CAACC,MAAM,CAACR;QAC/B;IACF;IAEA,OAAQI,cAAcC,SAASI,QAAQ,KAAKJ;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/api-utils/web.ts"],"sourcesContent":["// Buffer.byteLength polyfill in the Edge runtime, with only utf8 strings\n// supported at the moment.\nexport function byteLength(payload: string): number {\n  return new TextEncoder().encode(payload).buffer.byteLength\n}\n"],"names":["byteLength","payload","TextEncoder","encode","buffer"],"mappings":"AAAA,yEAAyE;AACzE,2BAA2B;;;;AACpB,SAASA,WAAWC,OAAe;IACxC,OAAO,IAAIC,cAAcC,MAAM,CAACF,SAASG,MAAM,CAACJ,UAAU;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/api-utils/get-cookie-parser.ts"],"sourcesContent":["import type { NextApiRequestCookies } from '.'\n\n/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */\n\nexport function getCookieParser(headers: {\n  [key: string]: string | string[] | null | undefined\n}): () => NextApiRequestCookies {\n  return function parseCookie(): NextApiRequestCookies {\n    const { cookie } = headers\n\n    if (!cookie) {\n      return {}\n    }\n\n    const { parse: parseCookieFn } = require('next/dist/compiled/cookie')\n    return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)\n  }\n}\n"],"names":["getCookieParser","headers","parseCookie","cookie","parse","parseCookieFn","require","Array","isArray","join"],"mappings":"AAEA;;;CAGC,GAED;;;AAAO,SAASA,gBAAgBC,OAE/B;IACC,OAAO,SAASC;QACd,MAAM,EAAEC,MAAM,EAAE,GAAGF;QAEnB,IAAI,CAACE,QAAQ;YACX,OAAO,CAAC;QACV;QAEA,MAAM,EAAEC,OAAOC,aAAa,EAAE,GAAGC,QAAQ;QACzC,OAAOD,cAAcE,MAAMC,OAAO,CAACL,UAAUA,OAAOM,IAAI,CAAC,QAAQN;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/async-storage/draft-mode-provider.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/spec-extension/request'\n\nimport {\n  COOKIE_NAME_PRERENDER_BYPASS,\n  checkIsOnDemandRevalidate,\n} from '../api-utils'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nexport class DraftModeProvider {\n  public readonly isEnabled: boolean\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _previewModeId: string | undefined\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _mutableCookies: ResponseCookies\n\n  constructor(\n    previewProps: __ApiPreviewProps | undefined,\n    req: IncomingMessage | BaseNextRequest<unknown> | NextRequest,\n    cookies: ReadonlyRequestCookies,\n    mutableCookies: ResponseCookies\n  ) {\n    // The logic for draftMode() is very similar to tryGetPreviewData()\n    // but Draft Mode does not have any data associated with it.\n    const isOnDemandRevalidate =\n      previewProps &&\n      checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate\n\n    const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value\n\n    this.isEnabled = Boolean(\n      !isOnDemandRevalidate &&\n        cookieValue &&\n        previewProps &&\n        (cookieValue === previewProps.previewModeId ||\n          // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.\n          (process.env.NODE_ENV !== 'production' &&\n            previewProps.previewModeId === 'development-id'))\n    )\n\n    this._previewModeId = previewProps?.previewModeId\n    this._mutableCookies = mutableCookies\n  }\n\n  enable() {\n    if (!this._previewModeId) {\n      throw new Error(\n        'Invariant: previewProps missing previewModeId this should never happen'\n      )\n    }\n\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: this._previewModeId,\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n    })\n  }\n\n  disable() {\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: '',\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      expires: new Date(0),\n    })\n  }\n}\n"],"names":["COOKIE_NAME_PRERENDER_BYPASS","checkIsOnDemandRevalidate","DraftModeProvider","constructor","previewProps","req","cookies","mutableCookies","isOnDemandRevalidate","cookieValue","get","value","isEnabled","Boolean","previewModeId","process","env","NODE_ENV","_previewModeId","_mutableCookies","enable","Error","set","name","httpOnly","sameSite","secure","path","disable","expires","Date"],"mappings":";;;AAMA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,eAAc;;AAGd,MAAMC;IAaXC,YACEC,YAA2C,EAC3CC,GAA6D,EAC7DC,OAA+B,EAC/BC,cAA+B,CAC/B;YAOoBD;QANpB,mEAAmE;QACnE,4DAA4D;QAC5D,MAAME,uBACJJ,oBACAH,2MAAAA,EAA0BI,KAAKD,cAAcI,oBAAoB;QAEnE,MAAMC,cAAAA,CAAcH,eAAAA,QAAQI,GAAG,gLAACV,+BAAAA,CAAAA,KAAAA,OAAAA,KAAAA,IAAZM,aAA2CK,KAAK;QAEpE,IAAI,CAACC,SAAS,GAAGC,QACf,CAACL,wBACCC,eACAL,gBACCK,CAAAA,gBAAgBL,aAAaU,aAAa,IACzC,mHAAmH;QAClHC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACxBb,aAAaU,aAAa,KAAK,gBAAgB;QAGvD,IAAI,CAACI,cAAc,GAAGd,gBAAAA,OAAAA,KAAAA,IAAAA,aAAcU,aAAa;QACjD,IAAI,CAACK,eAAe,GAAGZ;IACzB;IAEAa,SAAS;QACP,IAAI,CAAC,IAAI,CAACF,cAAc,EAAE;YACxB,MAAM,IAAIG,MACR;QAEJ;QAEA,IAAI,CAACF,eAAe,CAACG,GAAG,CAAC;YACvBC,MAAMvB,8MAAAA;YACNW,OAAO,IAAI,CAACO,cAAc;YAC1BM,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;QACR;IACF;IAEAC,UAAU;QACR,2DAA2D;QAC3D,oDAAoD;QACpD,wEAAwE;QACxE,IAAI,CAACT,eAAe,CAACG,GAAG,CAAC;YACvBC,qLAAMvB,+BAAAA;YACNW,OAAO;YACPa,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;YACNE,SAAS,IAAIC,KAAK;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/async-storage/request-store.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { RenderOpts } from '../app-render/types'\nimport type { NextRequest } from '../web/spec-extension/request'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\nimport {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  MutableRequestCookiesAdapter,\n  RequestCookiesAdapter,\n  responseCookiesToRequestCookies,\n  wrapWithMutableAccessCheck,\n  type ReadonlyRequestCookies,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'\nimport { DraftModeProvider } from './draft-mode-provider'\nimport { splitCookiesString } from '../web/utils'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nfunction getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n  const cleaned = HeadersAdapter.from(headers)\n  for (const header of FLIGHT_HEADERS) {\n    cleaned.delete(header.toLowerCase())\n  }\n\n  return HeadersAdapter.seal(cleaned)\n}\n\nfunction getMutableCookies(\n  headers: Headers | IncomingHttpHeaders,\n  onUpdateCookies?: (cookies: string[]) => void\n): ResponseCookies {\n  const cookies = new RequestCookies(HeadersAdapter.from(headers))\n  return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)\n}\n\nexport type WrapperRenderOpts = Partial<Pick<RenderOpts, 'onUpdateCookies'>> & {\n  previewProps?: __ApiPreviewProps\n}\n\ntype RequestContext = RequestResponsePair & {\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL. This is only undefined when generating static paths (ie,\n   * there is no request in progress, nor do we know one).\n   */\n  url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    search?: string\n  }\n  phase: RequestStore['phase']\n  renderOpts?: WrapperRenderOpts\n  isHmrRefresh?: boolean\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  implicitTags?: string[] | undefined\n}\n\ntype RequestResponsePair =\n  | { req: BaseNextRequest; res: BaseNextResponse } // for an app page\n  | { req: NextRequest; res: undefined } // in an api route or middleware\n\n/**\n * If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),\n * then merge those into the existing cookie object, so that when `cookies()` is accessed\n * it's able to read the newly set cookies.\n */\nfunction mergeMiddlewareCookies(\n  req: RequestContext['req'],\n  existingCookies: RequestCookies | ResponseCookies\n) {\n  if (\n    'x-middleware-set-cookie' in req.headers &&\n    typeof req.headers['x-middleware-set-cookie'] === 'string'\n  ) {\n    const setCookieValue = req.headers['x-middleware-set-cookie']\n    const responseHeaders = new Headers()\n\n    for (const cookie of splitCookiesString(setCookieValue)) {\n      responseHeaders.append('set-cookie', cookie)\n    }\n\n    const responseCookies = new ResponseCookies(responseHeaders)\n\n    // Transfer cookies from ResponseCookies to RequestCookies\n    for (const cookie of responseCookies.getAll()) {\n      existingCookies.set(cookie)\n    }\n  }\n}\n\nexport function createRequestStoreForRender(\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | undefined,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']\n): RequestStore {\n  return createRequestStoreImpl(\n    // Pages start in render phase by default\n    'render',\n    req,\n    res,\n    url,\n    implicitTags,\n    onUpdateCookies,\n    renderResumeDataCache,\n    previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache\n  )\n}\n\nexport function createRequestStoreForAPI(\n  req: RequestContext['req'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps']\n): RequestStore {\n  return createRequestStoreImpl(\n    // API routes start in action phase by default\n    'action',\n    req,\n    undefined,\n    url,\n    implicitTags,\n    onUpdateCookies,\n    undefined,\n    previewProps,\n    false,\n    undefined\n  )\n}\n\nfunction createRequestStoreImpl(\n  phase: RequestStore['phase'],\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | undefined,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']\n): RequestStore {\n  function defaultOnUpdateCookies(cookies: string[]) {\n    if (res) {\n      res.setHeader('Set-Cookie', cookies)\n    }\n  }\n\n  const cache: {\n    headers?: ReadonlyHeaders\n    cookies?: ReadonlyRequestCookies\n    mutableCookies?: ResponseCookies\n    userspaceMutableCookies?: ResponseCookies\n    draftMode?: DraftModeProvider\n  } = {}\n\n  return {\n    type: 'request',\n    phase,\n    implicitTags: implicitTags ?? [],\n    // Rather than just using the whole `url` here, we pull the parts we want\n    // to ensure we don't use parts of the URL that we shouldn't. This also\n    // lets us avoid requiring an empty string for `search` in the type.\n    url: { pathname: url.pathname, search: url.search ?? '' },\n    get headers() {\n      if (!cache.headers) {\n        // Seal the headers object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.headers = getHeaders(req.headers)\n      }\n\n      return cache.headers\n    },\n    get cookies() {\n      if (!cache.cookies) {\n        // if middleware is setting cookie(s), then include those in\n        // the initial cached cookies so they can be read in render\n        const requestCookies = new RequestCookies(\n          HeadersAdapter.from(req.headers)\n        )\n\n        mergeMiddlewareCookies(req, requestCookies)\n\n        // Seal the cookies object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.cookies = RequestCookiesAdapter.seal(requestCookies)\n      }\n\n      return cache.cookies\n    },\n    set cookies(value: ReadonlyRequestCookies) {\n      cache.cookies = value\n    },\n    get mutableCookies() {\n      if (!cache.mutableCookies) {\n        const mutableCookies = getMutableCookies(\n          req.headers,\n          onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)\n        )\n\n        mergeMiddlewareCookies(req, mutableCookies)\n\n        cache.mutableCookies = mutableCookies\n      }\n      return cache.mutableCookies\n    },\n    get userspaceMutableCookies() {\n      if (!cache.userspaceMutableCookies) {\n        const userspaceMutableCookies = wrapWithMutableAccessCheck(\n          this.mutableCookies\n        )\n        cache.userspaceMutableCookies = userspaceMutableCookies\n      }\n      return cache.userspaceMutableCookies\n    },\n    get draftMode() {\n      if (!cache.draftMode) {\n        cache.draftMode = new DraftModeProvider(\n          previewProps,\n          req,\n          this.cookies,\n          this.mutableCookies\n        )\n      }\n\n      return cache.draftMode\n    },\n    renderResumeDataCache: renderResumeDataCache ?? null,\n    devWarmupPrerenderResumeDataCache: null,\n    isHmrRefresh,\n    serverComponentsHmrCache:\n      serverComponentsHmrCache ||\n      (globalThis as any).__serverComponentsHmrCache,\n  }\n}\n\nexport function synchronizeMutableCookies(store: RequestStore) {\n  // TODO: does this need to update headers as well?\n  store.cookies = RequestCookiesAdapter.seal(\n    responseCookiesToRequestCookies(store.mutableCookies)\n  )\n}\n"],"names":["FLIGHT_HEADERS","HeadersAdapter","MutableRequestCookiesAdapter","RequestCookiesAdapter","responseCookiesToRequestCookies","wrapWithMutableAccessCheck","ResponseCookies","RequestCookies","DraftModeProvider","splitCookiesString","getHeaders","headers","cleaned","from","header","delete","toLowerCase","seal","getMutableCookies","onUpdateCookies","cookies","wrap","mergeMiddlewareCookies","req","existingCookies","setCookieValue","responseHeaders","Headers","cookie","append","responseCookies","getAll","set","createRequestStoreForRender","res","url","implicitTags","renderResumeDataCache","previewProps","isHmrRefresh","serverComponentsHmrCache","createRequestStoreImpl","createRequestStoreForAPI","undefined","phase","defaultOnUpdateCookies","setHeader","cache","type","pathname","search","requestCookies","value","mutableCookies","userspaceMutableCookies","draftMode","devWarmupPrerenderResumeDataCache","globalThis","__serverComponentsHmrCache","synchronizeMutableCookies","store"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 568, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/async-storage/work-store.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  /**\n   * The route parameters that are currently unknown.\n   */\n  fallbackRouteParams: FallbackRouteParams | null\n\n  requestEndedState?: { ended?: boolean }\n  isPrefetchRequest?: boolean\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'after' | 'dynamicIO'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'buildId'\n  > &\n    Partial<RequestLifecycleOpts> &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n}\n\nexport function createWorkStore({\n  page,\n  fallbackRouteParams,\n  renderOpts,\n  requestEndedState,\n  isPrefetchRequest,\n}: WorkStoreContext): WorkStore {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    fallbackRouteParams,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    requestEndedState,\n    isPrefetchRequest,\n    buildId: renderOpts.buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n\n    afterContext: createAfterContext(renderOpts),\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return store\n}\n\nfunction createAfterContext(\n  renderOpts: Partial<RequestLifecycleOpts> & {\n    experimental: Pick<RenderOpts['experimental'], 'after'>\n  }\n): AfterContext | undefined {\n  const isAfterEnabled = renderOpts?.experimental?.after ?? false\n  if (!isAfterEnabled) {\n    return undefined\n  }\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({ waitUntil, onClose, onTaskError: onAfterTaskError })\n}\n"],"names":["AfterContext","normalizeAppPath","createWorkStore","page","fallbackRouteParams","renderOpts","requestEndedState","isPrefetchRequest","isStaticGeneration","supportsDynamicResponse","isDraftMode","isServerAction","store","route","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","buildId","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","isAfterEnabled","experimental","after","undefined","waitUntil","onClose","onAfterTaskError","onTaskError"],"mappings":";;;AASA,SAASA,YAAY,QAAQ,yBAAwB;AAErD,SAASC,gBAAgB,QAAQ,0CAAyC;;;AAyDnE,SAASC,gBAAgB,EAC9BC,IAAI,EACJC,mBAAmB,EACnBC,UAAU,EACVC,iBAAiB,EACjBC,iBAAiB,EACA;IACjB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACH,WAAWI,uBAAuB,IACnC,CAACJ,WAAWK,WAAW,IACvB,CAACL,WAAWM,cAAc;IAE5B,MAAMC,QAAmB;QACvBJ;QACAL;QACAC;QACAS,2MAAOZ,mBAAAA,EAAiBE;QACxBW,kBACE,AACA,mDAAmD,kBADkB;QAErET,WAAWS,gBAAgB,IAAKC,WAAmBC,kBAAkB;QACvEC,mBAAmBZ,WAAWY,iBAAiB;QAC/CC,cAAcb,WAAWa,YAAY;QACrCC,gBAAgBd,WAAWe,UAAU;QACrCC,YAAYhB,WAAWgB,UAAU;QACjCC,sBAAsBjB,WAAWiB,oBAAoB;QAErDZ,aAAaL,WAAWK,WAAW;QAEnCJ;QACAC;QACAgB,SAASlB,WAAWkB,OAAO;QAC3BC,uBAAuBnB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYmB,qBAAqB,KAAI,CAAC;QAC7DC,aAAapB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYoB,WAAW,KAAI;QAExCC,cAAcC,mBAAmBtB;IACnC;IAEA,sFAAsF;IACtFA,WAAWO,KAAK,GAAGA;IAEnB,OAAOA;AACT;AAEA,SAASe,mBACPtB,UAEC;QAEsBA;IAAvB,MAAMuB,iBAAiBvB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,CAAAA,2BAAAA,WAAYwB,YAAY,KAAA,OAAA,KAAA,IAAxBxB,yBAA0ByB,KAAK,KAAI;IAC1D,IAAI,CAACF,gBAAgB;QACnB,OAAOG;IACT;IACA,MAAM,EAAEC,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAG7B;IACjD,OAAO,uLAAIL,eAAAA,CAAa;QAAEgC;QAAWC;QAASE,aAAaD;IAAiB;AAC9E","ignoreList":[0]}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 642, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/async-storage/draft-mode-provider.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/spec-extension/request'\n\nimport {\n  COOKIE_NAME_PRERENDER_BYPASS,\n  checkIsOnDemandRevalidate,\n} from '../api-utils'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nexport class DraftModeProvider {\n  public readonly isEnabled: boolean\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _previewModeId: string | undefined\n\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _mutableCookies: ResponseCookies\n\n  constructor(\n    previewProps: __ApiPreviewProps | undefined,\n    req: IncomingMessage | BaseNextRequest<unknown> | NextRequest,\n    cookies: ReadonlyRequestCookies,\n    mutableCookies: ResponseCookies\n  ) {\n    // The logic for draftMode() is very similar to tryGetPreviewData()\n    // but Draft Mode does not have any data associated with it.\n    const isOnDemandRevalidate =\n      previewProps &&\n      checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate\n\n    const cookieValue = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value\n\n    this.isEnabled = Boolean(\n      !isOnDemandRevalidate &&\n        cookieValue &&\n        previewProps &&\n        (cookieValue === previewProps.previewModeId ||\n          // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.\n          (process.env.NODE_ENV !== 'production' &&\n            previewProps.previewModeId === 'development-id'))\n    )\n\n    this._previewModeId = previewProps?.previewModeId\n    this._mutableCookies = mutableCookies\n  }\n\n  enable() {\n    if (!this._previewModeId) {\n      throw new Error(\n        'Invariant: previewProps missing previewModeId this should never happen'\n      )\n    }\n\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: this._previewModeId,\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n    })\n  }\n\n  disable() {\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    this._mutableCookies.set({\n      name: COOKIE_NAME_PRERENDER_BYPASS,\n      value: '',\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      expires: new Date(0),\n    })\n  }\n}\n"],"names":["COOKIE_NAME_PRERENDER_BYPASS","checkIsOnDemandRevalidate","DraftModeProvider","constructor","previewProps","req","cookies","mutableCookies","isOnDemandRevalidate","cookieValue","get","value","isEnabled","Boolean","previewModeId","process","env","NODE_ENV","_previewModeId","_mutableCookies","enable","Error","set","name","httpOnly","sameSite","secure","path","disable","expires","Date"],"mappings":";;;AAMA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,eAAc;;AAGd,MAAMC;IAaXC,YACEC,YAA2C,EAC3CC,GAA6D,EAC7DC,OAA+B,EAC/BC,cAA+B,CAC/B;YAOoBD;QANpB,mEAAmE;QACnE,4DAA4D;QAC5D,MAAME,uBACJJ,oBACAH,2MAAAA,EAA0BI,KAAKD,cAAcI,oBAAoB;QAEnE,MAAMC,cAAAA,CAAcH,eAAAA,QAAQI,GAAG,gLAACV,+BAAAA,CAAAA,KAAAA,OAAAA,KAAAA,IAAZM,aAA2CK,KAAK;QAEpE,IAAI,CAACC,SAAS,GAAGC,QACf,CAACL,wBACCC,eACAL,gBACCK,CAAAA,gBAAgBL,aAAaU,aAAa,IACzC,mHAAmH;QAClHC,QAAQC,GAAG,CAACC,QAAQ,gCAAK,gBACxBb,aAAaU,aAAa,KAAK,gBAAgB;QAGvD,IAAI,CAACI,cAAc,GAAGd,gBAAAA,OAAAA,KAAAA,IAAAA,aAAcU,aAAa;QACjD,IAAI,CAACK,eAAe,GAAGZ;IACzB;IAEAa,SAAS;QACP,IAAI,CAAC,IAAI,CAACF,cAAc,EAAE;YACxB,MAAM,IAAIG,MACR;QAEJ;QAEA,IAAI,CAACF,eAAe,CAACG,GAAG,CAAC;YACvBC,MAAMvB,8MAAAA;YACNW,OAAO,IAAI,CAACO,cAAc;YAC1BM,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;QACR;IACF;IAEAC,UAAU;QACR,2DAA2D;QAC3D,oDAAoD;QACpD,wEAAwE;QACxE,IAAI,CAACT,eAAe,CAACG,GAAG,CAAC;YACvBC,qLAAMvB,+BAAAA;YACNW,OAAO;YACPa,UAAU;YACVC,UAAUV,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,oCAAS;YAC5DS,QAAQX,QAAQC,GAAG,CAACC,QAAQ,gCAAK;YACjCU,MAAM;YACNE,SAAS,IAAIC,KAAK;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 687, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/async-storage/request-store.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { RenderOpts } from '../app-render/types'\nimport type { NextRequest } from '../web/spec-extension/request'\nimport type { __ApiPreviewProps } from '../api-utils'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\nimport {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport {\n  MutableRequestCookiesAdapter,\n  RequestCookiesAdapter,\n  responseCookiesToRequestCookies,\n  wrapWithMutableAccessCheck,\n  type ReadonlyRequestCookies,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { ResponseCookies, RequestCookies } from '../web/spec-extension/cookies'\nimport { DraftModeProvider } from './draft-mode-provider'\nimport { splitCookiesString } from '../web/utils'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n\nfunction getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n  const cleaned = HeadersAdapter.from(headers)\n  for (const header of FLIGHT_HEADERS) {\n    cleaned.delete(header.toLowerCase())\n  }\n\n  return HeadersAdapter.seal(cleaned)\n}\n\nfunction getMutableCookies(\n  headers: Headers | IncomingHttpHeaders,\n  onUpdateCookies?: (cookies: string[]) => void\n): ResponseCookies {\n  const cookies = new RequestCookies(HeadersAdapter.from(headers))\n  return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies)\n}\n\nexport type WrapperRenderOpts = Partial<Pick<RenderOpts, 'onUpdateCookies'>> & {\n  previewProps?: __ApiPreviewProps\n}\n\ntype RequestContext = RequestResponsePair & {\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL. This is only undefined when generating static paths (ie,\n   * there is no request in progress, nor do we know one).\n   */\n  url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    search?: string\n  }\n  phase: RequestStore['phase']\n  renderOpts?: WrapperRenderOpts\n  isHmrRefresh?: boolean\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n  implicitTags?: string[] | undefined\n}\n\ntype RequestResponsePair =\n  | { req: BaseNextRequest; res: BaseNextResponse } // for an app page\n  | { req: NextRequest; res: undefined } // in an api route or middleware\n\n/**\n * If middleware set cookies in this request (indicated by `x-middleware-set-cookie`),\n * then merge those into the existing cookie object, so that when `cookies()` is accessed\n * it's able to read the newly set cookies.\n */\nfunction mergeMiddlewareCookies(\n  req: RequestContext['req'],\n  existingCookies: RequestCookies | ResponseCookies\n) {\n  if (\n    'x-middleware-set-cookie' in req.headers &&\n    typeof req.headers['x-middleware-set-cookie'] === 'string'\n  ) {\n    const setCookieValue = req.headers['x-middleware-set-cookie']\n    const responseHeaders = new Headers()\n\n    for (const cookie of splitCookiesString(setCookieValue)) {\n      responseHeaders.append('set-cookie', cookie)\n    }\n\n    const responseCookies = new ResponseCookies(responseHeaders)\n\n    // Transfer cookies from ResponseCookies to RequestCookies\n    for (const cookie of responseCookies.getAll()) {\n      existingCookies.set(cookie)\n    }\n  }\n}\n\nexport function createRequestStoreForRender(\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | undefined,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']\n): RequestStore {\n  return createRequestStoreImpl(\n    // Pages start in render phase by default\n    'render',\n    req,\n    res,\n    url,\n    implicitTags,\n    onUpdateCookies,\n    renderResumeDataCache,\n    previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache\n  )\n}\n\nexport function createRequestStoreForAPI(\n  req: RequestContext['req'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  previewProps: WrapperRenderOpts['previewProps']\n): RequestStore {\n  return createRequestStoreImpl(\n    // API routes start in action phase by default\n    'action',\n    req,\n    undefined,\n    url,\n    implicitTags,\n    onUpdateCookies,\n    undefined,\n    previewProps,\n    false,\n    undefined\n  )\n}\n\nfunction createRequestStoreImpl(\n  phase: RequestStore['phase'],\n  req: RequestContext['req'],\n  res: RequestContext['res'],\n  url: RequestContext['url'],\n  implicitTags: RequestContext['implicitTags'],\n  onUpdateCookies: RenderOpts['onUpdateCookies'],\n  renderResumeDataCache: RenderResumeDataCache | undefined,\n  previewProps: WrapperRenderOpts['previewProps'],\n  isHmrRefresh: RequestContext['isHmrRefresh'],\n  serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']\n): RequestStore {\n  function defaultOnUpdateCookies(cookies: string[]) {\n    if (res) {\n      res.setHeader('Set-Cookie', cookies)\n    }\n  }\n\n  const cache: {\n    headers?: ReadonlyHeaders\n    cookies?: ReadonlyRequestCookies\n    mutableCookies?: ResponseCookies\n    userspaceMutableCookies?: ResponseCookies\n    draftMode?: DraftModeProvider\n  } = {}\n\n  return {\n    type: 'request',\n    phase,\n    implicitTags: implicitTags ?? [],\n    // Rather than just using the whole `url` here, we pull the parts we want\n    // to ensure we don't use parts of the URL that we shouldn't. This also\n    // lets us avoid requiring an empty string for `search` in the type.\n    url: { pathname: url.pathname, search: url.search ?? '' },\n    get headers() {\n      if (!cache.headers) {\n        // Seal the headers object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.headers = getHeaders(req.headers)\n      }\n\n      return cache.headers\n    },\n    get cookies() {\n      if (!cache.cookies) {\n        // if middleware is setting cookie(s), then include those in\n        // the initial cached cookies so they can be read in render\n        const requestCookies = new RequestCookies(\n          HeadersAdapter.from(req.headers)\n        )\n\n        mergeMiddlewareCookies(req, requestCookies)\n\n        // Seal the cookies object that'll freeze out any methods that could\n        // mutate the underlying data.\n        cache.cookies = RequestCookiesAdapter.seal(requestCookies)\n      }\n\n      return cache.cookies\n    },\n    set cookies(value: ReadonlyRequestCookies) {\n      cache.cookies = value\n    },\n    get mutableCookies() {\n      if (!cache.mutableCookies) {\n        const mutableCookies = getMutableCookies(\n          req.headers,\n          onUpdateCookies || (res ? defaultOnUpdateCookies : undefined)\n        )\n\n        mergeMiddlewareCookies(req, mutableCookies)\n\n        cache.mutableCookies = mutableCookies\n      }\n      return cache.mutableCookies\n    },\n    get userspaceMutableCookies() {\n      if (!cache.userspaceMutableCookies) {\n        const userspaceMutableCookies = wrapWithMutableAccessCheck(\n          this.mutableCookies\n        )\n        cache.userspaceMutableCookies = userspaceMutableCookies\n      }\n      return cache.userspaceMutableCookies\n    },\n    get draftMode() {\n      if (!cache.draftMode) {\n        cache.draftMode = new DraftModeProvider(\n          previewProps,\n          req,\n          this.cookies,\n          this.mutableCookies\n        )\n      }\n\n      return cache.draftMode\n    },\n    renderResumeDataCache: renderResumeDataCache ?? null,\n    devWarmupPrerenderResumeDataCache: null,\n    isHmrRefresh,\n    serverComponentsHmrCache:\n      serverComponentsHmrCache ||\n      (globalThis as any).__serverComponentsHmrCache,\n  }\n}\n\nexport function synchronizeMutableCookies(store: RequestStore) {\n  // TODO: does this need to update headers as well?\n  store.cookies = RequestCookiesAdapter.seal(\n    responseCookiesToRequestCookies(store.mutableCookies)\n  )\n}\n"],"names":["FLIGHT_HEADERS","HeadersAdapter","MutableRequestCookiesAdapter","RequestCookiesAdapter","responseCookiesToRequestCookies","wrapWithMutableAccessCheck","ResponseCookies","RequestCookies","DraftModeProvider","splitCookiesString","getHeaders","headers","cleaned","from","header","delete","toLowerCase","seal","getMutableCookies","onUpdateCookies","cookies","wrap","mergeMiddlewareCookies","req","existingCookies","setCookieValue","responseHeaders","Headers","cookie","append","responseCookies","getAll","set","createRequestStoreForRender","res","url","implicitTags","renderResumeDataCache","previewProps","isHmrRefresh","serverComponentsHmrCache","createRequestStoreImpl","createRequestStoreForAPI","undefined","phase","defaultOnUpdateCookies","setHeader","cache","type","pathname","search","requestCookies","value","mutableCookies","userspaceMutableCookies","draftMode","devWarmupPrerenderResumeDataCache","globalThis","__serverComponentsHmrCache","synchronizeMutableCookies","store"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 818, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/async-storage/work-store.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  /**\n   * The route parameters that are currently unknown.\n   */\n  fallbackRouteParams: FallbackRouteParams | null\n\n  requestEndedState?: { ended?: boolean }\n  isPrefetchRequest?: boolean\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'after' | 'dynamicIO'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'buildId'\n  > &\n    Partial<RequestLifecycleOpts> &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n}\n\nexport function createWorkStore({\n  page,\n  fallbackRouteParams,\n  renderOpts,\n  requestEndedState,\n  isPrefetchRequest,\n}: WorkStoreContext): WorkStore {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    fallbackRouteParams,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    requestEndedState,\n    isPrefetchRequest,\n    buildId: renderOpts.buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n\n    afterContext: createAfterContext(renderOpts),\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return store\n}\n\nfunction createAfterContext(\n  renderOpts: Partial<RequestLifecycleOpts> & {\n    experimental: Pick<RenderOpts['experimental'], 'after'>\n  }\n): AfterContext | undefined {\n  const isAfterEnabled = renderOpts?.experimental?.after ?? false\n  if (!isAfterEnabled) {\n    return undefined\n  }\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({ waitUntil, onClose, onTaskError: onAfterTaskError })\n}\n"],"names":["AfterContext","normalizeAppPath","createWorkStore","page","fallbackRouteParams","renderOpts","requestEndedState","isPrefetchRequest","isStaticGeneration","supportsDynamicResponse","isDraftMode","isServerAction","store","route","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","buildId","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","isAfterEnabled","experimental","after","undefined","waitUntil","onClose","onAfterTaskError","onTaskError"],"mappings":";;;AASA,SAASA,YAAY,QAAQ,yBAAwB;AAErD,SAASC,gBAAgB,QAAQ,0CAAyC;;;AAyDnE,SAASC,gBAAgB,EAC9BC,IAAI,EACJC,mBAAmB,EACnBC,UAAU,EACVC,iBAAiB,EACjBC,iBAAiB,EACA;IACjB;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACH,WAAWI,uBAAuB,IACnC,CAACJ,WAAWK,WAAW,IACvB,CAACL,WAAWM,cAAc;IAE5B,MAAMC,QAAmB;QACvBJ;QACAL;QACAC;QACAS,2MAAOZ,mBAAAA,EAAiBE;QACxBW,kBACE,AACA,mDAAmD,kBADkB;QAErET,WAAWS,gBAAgB,IAAKC,WAAmBC,kBAAkB;QACvEC,mBAAmBZ,WAAWY,iBAAiB;QAC/CC,cAAcb,WAAWa,YAAY;QACrCC,gBAAgBd,WAAWe,UAAU;QACrCC,YAAYhB,WAAWgB,UAAU;QACjCC,sBAAsBjB,WAAWiB,oBAAoB;QAErDZ,aAAaL,WAAWK,WAAW;QAEnCJ;QACAC;QACAgB,SAASlB,WAAWkB,OAAO;QAC3BC,uBAAuBnB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYmB,qBAAqB,KAAI,CAAC;QAC7DC,aAAapB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,WAAYoB,WAAW,KAAI;QAExCC,cAAcC,mBAAmBtB;IACnC;IAEA,sFAAsF;IACtFA,WAAWO,KAAK,GAAGA;IAEnB,OAAOA;AACT;AAEA,SAASe,mBACPtB,UAEC;QAEsBA;IAAvB,MAAMuB,iBAAiBvB,CAAAA,cAAAA,OAAAA,KAAAA,IAAAA,CAAAA,2BAAAA,WAAYwB,YAAY,KAAA,OAAA,KAAA,IAAxBxB,yBAA0ByB,KAAK,KAAI;IAC1D,IAAI,CAACF,gBAAgB;QACnB,OAAOG;IACT;IACA,MAAM,EAAEC,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAG7B;IACjD,OAAO,uLAAIL,eAAAA,CAAa;QAAEgC;QAAWC;QAASE,aAAaD;IAAiB;AAC9E","ignoreList":[0]}},
    {"offset": {"line": 886, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 892, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/after/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'revalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    revalidatedTags: store.revalidatedTags ? [...store.revalidatedTags] : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTags = new Set(prev.revalidatedTags)\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    revalidatedTags: curr.revalidatedTags.filter((tag) => !prevTags.has(tag)),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function executeRevalidates(\n  workStore: WorkStore,\n  {\n    revalidatedTags,\n    pendingRevalidates,\n    pendingRevalidateWrites,\n  }: RevalidationState\n) {\n  return Promise.all([\n    workStore.incrementalCache?.revalidateTag(revalidatedTags),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","revalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTags","Set","prevRevalidateWrites","filter","tag","has","Object","fromEntries","entries","key","promise","workStore","Promise","all","incrementalCache","revalidateTag","values"],"mappings":"AAEA,kFAAkF,GAClF;;;AAAO,eAAeA,uBACpBC,KAA4B,EAC5BC,QAA0B;IAE1B,IAAI,CAACD,OAAO;QACV,OAAOC;IACT;IACA,+FAA+F;IAC/F,yFAAyF;IACzF,MAAMC,yBAAyBC,uBAAuBH;IACtD,IAAI;QACF,OAAO,MAAMC;IACf,SAAU;QACR,qFAAqF;QACrF,MAAMG,iBAAiBC,sBACrBH,wBACAC,uBAAuBH;QAEzB,MAAMM,mBAAmBN,OAAOI;IAClC;AACF;AASA,SAASD,uBAAuBH,KAAgB;IAC9C,OAAO;QACLO,iBAAiBP,MAAMO,eAAe,GAAG;eAAIP,MAAMO,eAAe;SAAC,GAAG,EAAE;QACxEC,oBAAoB;YAAE,GAAGR,MAAMQ,kBAAkB;QAAC;QAClDC,yBAAyBT,MAAMS,uBAAuB,GAClD;eAAIT,MAAMS,uBAAuB;SAAC,GAClC,EAAE;IACR;AACF;AAEA,SAASJ,sBACPK,IAAuB,EACvBC,IAAuB;IAEvB,MAAMC,WAAW,IAAIC,IAAIH,KAAKH,eAAe;IAC7C,MAAMO,uBAAuB,IAAID,IAAIH,KAAKD,uBAAuB;IACjE,OAAO;QACLF,iBAAiBI,KAAKJ,eAAe,CAACQ,MAAM,CAAC,CAACC,MAAQ,CAACJ,SAASK,GAAG,CAACD;QACpER,oBAAoBU,OAAOC,WAAW,CACpCD,OAAOE,OAAO,CAACT,KAAKH,kBAAkB,EAAEO,MAAM,CAC5C,CAAC,CAACM,IAAI,GAAK,CAAEA,CAAAA,OAAOX,KAAKF,kBAAiB;QAG9CC,yBAAyBE,KAAKF,uBAAuB,CAACM,MAAM,CAC1D,CAACO,UAAY,CAACR,qBAAqBG,GAAG,CAACK;IAE3C;AACF;AAEA,eAAehB,mBACbiB,SAAoB,EACpB,EACEhB,eAAe,EACfC,kBAAkB,EAClBC,uBAAuB,EACL;QAGlBc;IADF,OAAOC,QAAQC,GAAG,CAAC;SACjBF,8BAAAA,UAAUG,gBAAgB,KAAA,OAAA,KAAA,IAA1BH,4BAA4BI,aAAa,CAACpB;WACvCW,OAAOU,MAAM,CAACpB;WACdC;KACJ;AACH","ignoreList":[0]}},
    {"offset": {"line": 940, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 946, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task.catch((error) => this.reportTaskError(error)))\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) {\n      throw new InvariantError(\n        'Missing workUnitStore in AfterContext.addCallback'\n      )\n    }\n    this.workUnitStores.add(workUnitStore)\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await callback()\n      } catch (error) {\n        this.reportTaskError(error)\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      'An error occurred in a function passed to `unstable_after()`:',\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `unstable_after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","Promise","resolve","runCallbacks","size","phase","workStore","start","onIdle","console","handlerError","cause"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1056, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1062, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/after/builtin-request-context.ts"],"sourcesContent":["import { createAsyncLocalStorage } from '../app-render/async-local-storage'\n\nexport function getBuiltinRequestContext():\n  | BuiltinRequestContextValue\n  | undefined {\n  const _globalThis = globalThis as GlobalThisWithRequestContext\n  const ctx =\n    _globalThis[NEXT_REQUEST_CONTEXT_SYMBOL] ??\n    _globalThis[VERCEL_REQUEST_CONTEXT_SYMBOL]\n  return ctx?.get()\n}\n\n/** This should be considered unstable until `unstable_after` is stablized. */\nconst NEXT_REQUEST_CONTEXT_SYMBOL = Symbol.for('@next/request-context')\n\n// TODO(after): this is a temporary workaround.\n// Remove this when vercel builder is updated to provide '@next/request-context'.\nconst VERCEL_REQUEST_CONTEXT_SYMBOL = Symbol.for('@vercel/request-context')\n\ntype GlobalThisWithRequestContext = typeof globalThis & {\n  [NEXT_REQUEST_CONTEXT_SYMBOL]?: BuiltinRequestContext\n  /** @deprecated */\n  [VERCEL_REQUEST_CONTEXT_SYMBOL]?: BuiltinRequestContext\n}\n\n/** A request context provided by the platform.\n * It should be considered unstable until `unstable_after` is stablized. */\nexport type BuiltinRequestContext = {\n  get(): BuiltinRequestContextValue | undefined\n}\n\nexport type RunnableBuiltinRequestContext = BuiltinRequestContext & {\n  run<T>(value: BuiltinRequestContextValue, callback: () => T): T\n}\n\nexport type BuiltinRequestContextValue = {\n  waitUntil?: WaitUntil\n}\nexport type WaitUntil = (promise: Promise<any>) => void\n\n/** \"@next/request-context\" has a different signature from AsyncLocalStorage,\n * matching [AsyncContext.Variable](https://github.com/tc39/proposal-async-context).\n * We don't need a full AsyncContext adapter here, just having `.get()` is enough\n */\nexport function createLocalRequestContext(): RunnableBuiltinRequestContext {\n  const storage = createAsyncLocalStorage<BuiltinRequestContextValue>()\n  return {\n    get: () => storage.getStore(),\n    run: (value, callback) => storage.run(value, callback),\n  }\n}\n"],"names":["createAsyncLocalStorage","getBuiltinRequestContext","_globalThis","globalThis","ctx","NEXT_REQUEST_CONTEXT_SYMBOL","VERCEL_REQUEST_CONTEXT_SYMBOL","get","Symbol","for","createLocalRequestContext","storage","getStore","run","value","callback"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ,oCAAmC;;AAEpE,SAASC;IAGd,MAAMC,cAAcC;IACpB,MAAMC,MACJF,WAAW,CAACG,4BAA4B,IACxCH,WAAW,CAACI,8BAA8B;IAC5C,OAAOF,OAAAA,OAAAA,KAAAA,IAAAA,IAAKG,GAAG;AACjB;AAEA,4EAA4E,GAC5E,MAAMF,8BAA8BG,OAAOC,GAAG,CAAC;AAE/C,+CAA+C;AAC/C,iFAAiF;AACjF,MAAMH,gCAAgCE,OAAOC,GAAG,CAAC;AA2B1C,SAASC;IACd,MAAMC,kNAAUX,0BAAAA;IAChB,OAAO;QACLO,KAAK,IAAMI,QAAQC,QAAQ;QAC3BC,KAAK,CAACC,OAAOC,WAAaJ,QAAQE,GAAG,CAACC,OAAOC;IAC/C;AACF","ignoreList":[0]}},
    {"offset": {"line": 1084, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1090, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/after/revalidation-utils.ts"],"sourcesContent":["import type { WorkStore } from '../app-render/work-async-storage.external'\n\n/** Run a callback, and execute any *new* revalidations added during its runtime. */\nexport async function withExecuteRevalidates<T>(\n  store: WorkStore | undefined,\n  callback: () => Promise<T>\n): Promise<T> {\n  if (!store) {\n    return callback()\n  }\n  // If we executed any revalidates during the request, then we don't want to execute them again.\n  // save the state so we can check if anything changed after we're done running callbacks.\n  const savedRevalidationState = cloneRevalidationState(store)\n  try {\n    return await callback()\n  } finally {\n    // Check if we have any new revalidates, and if so, wait until they are all resolved.\n    const newRevalidates = diffRevalidationState(\n      savedRevalidationState,\n      cloneRevalidationState(store)\n    )\n    await executeRevalidates(store, newRevalidates)\n  }\n}\n\ntype RevalidationState = Required<\n  Pick<\n    WorkStore,\n    'revalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n  >\n>\n\nfunction cloneRevalidationState(store: WorkStore): RevalidationState {\n  return {\n    revalidatedTags: store.revalidatedTags ? [...store.revalidatedTags] : [],\n    pendingRevalidates: { ...store.pendingRevalidates },\n    pendingRevalidateWrites: store.pendingRevalidateWrites\n      ? [...store.pendingRevalidateWrites]\n      : [],\n  }\n}\n\nfunction diffRevalidationState(\n  prev: RevalidationState,\n  curr: RevalidationState\n): RevalidationState {\n  const prevTags = new Set(prev.revalidatedTags)\n  const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n  return {\n    revalidatedTags: curr.revalidatedTags.filter((tag) => !prevTags.has(tag)),\n    pendingRevalidates: Object.fromEntries(\n      Object.entries(curr.pendingRevalidates).filter(\n        ([key]) => !(key in prev.pendingRevalidates)\n      )\n    ),\n    pendingRevalidateWrites: curr.pendingRevalidateWrites.filter(\n      (promise) => !prevRevalidateWrites.has(promise)\n    ),\n  }\n}\n\nasync function executeRevalidates(\n  workStore: WorkStore,\n  {\n    revalidatedTags,\n    pendingRevalidates,\n    pendingRevalidateWrites,\n  }: RevalidationState\n) {\n  return Promise.all([\n    workStore.incrementalCache?.revalidateTag(revalidatedTags),\n    ...Object.values(pendingRevalidates),\n    ...pendingRevalidateWrites,\n  ])\n}\n"],"names":["withExecuteRevalidates","store","callback","savedRevalidationState","cloneRevalidationState","newRevalidates","diffRevalidationState","executeRevalidates","revalidatedTags","pendingRevalidates","pendingRevalidateWrites","prev","curr","prevTags","Set","prevRevalidateWrites","filter","tag","has","Object","fromEntries","entries","key","promise","workStore","Promise","all","incrementalCache","revalidateTag","values"],"mappings":"AAEA,kFAAkF,GAClF;;;AAAO,eAAeA,uBACpBC,KAA4B,EAC5BC,QAA0B;IAE1B,IAAI,CAACD,OAAO;QACV,OAAOC;IACT;IACA,+FAA+F;IAC/F,yFAAyF;IACzF,MAAMC,yBAAyBC,uBAAuBH;IACtD,IAAI;QACF,OAAO,MAAMC;IACf,SAAU;QACR,qFAAqF;QACrF,MAAMG,iBAAiBC,sBACrBH,wBACAC,uBAAuBH;QAEzB,MAAMM,mBAAmBN,OAAOI;IAClC;AACF;AASA,SAASD,uBAAuBH,KAAgB;IAC9C,OAAO;QACLO,iBAAiBP,MAAMO,eAAe,GAAG;eAAIP,MAAMO,eAAe;SAAC,GAAG,EAAE;QACxEC,oBAAoB;YAAE,GAAGR,MAAMQ,kBAAkB;QAAC;QAClDC,yBAAyBT,MAAMS,uBAAuB,GAClD;eAAIT,MAAMS,uBAAuB;SAAC,GAClC,EAAE;IACR;AACF;AAEA,SAASJ,sBACPK,IAAuB,EACvBC,IAAuB;IAEvB,MAAMC,WAAW,IAAIC,IAAIH,KAAKH,eAAe;IAC7C,MAAMO,uBAAuB,IAAID,IAAIH,KAAKD,uBAAuB;IACjE,OAAO;QACLF,iBAAiBI,KAAKJ,eAAe,CAACQ,MAAM,CAAC,CAACC,MAAQ,CAACJ,SAASK,GAAG,CAACD;QACpER,oBAAoBU,OAAOC,WAAW,CACpCD,OAAOE,OAAO,CAACT,KAAKH,kBAAkB,EAAEO,MAAM,CAC5C,CAAC,CAACM,IAAI,GAAK,CAAEA,CAAAA,OAAOX,KAAKF,kBAAiB;QAG9CC,yBAAyBE,KAAKF,uBAAuB,CAACM,MAAM,CAC1D,CAACO,UAAY,CAACR,qBAAqBG,GAAG,CAACK;IAE3C;AACF;AAEA,eAAehB,mBACbiB,SAAoB,EACpB,EACEhB,eAAe,EACfC,kBAAkB,EAClBC,uBAAuB,EACL;QAGlBc;IADF,OAAOC,QAAQC,GAAG,CAAC;SACjBF,8BAAAA,UAAUG,gBAAgB,KAAA,OAAA,KAAA,IAA1BH,4BAA4BI,aAAa,CAACpB;WACvCW,OAAOU,MAAM,CAACpB;WACdC;KACJ;AACH","ignoreList":[0]}},
    {"offset": {"line": 1138, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1144, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/after/after-context.ts"],"sourcesContent":["import PromiseQueue from 'next/dist/compiled/p-queue'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { AfterCallback, AfterTask } from './after'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { withExecuteRevalidates } from './revalidation-utils'\nimport { bindSnapshot } from '../app-render/async-local-storage'\nimport {\n  workUnitAsyncStorage,\n  type WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\n\nexport type AfterContextOpts = {\n  waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  onClose: RequestLifecycleOpts['onClose'] | undefined\n  onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n}\n\nexport class AfterContext {\n  private waitUntil: RequestLifecycleOpts['waitUntil'] | undefined\n  private onClose: RequestLifecycleOpts['onClose'] | undefined\n  private onTaskError: RequestLifecycleOpts['onAfterTaskError'] | undefined\n\n  private runCallbacksOnClosePromise: Promise<void> | undefined\n  private callbackQueue: PromiseQueue\n  private workUnitStores = new Set<WorkUnitStore>()\n\n  constructor({ waitUntil, onClose, onTaskError }: AfterContextOpts) {\n    this.waitUntil = waitUntil\n    this.onClose = onClose\n    this.onTaskError = onTaskError\n\n    this.callbackQueue = new PromiseQueue()\n    this.callbackQueue.pause()\n  }\n\n  public after(task: AfterTask): void {\n    if (isThenable(task)) {\n      if (!this.waitUntil) {\n        errorWaitUntilNotAvailable()\n      }\n      this.waitUntil(task.catch((error) => this.reportTaskError(error)))\n    } else if (typeof task === 'function') {\n      // TODO(after): implement tracing\n      this.addCallback(task)\n    } else {\n      throw new Error(\n        '`unstable_after()`: Argument must be a promise or a function'\n      )\n    }\n  }\n\n  private addCallback(callback: AfterCallback) {\n    // if something is wrong, throw synchronously, bubbling up to the `unstable_after` callsite.\n    if (!this.waitUntil) {\n      errorWaitUntilNotAvailable()\n    }\n    if (!this.onClose) {\n      throw new InvariantError(\n        'unstable_after: Missing `onClose` implementation'\n      )\n    }\n\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (!workUnitStore) {\n      throw new InvariantError(\n        'Missing workUnitStore in AfterContext.addCallback'\n      )\n    }\n    this.workUnitStores.add(workUnitStore)\n\n    // this should only happen once.\n    if (!this.runCallbacksOnClosePromise) {\n      this.runCallbacksOnClosePromise = this.runCallbacksOnClose()\n      this.waitUntil(this.runCallbacksOnClosePromise)\n    }\n\n    // Bind the callback to the current execution context (i.e. preserve all currently available ALS-es).\n    // We do this because we want all of these to be equivalent in every regard except timing:\n    //   after(() => x())\n    //   after(x())\n    //   await x()\n    const wrappedCallback = bindSnapshot(async () => {\n      try {\n        await callback()\n      } catch (error) {\n        this.reportTaskError(error)\n      }\n    })\n\n    this.callbackQueue.add(wrappedCallback)\n  }\n\n  private async runCallbacksOnClose() {\n    await new Promise<void>((resolve) => this.onClose!(resolve))\n    return this.runCallbacks()\n  }\n\n  private async runCallbacks(): Promise<void> {\n    if (this.callbackQueue.size === 0) return\n\n    for (const workUnitStore of this.workUnitStores) {\n      workUnitStore.phase = 'after'\n    }\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new InvariantError('Missing workStore in AfterContext.runCallbacks')\n    }\n\n    return withExecuteRevalidates(workStore, () => {\n      this.callbackQueue.start()\n      return this.callbackQueue.onIdle()\n    })\n  }\n\n  private reportTaskError(error: unknown) {\n    // TODO(after): this is fine for now, but will need better intergration with our error reporting.\n    // TODO(after): should we log this if we have a onTaskError callback?\n    console.error(\n      'An error occurred in a function passed to `unstable_after()`:',\n      error\n    )\n    if (this.onTaskError) {\n      // this is very defensive, but we really don't want anything to blow up in an error handler\n      try {\n        this.onTaskError?.(error)\n      } catch (handlerError) {\n        console.error(\n          new InvariantError(\n            '`onTaskError` threw while handling an error thrown from an `unstable_after` task',\n            {\n              cause: handlerError,\n            }\n          )\n        )\n      }\n    }\n  }\n}\n\nfunction errorWaitUntilNotAvailable(): never {\n  throw new Error(\n    '`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.'\n  )\n}\n"],"names":["PromiseQueue","InvariantError","isThenable","workAsyncStorage","withExecuteRevalidates","bindSnapshot","workUnitAsyncStorage","AfterContext","constructor","waitUntil","onClose","onTaskError","workUnitStores","Set","callbackQueue","pause","after","task","errorWaitUntilNotAvailable","catch","error","reportTaskError","addCallback","Error","callback","workUnitStore","getStore","add","runCallbacksOnClosePromise","runCallbacksOnClose","wrappedCallback","Promise","resolve","runCallbacks","size","phase","workStore","start","onIdle","console","handlerError","cause"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1254, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1260, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/types.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { Revalidate } from '../lib/revalidate'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: { [segmentPath: string]: string } | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: { [segmentPath: string]: string } | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport type IncrementalCacheEntry = {\n  curRevalidate?: Revalidate\n  // milliseconds to revalidate after\n  revalidateAfter: Revalidate\n  // -1 here dictates a blocking revalidate should be used\n  isStale?: boolean | -1\n  value: IncrementalCacheValue | null\n  isFallback: boolean | undefined\n}\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  revalidate?: Revalidate\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalCacheItem\n  isRevalidating?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport type IncrementalCacheItem = {\n  revalidateAfter?: number | false\n  curRevalidate?: number | false\n  revalidate?: number | false\n  value: IncrementalCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n} | null\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface IncrementalCache {\n  get: (\n    key: string,\n    ctx: {\n      kind: IncrementalCacheKind\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback: boolean\n    }\n  ) => Promise<IncrementalCacheItem>\n  set: (\n    key: string,\n    data: IncrementalCacheValue | null,\n    ctx: {\n      revalidate: Revalidate\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback: boolean\n    }\n  ) => Promise<void>\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind"],"mappings":";;;;;UA+CkBA,eAAAA;;;;;;;GAAAA,mBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA;;UA2IAC,oBAAAA;;;;;;GAAAA,wBAAAA,CAAAA,uBAAAA,CAAAA,CAAAA","ignoreList":[0]}},
    {"offset": {"line": 1281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/utils.ts"],"sourcesContent":["import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalCacheItem,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalCacheItem> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalCacheItem\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  if (response.value?.kind === CachedRouteKind.FETCH) {\n    throw new Error(\n      'Invariant: unexpected cachedResponse of kind fetch in response cache'\n    )\n  }\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    revalidate: response.revalidate,\n    isFallback: response.isFallback,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(response.value.html),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(response.value.html),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): IncrementalCacheKind {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    default:\n      throw new Error(`Unexpected route kind ${routeKind}`)\n  }\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind","RenderResult","RouteKind","fromResponseCacheEntry","cacheEntry","value","kind","PAGES","html","toUnchunkedString","pageData","headers","status","APP_PAGE","postponed","rscData","segmentData","toResponseCacheEntry","response","FETCH","Error","isMiss","isStale","revalidate","isFallback","fromStatic","routeKindToIncrementalCacheKind","routeKind","IMAGE","APP_ROUTE"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1361, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1367, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/index.ts"],"sourcesContent":["import {\n  type IncrementalCache,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n  type IncrementalCacheItem,\n  type ResponseCacheBase,\n  CachedRouteKind,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalCacheItem | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalCacheItem | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({ hasResolved: false, previousCacheEntry: null })\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n    } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        const kind = routeKindToIncrementalCacheKind(context.routeKind)\n\n        let resolved = false\n        let cachedResponse: IncrementalCacheItem = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, {\n                kind,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n                isFallback,\n              })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            if (cachedResponse.value?.kind === CachedRouteKind.FETCH) {\n              throw new Error(\n                `invariant: unexpected cachedResponse of kind fetch in response cache`\n              )\n            }\n\n            resolve({\n              ...cachedResponse,\n              revalidate: cachedResponse.curRevalidate,\n            })\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator({\n            hasResolved: resolved,\n            previousCacheEntry: cachedResponse,\n            isRevalidating: true,\n          })\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          // We want to persist the result only if it has a revalidate value\n          // defined.\n          if (typeof resolveValue.revalidate !== 'undefined') {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                revalidate: resolveValue.revalidate,\n                isRoutePPREnabled,\n                isFallback,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a getStaticProps path is erroring we automatically re-set the\n          // existing cache under a new expiration to prevent non-stop retrying.\n          if (cachedResponse) {\n            await incrementalCache.set(key, cachedResponse.value, {\n              revalidate: Math.min(\n                Math.max(cachedResponse.revalidate || 3, 3),\n                30\n              ),\n              isRoutePPREnabled,\n              isFallback,\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["CachedRouteKind","Batcher","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","ResponseCache","constructor","minimalMode","batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","minimalModeKey","get","responseGenerator","context","hasResolved","previousCacheEntry","incrementalCache","isFallback","isRoutePPREnabled","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kind","routeKind","resolved","cachedResponse","value","FETCH","Error","revalidate","curRevalidate","isStale","isPrefetch","cacheEntry","isRevalidating","undefined","resolveValue","isMiss","set","err","Math","min","max","console","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1509, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1527, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/web.ts"],"sourcesContent":["import { DetachedPromise } from '../../lib/detached-promise'\nimport type { ResponseCacheEntry, ResponseGenerator } from './types'\n\n/**\n * In the web server, there is currently no incremental cache provided and we\n * always SSR the page.\n */\nexport default class WebResponseCache {\n  pendingResponses: Map<string, Promise<ResponseCacheEntry | null>>\n  previousCacheItem?: {\n    key: string\n    entry: ResponseCacheEntry | null\n    expiresAt: number\n  }\n  minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    this.pendingResponses = new Map()\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    Object.assign(this, { minimalMode })\n  }\n\n  public get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: any\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // ensure on-demand revalidate doesn't block normal requests\n    const pendingResponseKey = key\n      ? `${key}-${context.isOnDemandRevalidate ? '1' : '0'}`\n      : null\n\n    const pendingResponse = pendingResponseKey\n      ? this.pendingResponses.get(pendingResponseKey)\n      : null\n    if (pendingResponse) {\n      return pendingResponse\n    }\n\n    const {\n      promise,\n      resolve: resolver,\n      reject: rejecter,\n    } = new DetachedPromise<ResponseCacheEntry | null>()\n    if (pendingResponseKey) {\n      this.pendingResponses.set(pendingResponseKey, promise)\n    }\n\n    let hasResolved = false\n    const resolve = (cacheEntry: ResponseCacheEntry | null) => {\n      if (pendingResponseKey) {\n        // Ensure all reads from the cache get the latest value.\n        this.pendingResponses.set(\n          pendingResponseKey,\n          Promise.resolve(cacheEntry)\n        )\n      }\n      if (!hasResolved) {\n        hasResolved = true\n        resolver(cacheEntry)\n      }\n    }\n\n    // we keep the previous cache entry around to leverage\n    // when the incremental cache is disabled in minimal mode\n    if (\n      pendingResponseKey &&\n      this.minimalMode &&\n      this.previousCacheItem?.key === pendingResponseKey &&\n      this.previousCacheItem.expiresAt > Date.now()\n    ) {\n      resolve(this.previousCacheItem.entry)\n      this.pendingResponses.delete(pendingResponseKey)\n      return promise\n    }\n\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    ;(async () => {\n      try {\n        const cacheEntry = await responseGenerator({ hasResolved })\n        const resolveValue =\n          cacheEntry === null\n            ? null\n            : {\n                ...cacheEntry,\n                isMiss: true,\n              }\n\n        // for on-demand revalidate wait to resolve until cache is set\n        if (!context.isOnDemandRevalidate) {\n          resolve(resolveValue)\n        }\n\n        if (key && cacheEntry && typeof cacheEntry.revalidate !== 'undefined') {\n          this.previousCacheItem = {\n            key: pendingResponseKey || key,\n            entry: cacheEntry,\n            expiresAt: Date.now() + 1000,\n          }\n        } else {\n          this.previousCacheItem = undefined\n        }\n\n        if (context.isOnDemandRevalidate) {\n          resolve(resolveValue)\n        }\n      } catch (err) {\n        // while revalidating in the background we can't reject as\n        // we already resolved the cache entry so log the error here\n        if (hasResolved) {\n          console.error(err)\n        } else {\n          rejecter(err as Error)\n        }\n      } finally {\n        if (pendingResponseKey) {\n          this.pendingResponses.delete(pendingResponseKey)\n        }\n      }\n    })()\n    return promise\n  }\n}\n"],"names":["DetachedPromise","WebResponseCache","constructor","minimalMode","pendingResponses","Map","Object","assign","get","key","responseGenerator","context","pendingResponseKey","isOnDemandRevalidate","pendingResponse","promise","resolve","resolver","reject","rejecter","set","hasResolved","cacheEntry","Promise","previousCacheItem","expiresAt","Date","now","entry","delete","resolveValue","isMiss","revalidate","undefined","err","console","error"],"mappings":";;;AAAA,SAASA,eAAe,QAAQ,6BAA4B;;AAO7C,MAAMC;IASnBC,YAAYC,WAAoB,CAAE;QAChC,IAAI,CAACC,gBAAgB,GAAG,IAAIC;QAC5B,4EAA4E;QAC5E,qEAAqE;QACrEC,OAAOC,MAAM,CAAC,IAAI,EAAE;YAAEJ;QAAY;IACpC;IAEOK,IACLC,GAAkB,EAClBC,iBAAoC,EACpCC,OAIC,EACmC;YA0ClC;QAzCF,4DAA4D;QAC5D,MAAMC,qBAAqBH,MACvB,CAAC,EAAEA,IAAI,CAAC,EAAEE,QAAQE,oBAAoB,GAAG,MAAM,IAAI,CAAC,GACpD;QAEJ,MAAMC,kBAAkBF,qBACpB,IAAI,CAACR,gBAAgB,CAACI,GAAG,CAACI,sBAC1B;QACJ,IAAIE,iBAAiB;YACnB,OAAOA;QACT;QAEA,MAAM,EACJC,OAAO,EACPC,SAASC,QAAQ,EACjBC,QAAQC,QAAQ,EACjB,GAAG,8KAAInB,kBAAAA;QACR,IAAIY,oBAAoB;YACtB,IAAI,CAACR,gBAAgB,CAACgB,GAAG,CAACR,oBAAoBG;QAChD;QAEA,IAAIM,cAAc;QAClB,MAAML,UAAU,CAACM;YACf,IAAIV,oBAAoB;gBACtB,wDAAwD;gBACxD,IAAI,CAACR,gBAAgB,CAACgB,GAAG,CACvBR,oBACAW,QAAQP,OAAO,CAACM;YAEpB;YACA,IAAI,CAACD,aAAa;gBAChBA,cAAc;gBACdJ,SAASK;YACX;QACF;QAEA,sDAAsD;QACtD,yDAAyD;QACzD,IACEV,sBACA,IAAI,CAACT,WAAW,IAChB,CAAA,CAAA,0BAAA,IAAI,CAACqB,iBAAiB,KAAA,OAAA,KAAA,IAAtB,wBAAwBf,GAAG,MAAKG,sBAChC,IAAI,CAACY,iBAAiB,CAACC,SAAS,GAAGC,KAAKC,GAAG,IAC3C;YACAX,QAAQ,IAAI,CAACQ,iBAAiB,CAACI,KAAK;YACpC,IAAI,CAACxB,gBAAgB,CAACyB,MAAM,CAACjB;YAC7B,OAAOG;QACT;QAKE,CAAA;YACA,IAAI;gBACF,MAAMO,aAAa,MAAMZ,kBAAkB;oBAAEW;gBAAY;gBACzD,MAAMS,eACJR,eAAe,OACX,OACA;oBACE,GAAGA,UAAU;oBACbS,QAAQ;gBACV;gBAEN,8DAA8D;gBAC9D,IAAI,CAACpB,QAAQE,oBAAoB,EAAE;oBACjCG,QAAQc;gBACV;gBAEA,IAAIrB,OAAOa,cAAc,OAAOA,WAAWU,UAAU,KAAK,aAAa;oBACrE,IAAI,CAACR,iBAAiB,GAAG;wBACvBf,KAAKG,sBAAsBH;wBAC3BmB,OAAON;wBACPG,WAAWC,KAAKC,GAAG,KAAK;oBAC1B;gBACF,OAAO;oBACL,IAAI,CAACH,iBAAiB,GAAGS;gBAC3B;gBAEA,IAAItB,QAAQE,oBAAoB,EAAE;oBAChCG,QAAQc;gBACV;YACF,EAAE,OAAOI,KAAK;gBACZ,0DAA0D;gBAC1D,4DAA4D;gBAC5D,IAAIb,aAAa;oBACfc,QAAQC,KAAK,CAACF;gBAChB,OAAO;oBACLf,SAASe;gBACX;YACF,SAAU;gBACR,IAAItB,oBAAoB;oBACtB,IAAI,CAACR,gBAAgB,CAACyB,MAAM,CAACjB;gBAC/B;YACF;QACF,CAAA;QACA,OAAOG;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1619, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/types.ts"],"sourcesContent":["import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { Revalidate } from '../lib/revalidate'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: { [segmentPath: string]: string } | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: { [segmentPath: string]: string } | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport type IncrementalCacheEntry = {\n  curRevalidate?: Revalidate\n  // milliseconds to revalidate after\n  revalidateAfter: Revalidate\n  // -1 here dictates a blocking revalidate should be used\n  isStale?: boolean | -1\n  value: IncrementalCacheValue | null\n  isFallback: boolean | undefined\n}\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  revalidate?: Revalidate\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalCacheItem\n  isRevalidating?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport type IncrementalCacheItem = {\n  revalidateAfter?: number | false\n  curRevalidate?: number | false\n  revalidate?: number | false\n  value: IncrementalCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n  isFallback: boolean | undefined\n} | null\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface IncrementalCache {\n  get: (\n    key: string,\n    ctx: {\n      kind: IncrementalCacheKind\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback: boolean\n    }\n  ) => Promise<IncrementalCacheItem>\n  set: (\n    key: string,\n    data: IncrementalCacheValue | null,\n    ctx: {\n      revalidate: Revalidate\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback: boolean\n    }\n  ) => Promise<void>\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind"],"mappings":";;;;;UA+CkBA,eAAAA;;;;;;;GAAAA,mBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA;;UA2IAC,oBAAAA;;;;;;GAAAA,wBAAAA,CAAAA,uBAAAA,CAAAA,CAAAA","ignoreList":[0]}},
    {"offset": {"line": 1640, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1646, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/utils.ts"],"sourcesContent":["import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalCacheItem,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalCacheItem> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalCacheItem\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  if (response.value?.kind === CachedRouteKind.FETCH) {\n    throw new Error(\n      'Invariant: unexpected cachedResponse of kind fetch in response cache'\n    )\n  }\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    revalidate: response.revalidate,\n    isFallback: response.isFallback,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(response.value.html),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(response.value.html),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): IncrementalCacheKind {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    default:\n      throw new Error(`Unexpected route kind ${routeKind}`)\n  }\n}\n"],"names":["CachedRouteKind","IncrementalCacheKind","RenderResult","RouteKind","fromResponseCacheEntry","cacheEntry","value","kind","PAGES","html","toUnchunkedString","pageData","headers","status","APP_PAGE","postponed","rscData","segmentData","toResponseCacheEntry","response","FETCH","Error","isMiss","isStale","revalidate","isFallback","fromStatic","routeKindToIncrementalCacheKind","routeKind","IMAGE","APP_ROUTE"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1720, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1726, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/response-cache/index.ts"],"sourcesContent":["import {\n  type IncrementalCache,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n  type IncrementalCacheItem,\n  type ResponseCacheBase,\n  CachedRouteKind,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly batcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalCacheItem | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalCacheItem | null\n    expiresAt: number\n  }\n\n  private minimalMode?: boolean\n\n  constructor(minimalMode: boolean) {\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] = minimalMode\n  }\n\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({ hasResolved: false, previousCacheEntry: null })\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n    } = context\n\n    const response = await this.batcher.batch(\n      { key, isOnDemandRevalidate },\n      async (cacheKey, resolve) => {\n        // We keep the previous cache entry around to leverage when the\n        // incremental cache is disabled in minimal mode.\n        if (\n          this.minimalMode &&\n          this.previousCacheItem?.key === cacheKey &&\n          this.previousCacheItem.expiresAt > Date.now()\n        ) {\n          return this.previousCacheItem.entry\n        }\n\n        // Coerce the kindHint into a given kind for the incremental cache.\n        const kind = routeKindToIncrementalCacheKind(context.routeKind)\n\n        let resolved = false\n        let cachedResponse: IncrementalCacheItem = null\n        try {\n          cachedResponse = !this.minimalMode\n            ? await incrementalCache.get(key, {\n                kind,\n                isRoutePPREnabled: context.isRoutePPREnabled,\n                isFallback,\n              })\n            : null\n\n          if (cachedResponse && !isOnDemandRevalidate) {\n            if (cachedResponse.value?.kind === CachedRouteKind.FETCH) {\n              throw new Error(\n                `invariant: unexpected cachedResponse of kind fetch in response cache`\n              )\n            }\n\n            resolve({\n              ...cachedResponse,\n              revalidate: cachedResponse.curRevalidate,\n            })\n            resolved = true\n\n            if (!cachedResponse.isStale || context.isPrefetch) {\n              // The cached value is still valid, so we don't need\n              // to update it yet.\n              return null\n            }\n          }\n\n          const cacheEntry = await responseGenerator({\n            hasResolved: resolved,\n            previousCacheEntry: cachedResponse,\n            isRevalidating: true,\n          })\n\n          // If the cache entry couldn't be generated, we don't want to cache\n          // the result.\n          if (!cacheEntry) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          const resolveValue = await fromResponseCacheEntry({\n            ...cacheEntry,\n            isMiss: !cachedResponse,\n          })\n          if (!resolveValue) {\n            // Unset the previous cache item if it was set.\n            if (this.minimalMode) this.previousCacheItem = undefined\n            return null\n          }\n\n          // For on-demand revalidate wait to resolve until cache is set.\n          // Otherwise resolve now.\n          if (!isOnDemandRevalidate && !resolved) {\n            resolve(resolveValue)\n            resolved = true\n          }\n\n          // We want to persist the result only if it has a revalidate value\n          // defined.\n          if (typeof resolveValue.revalidate !== 'undefined') {\n            if (this.minimalMode) {\n              this.previousCacheItem = {\n                key: cacheKey,\n                entry: resolveValue,\n                expiresAt: Date.now() + 1000,\n              }\n            } else {\n              await incrementalCache.set(key, resolveValue.value, {\n                revalidate: resolveValue.revalidate,\n                isRoutePPREnabled,\n                isFallback,\n              })\n            }\n          }\n\n          return resolveValue\n        } catch (err) {\n          // When a getStaticProps path is erroring we automatically re-set the\n          // existing cache under a new expiration to prevent non-stop retrying.\n          if (cachedResponse) {\n            await incrementalCache.set(key, cachedResponse.value, {\n              revalidate: Math.min(\n                Math.max(cachedResponse.revalidate || 3, 3),\n                30\n              ),\n              isRoutePPREnabled,\n              isFallback,\n            })\n          }\n\n          // While revalidating in the background we can't reject as we already\n          // resolved the cache entry so log the error here.\n          if (resolved) {\n            console.error(err)\n            return null\n          }\n\n          // We haven't resolved yet, so let's throw to indicate an error.\n          throw err\n        }\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n}\n"],"names":["CachedRouteKind","Batcher","scheduleOnNextTick","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","ResponseCache","constructor","minimalMode","batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","minimalModeKey","get","responseGenerator","context","hasResolved","previousCacheEntry","incrementalCache","isFallback","isRoutePPREnabled","response","batch","cacheKey","resolve","previousCacheItem","expiresAt","Date","now","entry","kind","routeKind","resolved","cachedResponse","value","FETCH","Error","revalidate","curRevalidate","isStale","isPrefetch","cacheEntry","isRevalidating","undefined","resolveValue","isMiss","set","err","Math","min","max","console","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1868, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1886, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/stream-utils/encodedTags.ts"],"sourcesContent":["export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n} as const\n"],"names":["ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML"],"mappings":";;;AAAO,MAAMA,eAAe;IAC1B,iHAAiH;IACjHC,SAAS;QACP,QAAQ;QACRC,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAK;YAAK;YAAK;SAAI;QAC7C,QAAQ;QACRC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;SAAI;IAC9C;IACAE,QAAQ;QACN,UAAU;QACVC,MAAM,IAAIH,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAI;YAAK;SAAG;QACpD,UAAU;QACVC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;SAAG;QACpD,UAAU;QACVD,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAAG;QACrD,iBAAiB;QACjBI,eAAe,IAAIJ,WAAW;YAC5B;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAC5D;IACH;AACF,EAAU","ignoreList":[0]}},
    {"offset": {"line": 1959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1965, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/stream-utils/uint8array-helpers.ts"],"sourcesContent":["/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n"],"names":["indexOfUint8Array","a","b","length","i","completeMatch","j","isEquivalentUint8Arrays","removeFromUint8Array","tagIndex","subarray","removed","Uint8Array","set","slice"],"mappings":"AAAA;;CAEC,GACD;;;;;AAAO,SAASA,kBAAkBC,CAAa,EAAEC,CAAa;IAC5D,IAAIA,EAAEC,MAAM,KAAK,GAAG,OAAO;IAC3B,IAAIF,EAAEE,MAAM,KAAK,KAAKD,EAAEC,MAAM,GAAGF,EAAEE,MAAM,EAAE,OAAO,CAAC;IAEnD,8BAA8B;IAC9B,IAAK,IAAIC,IAAI,GAAGA,KAAKH,EAAEE,MAAM,GAAGD,EAAEC,MAAM,EAAEC,IAAK;QAC7C,IAAIC,gBAAgB;QACpB,6DAA6D;QAC7D,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,EAAEC,MAAM,EAAEG,IAAK;YACjC,2HAA2H;YAC3H,IAAIL,CAAC,CAACG,IAAIE,EAAE,KAAKJ,CAAC,CAACI,EAAE,EAAE;gBACrBD,gBAAgB;gBAChB;YACF;QACF;QAEA,IAAIA,eAAe;YACjB,OAAOD;QACT;IACF;IAEA,OAAO,CAAC;AACV;AAKO,SAASG,wBAAwBN,CAAa,EAAEC,CAAa;IAClE,IAAID,EAAEE,MAAM,KAAKD,EAAEC,MAAM,EAAE,OAAO;IAElC,IAAK,IAAIC,IAAI,GAAGA,IAAIH,EAAEE,MAAM,EAAEC,IAAK;QACjC,IAAIH,CAAC,CAACG,EAAE,KAAKF,CAAC,CAACE,EAAE,EAAE,OAAO;IAC5B;IAEA,OAAO;AACT;AASO,SAASI,qBAAqBP,CAAa,EAAEC,CAAa;IAC/D,MAAMO,WAAWT,kBAAkBC,GAAGC;IACtC,IAAIO,aAAa,GAAG,OAAOR,EAAES,QAAQ,CAACR,EAAEC,MAAM;IAC9C,IAAIM,WAAW,CAAC,GAAG;QACjB,MAAME,UAAU,IAAIC,WAAWX,EAAEE,MAAM,GAAGD,EAAEC,MAAM;QAClDQ,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAAC,GAAGL;QACvBE,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAACL,WAAWP,EAAEC,MAAM,GAAGM;QAC1C,OAAOE;IACT,OAAO;QACL,OAAOV;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2011, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2017, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":["import { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encodedTags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\nexport type ReactReadableStream = ReadableStream<Uint8Array> & {\n  allReady?: Promise<void> | undefined\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // We could encode this invariant in the arguments but current uses of this function pass\n  // use spread so it would be missed by\n  if (streams.length === 0) {\n    throw new Error('Invariant: chainStreams requires at least one stream')\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport function createBufferedTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    // If we already have a pending flush, then return early.\n    if (pending) return\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        const chunk = new Uint8Array(bufferByteLength)\n        let copiedBytes = 0\n\n        for (let i = 0; i < bufferedChunks.length; i++) {\n          const bufferedChunk = bufferedChunks[i]\n          chunk.set(bufferedChunk, copiedBytes)\n          copiedBytes += bufferedChunk.byteLength\n        }\n        // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n        // and our bufferByteLength to prepare for the next round of buffered chunks\n        bufferedChunks.length = 0\n        bufferByteLength = 0\n        controller.enqueue(chunk)\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      // Flush the buffer to the controller.\n      flush(controller)\n    },\n    flush() {\n      if (!pending) return\n\n      return pending.promise\n    },\n  })\n}\n\nfunction createInsertedHTMLStream(\n  getServerInsertedHTML: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const html = await getServerInsertedHTML()\n      if (html) {\n        controller.enqueue(encoder.encode(html))\n      }\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: typeof import('react-dom/server.edge')\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n  let freezing = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n      // While react is flushing chunks, we don't apply insertions\n      if (freezing) {\n        controller.enqueue(chunk)\n        return\n      }\n\n      const insertion = await insert()\n\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n        freezing = true\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            insertedHeadContent.set(chunk.slice(0, index))\n            insertedHeadContent.set(encodedInsertion, index)\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          freezing = true\n          inserted = true\n        }\n      }\n\n      if (!inserted) {\n        controller.enqueue(chunk)\n      } else {\n        scheduleImmediate(() => {\n          freezing = false\n        })\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\n// Merge two streams into one. Ensure the final transform stream is closed\n// when both are finished.\nfunction createMergedTransformStream(\n  stream: ReadableStream<Uint8Array>\n): TransformStream<Uint8Array, Uint8Array> {\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    if (pull) {\n      return\n    }\n\n    const reader = stream.getReader()\n\n    // NOTE: streaming flush\n    // We are buffering here for the inlined data stream because the\n    // \"shell\" stream might be chunkenized again by the underlying stream\n    // implementation, e.g. with a specific high-water mark. To ensure it's\n    // the safe timing to pipe the data stream, this extra tick is\n    // necessary.\n\n    // We don't start reading until we've left the current Task to ensure\n    // that it's inserted after flushing the shell. Note that this implementation\n    // might get stale if impl details of Fizz change in the future.\n    await atLeastOneTask()\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (!pull) {\n        pull = startPulling(controller)\n      }\n    },\n    flush(controller) {\n      if (donePulling) {\n        return\n      }\n      return pull || startPulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: typeof window.__next_root_layout_missing_tags = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<script>self.__next_root_layout_missing_tags=${JSON.stringify(\n            missingTags\n          )}</script>`\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  getServerInsertedHTML: (() => Promise<string>) | undefined\n  serverInsertedHTMLToHead: boolean\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    getServerInsertedHTML,\n    serverInsertedHTMLToHead,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML and there's an `allReady` promise on the\n  // stream, we need to wait for it to resolve before continuing.\n  if (isStaticGeneration && 'allReady' in renderStream) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Insert generated tags to head\n    getServerInsertedHTML && !serverInsertedHTMLToHead\n      ? createInsertedHTMLStream(getServerInsertedHTML)\n      : null,\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    getServerInsertedHTML && serverInsertedHTMLToHead\n      ? createHeadInsertionTransformStream(getServerInsertedHTML)\n      : null,\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  { getServerInsertedHTML }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  { inlinedDataStream, getServerInsertedHTML }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  { inlinedDataStream, getServerInsertedHTML }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n"],"names":["getTracer","AppRenderSpan","DetachedPromise","scheduleImmediate","atLeastOneTask","ENCODED_TAGS","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","voidCatch","encoder","TextEncoder","chainStreams","streams","length","Error","readable","writable","TransformStream","promise","pipeTo","preventClose","i","nextStream","then","lastStream","catch","streamFromString","str","ReadableStream","start","controller","enqueue","encode","close","streamFromBuffer","chunk","streamToBuffer","stream","reader","getReader","chunks","done","value","read","push","Buffer","concat","streamToString","decoder","TextDecoder","fatal","string","decode","createBufferedTransformStream","bufferedChunks","bufferByteLength","pending","flush","detached","Uint8Array","copiedBytes","bufferedChunk","set","byteLength","undefined","resolve","transform","createInsertedHTMLStream","getServerInsertedHTML","html","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","trace","renderToReadableStream","createHeadInsertionTransformStream","insert","inserted","freezing","hasBytes","insertion","encodedInsertion","index","CLOSED","HEAD","insertedHeadContent","slice","createDeferredSuffixStream","suffix","flushed","createMergedTransformStream","pull","donePulling","startPulling","err","error","CLOSE_TAG","createMoveSuffixStream","foundSuffix","BODY_AND_HTML","before","after","createStripDocumentClosingTagsTransform","BODY","HTML","createRootLayoutValidatorStream","foundHtml","foundBody","OPENING","missingTags","JSON","stringify","chainTransformers","transformers","transformer","pipeThrough","continueFizzStream","renderStream","inlinedDataStream","isStaticGeneration","serverInsertedHTMLToHead","validateRootLayout","suffixUnclosed","split","allReady","continueDynamicPrerender","prerenderStream","continueStaticPrerender","continueDynamicHTMLResume","createDocumentClosingStream"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2482, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/stream-utils/encodedTags.ts"],"sourcesContent":["export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n} as const\n"],"names":["ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML"],"mappings":";;;AAAO,MAAMA,eAAe;IAC1B,iHAAiH;IACjHC,SAAS;QACP,QAAQ;QACRC,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAK;YAAK;YAAK;SAAI;QAC7C,QAAQ;QACRC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;SAAI;IAC9C;IACAE,QAAQ;QACN,UAAU;QACVC,MAAM,IAAIH,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAI;YAAK;SAAG;QACpD,UAAU;QACVC,MAAM,IAAID,WAAW;YAAC;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;SAAG;QACpD,UAAU;QACVD,MAAM,IAAIC,WAAW;YAAC;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAAG;QACrD,iBAAiB;QACjBI,eAAe,IAAIJ,WAAW;YAC5B;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAI;YAAI;YAAI;YAAK;YAAK;YAAK;YAAK;SAC5D;IACH;AACF,EAAU","ignoreList":[0]}},
    {"offset": {"line": 2555, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2561, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/stream-utils/uint8array-helpers.ts"],"sourcesContent":["/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n"],"names":["indexOfUint8Array","a","b","length","i","completeMatch","j","isEquivalentUint8Arrays","removeFromUint8Array","tagIndex","subarray","removed","Uint8Array","set","slice"],"mappings":"AAAA;;CAEC,GACD;;;;;AAAO,SAASA,kBAAkBC,CAAa,EAAEC,CAAa;IAC5D,IAAIA,EAAEC,MAAM,KAAK,GAAG,OAAO;IAC3B,IAAIF,EAAEE,MAAM,KAAK,KAAKD,EAAEC,MAAM,GAAGF,EAAEE,MAAM,EAAE,OAAO,CAAC;IAEnD,8BAA8B;IAC9B,IAAK,IAAIC,IAAI,GAAGA,KAAKH,EAAEE,MAAM,GAAGD,EAAEC,MAAM,EAAEC,IAAK;QAC7C,IAAIC,gBAAgB;QACpB,6DAA6D;QAC7D,IAAK,IAAIC,IAAI,GAAGA,IAAIJ,EAAEC,MAAM,EAAEG,IAAK;YACjC,2HAA2H;YAC3H,IAAIL,CAAC,CAACG,IAAIE,EAAE,KAAKJ,CAAC,CAACI,EAAE,EAAE;gBACrBD,gBAAgB;gBAChB;YACF;QACF;QAEA,IAAIA,eAAe;YACjB,OAAOD;QACT;IACF;IAEA,OAAO,CAAC;AACV;AAKO,SAASG,wBAAwBN,CAAa,EAAEC,CAAa;IAClE,IAAID,EAAEE,MAAM,KAAKD,EAAEC,MAAM,EAAE,OAAO;IAElC,IAAK,IAAIC,IAAI,GAAGA,IAAIH,EAAEE,MAAM,EAAEC,IAAK;QACjC,IAAIH,CAAC,CAACG,EAAE,KAAKF,CAAC,CAACE,EAAE,EAAE,OAAO;IAC5B;IAEA,OAAO;AACT;AASO,SAASI,qBAAqBP,CAAa,EAAEC,CAAa;IAC/D,MAAMO,WAAWT,kBAAkBC,GAAGC;IACtC,IAAIO,aAAa,GAAG,OAAOR,EAAES,QAAQ,CAACR,EAAEC,MAAM;IAC9C,IAAIM,WAAW,CAAC,GAAG;QACjB,MAAME,UAAU,IAAIC,WAAWX,EAAEE,MAAM,GAAGD,EAAEC,MAAM;QAClDQ,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAAC,GAAGL;QACvBE,QAAQE,GAAG,CAACZ,EAAEa,KAAK,CAACL,WAAWP,EAAEC,MAAM,GAAGM;QAC1C,OAAOE;IACT,OAAO;QACL,OAAOV;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2613, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/stream-utils/node-web-streams-helper.ts"],"sourcesContent":["import { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encodedTags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\nexport type ReactReadableStream = ReadableStream<Uint8Array> & {\n  allReady?: Promise<void> | undefined\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // We could encode this invariant in the arguments but current uses of this function pass\n  // use spread so it would be missed by\n  if (streams.length === 0) {\n    throw new Error('Invariant: chainStreams requires at least one stream')\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport function createBufferedTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    // If we already have a pending flush, then return early.\n    if (pending) return\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        const chunk = new Uint8Array(bufferByteLength)\n        let copiedBytes = 0\n\n        for (let i = 0; i < bufferedChunks.length; i++) {\n          const bufferedChunk = bufferedChunks[i]\n          chunk.set(bufferedChunk, copiedBytes)\n          copiedBytes += bufferedChunk.byteLength\n        }\n        // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n        // and our bufferByteLength to prepare for the next round of buffered chunks\n        bufferedChunks.length = 0\n        bufferByteLength = 0\n        controller.enqueue(chunk)\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      // Flush the buffer to the controller.\n      flush(controller)\n    },\n    flush() {\n      if (!pending) return\n\n      return pending.promise\n    },\n  })\n}\n\nfunction createInsertedHTMLStream(\n  getServerInsertedHTML: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const html = await getServerInsertedHTML()\n      if (html) {\n        controller.enqueue(encoder.encode(html))\n      }\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: typeof import('react-dom/server.edge')\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n  let freezing = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n      // While react is flushing chunks, we don't apply insertions\n      if (freezing) {\n        controller.enqueue(chunk)\n        return\n      }\n\n      const insertion = await insert()\n\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n        freezing = true\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            insertedHeadContent.set(chunk.slice(0, index))\n            insertedHeadContent.set(encodedInsertion, index)\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          freezing = true\n          inserted = true\n        }\n      }\n\n      if (!inserted) {\n        controller.enqueue(chunk)\n      } else {\n        scheduleImmediate(() => {\n          freezing = false\n        })\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\n// Merge two streams into one. Ensure the final transform stream is closed\n// when both are finished.\nfunction createMergedTransformStream(\n  stream: ReadableStream<Uint8Array>\n): TransformStream<Uint8Array, Uint8Array> {\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    if (pull) {\n      return\n    }\n\n    const reader = stream.getReader()\n\n    // NOTE: streaming flush\n    // We are buffering here for the inlined data stream because the\n    // \"shell\" stream might be chunkenized again by the underlying stream\n    // implementation, e.g. with a specific high-water mark. To ensure it's\n    // the safe timing to pipe the data stream, this extra tick is\n    // necessary.\n\n    // We don't start reading until we've left the current Task to ensure\n    // that it's inserted after flushing the shell. Note that this implementation\n    // might get stale if impl details of Fizz change in the future.\n    await atLeastOneTask()\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (!pull) {\n        pull = startPulling(controller)\n      }\n    },\n    flush(controller) {\n      if (donePulling) {\n        return\n      }\n      return pull || startPulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: typeof window.__next_root_layout_missing_tags = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<script>self.__next_root_layout_missing_tags=${JSON.stringify(\n            missingTags\n          )}</script>`\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  getServerInsertedHTML: (() => Promise<string>) | undefined\n  serverInsertedHTMLToHead: boolean\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    getServerInsertedHTML,\n    serverInsertedHTMLToHead,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML and there's an `allReady` promise on the\n  // stream, we need to wait for it to resolve before continuing.\n  if (isStaticGeneration && 'allReady' in renderStream) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Insert generated tags to head\n    getServerInsertedHTML && !serverInsertedHTMLToHead\n      ? createInsertedHTMLStream(getServerInsertedHTML)\n      : null,\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    getServerInsertedHTML && serverInsertedHTMLToHead\n      ? createHeadInsertionTransformStream(getServerInsertedHTML)\n      : null,\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  { getServerInsertedHTML }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  { inlinedDataStream, getServerInsertedHTML }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  { inlinedDataStream, getServerInsertedHTML }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n"],"names":["getTracer","AppRenderSpan","DetachedPromise","scheduleImmediate","atLeastOneTask","ENCODED_TAGS","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","voidCatch","encoder","TextEncoder","chainStreams","streams","length","Error","readable","writable","TransformStream","promise","pipeTo","preventClose","i","nextStream","then","lastStream","catch","streamFromString","str","ReadableStream","start","controller","enqueue","encode","close","streamFromBuffer","chunk","streamToBuffer","stream","reader","getReader","chunks","done","value","read","push","Buffer","concat","streamToString","decoder","TextDecoder","fatal","string","decode","createBufferedTransformStream","bufferedChunks","bufferByteLength","pending","flush","detached","Uint8Array","copiedBytes","bufferedChunk","set","byteLength","undefined","resolve","transform","createInsertedHTMLStream","getServerInsertedHTML","html","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","trace","renderToReadableStream","createHeadInsertionTransformStream","insert","inserted","freezing","hasBytes","insertion","encodedInsertion","index","CLOSED","HEAD","insertedHeadContent","slice","createDeferredSuffixStream","suffix","flushed","createMergedTransformStream","pull","donePulling","startPulling","err","error","CLOSE_TAG","createMoveSuffixStream","foundSuffix","BODY_AND_HTML","before","after","createStripDocumentClosingTagsTransform","BODY","HTML","createRootLayoutValidatorStream","foundHtml","foundBody","OPENING","missingTags","JSON","stringify","chainTransformers","transformers","transformer","pipeThrough","continueFizzStream","renderStream","inlinedDataStream","isStaticGeneration","serverInsertedHTMLToHead","validateRootLayout","suffixUnclosed","split","allReady","continueDynamicPrerender","prerenderStream","continueStaticPrerender","continueDynamicHTMLResume","createDocumentClosingStream"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3078, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/request-meta.ts"],"sourcesContent":["/* eslint-disable no-redeclare */\nimport type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type { ServerComponentsHmrCache } from './response-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: any\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntry?: (\n    cacheEntry: any,\n    requestMeta: any\n  ) => Promise<boolean | void> | boolean | void\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the default route matches were set on the request during routing.\n   */\n  didSetDefaultRouteMatches?: boolean\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  __nextNotFoundSrcPage?: string\n  __nextDefaultLocale?: string\n  __nextFallback?: 'true'\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   *\n   * When this property is mutated, it's important to also update the request\n   * metadata for `_nextInferredDefaultLocale` to ensure that the correct\n   * behavior is applied.\n   */\n  __nextLocale?: string\n\n  /**\n   * `1` when the request did not have a locale in the pathname part of the\n   * URL but the default locale was inferred from either the domain or the\n   * configuration.\n   */\n  __nextInferredLocaleFromDefault?: '1'\n\n  __nextSsgPath?: string\n  _nextBubbleNoFallback?: '1'\n\n  /**\n   * When set to `1`, the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  __nextDataReq?: '1'\n  __nextCustomErrorRender?: '1'\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery &\n  NextQueryMetadata & {\n    amp?: '1'\n  }\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n\nexport function getNextInternalQuery(\n  query: NextParsedUrlQuery\n): NextQueryMetadata {\n  const keysToInclude: (keyof NextQueryMetadata)[] = [\n    '__nextDefaultLocale',\n    '__nextFallback',\n    '__nextLocale',\n    '__nextSsgPath',\n    '_nextBubbleNoFallback',\n    '__nextDataReq',\n    '__nextInferredLocaleFromDefault',\n  ]\n  const nextInternalQuery: NextQueryMetadata = {}\n\n  for (const key of keysToInclude) {\n    if (key in query) {\n      // @ts-ignore this can't be typed correctly\n      nextInternalQuery[key] = query[key]\n    }\n  }\n\n  return nextInternalQuery\n}\n"],"names":["NEXT_REQUEST_META","Symbol","for","getRequestMeta","req","key","meta","setRequestMeta","addRequestMeta","request","value","removeRequestMeta","getNextInternalQuery","query","keysToInclude","nextInternalQuery"],"mappings":"AAAA,+BAA+B,GAU/B,kGAAkG;;;;;;;;;AAC3F,MAAMA,oBAAoBC,OAAOC,GAAG,CAAC,2BAA0B;AAqJ/D,SAASC,eACdC,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACJ,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOK,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASC,eAAeH,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACJ,kBAAkB,GAAGM;IACzB,OAAOA;AACT;AAUO,SAASE,eACdC,OAA4B,EAC5BJ,GAAM,EACNK,KAAqB;IAErB,MAAMJ,OAAOH,eAAeM;IAC5BH,IAAI,CAACD,IAAI,GAAGK;IACZ,OAAOH,eAAeE,SAASH;AACjC;AASO,SAASK,kBACdF,OAA4B,EAC5BJ,GAAM;IAEN,MAAMC,OAAOH,eAAeM;IAC5B,OAAOH,IAAI,CAACD,IAAI;IAChB,OAAOE,eAAeE,SAASH;AACjC;AA4CO,SAASM,qBACdC,KAAyB;IAEzB,MAAMC,gBAA6C;QACjD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACD,MAAMC,oBAAuC,CAAC;IAE9C,KAAK,MAAMV,OAAOS,cAAe;QAC/B,IAAIT,OAAOQ,OAAO;YAChB,2CAA2C;YAC3CE,iBAAiB,CAACV,IAAI,GAAGQ,KAAK,CAACR,IAAI;QACrC;IACF;IAEA,OAAOU;AACT","ignoreList":[0]}},
    {"offset": {"line": 3125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3131, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/base-http/helpers.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n"],"names":["isWebNextRequest","req","process","env","NEXT_RUNTIME","isWebNextResponse","res","isNodeNextRequest","isNodeNextResponse"],"mappings":"AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD;;;;;;AAAO,MAAMA,mBAAmB,CAACC,MAC/BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQ9B,MAAMC,oBAAoB,CAC/BC,MAC2BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMG,oBAAoB,CAC/BN,MAC2BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMI,qBAAqB,CAChCF,MAC4BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM","ignoreList":[0]}},
    {"offset": {"line": 3151, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3157, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/base-http/index.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { I18NConfig } from '../config-shared'\n\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport type { NextApiRequestCookies } from '../api-utils'\nimport { getCookieParser } from '../api-utils/get-cookie-parser'\n\nexport interface BaseNextRequestConfig {\n  basePath: string | undefined\n  i18n?: I18NConfig\n  trailingSlash?: boolean | undefined\n}\n\nexport type FetchMetric = {\n  url: string\n  idx: number\n  end: number\n  start: number\n  method: string\n  status: number\n  cacheReason: string\n  cacheStatus: 'hit' | 'miss' | 'skip' | 'hmr'\n  cacheWarning?: string\n}\n\nexport type FetchMetrics = Array<FetchMetric>\n\nexport abstract class BaseNextRequest<Body = any> {\n  protected _cookies: NextApiRequestCookies | undefined\n  public abstract headers: IncomingHttpHeaders\n  public abstract fetchMetrics: FetchMetric[] | undefined\n\n  constructor(\n    public method: string,\n    public url: string,\n    public body: Body\n  ) {}\n\n  // Utils implemented using the abstract methods above\n\n  public get cookies() {\n    if (this._cookies) return this._cookies\n    return (this._cookies = getCookieParser(this.headers)())\n  }\n}\n\nexport abstract class BaseNextResponse<Destination = any> {\n  abstract statusCode: number | undefined\n  abstract statusMessage: string | undefined\n  abstract get sent(): boolean\n\n  constructor(public destination: Destination) {}\n\n  /**\n   * Sets a value for the header overwriting existing values\n   */\n  abstract setHeader(name: string, value: string | string[]): this\n\n  /**\n   * Removes a header\n   */\n  abstract removeHeader(name: string): this\n\n  /**\n   * Appends value for the given header name\n   */\n  abstract appendHeader(name: string, value: string): this\n\n  /**\n   * Get all vaues for a header as an array or undefined if no value is present\n   */\n  abstract getHeaderValues(name: string): string[] | undefined\n\n  abstract hasHeader(name: string): boolean\n\n  /**\n   * Get vaues for a header concatenated using `,` or undefined if no value is present\n   */\n  abstract getHeader(name: string): string | undefined\n\n  abstract getHeaders(): OutgoingHttpHeaders\n\n  abstract body(value: string): this\n\n  abstract send(): void\n\n  abstract onClose(callback: () => void): void\n\n  // Utils implemented using the abstract methods above\n\n  public redirect(destination: string, statusCode: number) {\n    this.setHeader('Location', destination)\n    this.statusCode = statusCode\n\n    // Since IE11 doesn't support the 308 header add backwards\n    // compatibility using refresh header\n    if (statusCode === RedirectStatusCode.PermanentRedirect) {\n      this.setHeader('Refresh', `0;url=${destination}`)\n    }\n\n    return this\n  }\n}\n"],"names":["RedirectStatusCode","getCookieParser","BaseNextRequest","constructor","method","url","body","cookies","_cookies","headers","BaseNextResponse","destination","redirect","statusCode","setHeader","PermanentRedirect"],"mappings":";;;;AAGA,SAASA,kBAAkB,QAAQ,+CAA8C;AAEjF,SAASC,eAAe,QAAQ,iCAAgC;;;AAsBzD,MAAeC;IAKpBC,YACSC,MAAc,EACdC,GAAW,EACXC,IAAU,CACjB;aAHOF,MAAAA,GAAAA;aACAC,GAAAA,GAAAA;aACAC,IAAAA,GAAAA;IACN;IAEH,qDAAqD;IAErD,IAAWC,UAAU;QACnB,IAAI,IAAI,CAACC,QAAQ,EAAE,OAAO,IAAI,CAACA,QAAQ;QACvC,OAAQ,IAAI,CAACA,QAAQ,wMAAGP,kBAAAA,EAAgB,IAAI,CAACQ,OAAO;IACtD;AACF;AAEO,MAAeC;IAKpBP,YAAmBQ,WAAwB,CAAE;aAA1BA,WAAAA,GAAAA;IAA2B;IAqC9C,qDAAqD;IAE9CC,SAASD,WAAmB,EAAEE,UAAkB,EAAE;QACvD,IAAI,CAACC,SAAS,CAAC,YAAYH;QAC3B,IAAI,CAACE,UAAU,GAAGA;QAElB,0DAA0D;QAC1D,qCAAqC;QACrC,IAAIA,iNAAeb,qBAAAA,CAAmBe,iBAAiB,EAAE;YACvD,IAAI,CAACD,SAAS,CAAC,WAAW,CAAC,MAAM,EAAEH,YAAY,CAAC;QAClD;QAEA,OAAO,IAAI;IACb;AACF","ignoreList":[0]}},
    {"offset": {"line": 3193, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3199, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/base-http/web.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { FetchMetrics } from './index'\n\nimport { toNodeOutgoingHttpHeaders } from '../web/utils'\nimport { BaseNextRequest, BaseNextResponse } from './index'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport type { NextRequestHint } from '../web/adapter'\nimport { CloseController, trackBodyConsumed } from '../web/web-on-close'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nexport class WebNextRequest extends BaseNextRequest<ReadableStream | null> {\n  public request: Request\n  public headers: IncomingHttpHeaders\n  public fetchMetrics: FetchMetrics | undefined\n\n  constructor(request: NextRequestHint) {\n    const url = new URL(request.url)\n\n    super(\n      request.method,\n      url.href.slice(url.origin.length),\n      request.clone().body\n    )\n    this.request = request\n    this.fetchMetrics = request.fetchMetrics\n\n    this.headers = {}\n    for (const [name, value] of request.headers.entries()) {\n      this.headers[name] = value\n    }\n  }\n\n  async parseBody(_limit: string | number): Promise<any> {\n    throw new Error('parseBody is not implemented in the web runtime')\n  }\n}\n\nexport class WebNextResponse extends BaseNextResponse<WritableStream> {\n  private headers = new Headers()\n  private textBody: string | undefined = undefined\n\n  private closeController = new CloseController()\n\n  public statusCode: number | undefined\n  public statusMessage: string | undefined\n\n  constructor(\n    public transformStream = new TransformStream(),\n    private trackOnClose = false\n  ) {\n    super(transformStream.writable)\n  }\n\n  setHeader(name: string, value: string | string[]): this {\n    this.headers.delete(name)\n    for (const val of Array.isArray(value) ? value : [value]) {\n      this.headers.append(name, val)\n    }\n    return this\n  }\n\n  removeHeader(name: string): this {\n    this.headers.delete(name)\n    return this\n  }\n\n  getHeaderValues(name: string): string[] | undefined {\n    // https://developer.mozilla.org/docs/Web/API/Headers/get#example\n    return this.getHeader(name)\n      ?.split(',')\n      .map((v) => v.trimStart())\n  }\n\n  getHeader(name: string): string | undefined {\n    return this.headers.get(name) ?? undefined\n  }\n\n  getHeaders(): OutgoingHttpHeaders {\n    return toNodeOutgoingHttpHeaders(this.headers)\n  }\n\n  hasHeader(name: string): boolean {\n    return this.headers.has(name)\n  }\n\n  appendHeader(name: string, value: string): this {\n    this.headers.append(name, value)\n    return this\n  }\n\n  body(value: string) {\n    this.textBody = value\n    return this\n  }\n\n  private readonly sendPromise = new DetachedPromise<void>()\n\n  private _sent = false\n  public send() {\n    this.sendPromise.resolve()\n    this._sent = true\n  }\n\n  get sent() {\n    return this._sent\n  }\n\n  public async toResponse() {\n    // If we haven't called `send` yet, wait for it to be called.\n    if (!this.sent) await this.sendPromise.promise\n\n    const body = this.textBody ?? this.transformStream.readable\n\n    let bodyInit: BodyInit = body\n\n    const canAddListenersLater = typeof bodyInit !== 'string'\n    const shouldTrackBody =\n      this.trackOnClose &&\n      (canAddListenersLater ? true : this.closeController.listeners > 0)\n\n    if (shouldTrackBody) {\n      bodyInit = trackBodyConsumed(body, () => {\n        this.closeController.dispatchClose()\n      })\n    }\n\n    return new Response(bodyInit, {\n      headers: this.headers,\n      status: this.statusCode,\n      statusText: this.statusMessage,\n    })\n  }\n\n  public onClose(callback: () => void) {\n    if (!this.trackOnClose) {\n      throw new InvariantError(\n        'Cannot call onClose on a WebNextResponse initialized with `trackOnClose = false`'\n      )\n    }\n    if (this.closeController.isClosed) {\n      throw new InvariantError(\n        'Cannot call onClose on a WebNextResponse that is already closed'\n      )\n    }\n    return this.closeController.onClose(callback)\n  }\n}\n"],"names":["toNodeOutgoingHttpHeaders","BaseNextRequest","BaseNextResponse","DetachedPromise","CloseController","trackBodyConsumed","InvariantError","WebNextRequest","constructor","request","url","URL","method","href","slice","origin","length","clone","body","fetchMetrics","headers","name","value","entries","parseBody","_limit","Error","WebNextResponse","transformStream","TransformStream","trackOnClose","writable","Headers","textBody","undefined","closeController","sendPromise","_sent","setHeader","delete","val","Array","isArray","append","removeHeader","getHeaderValues","getHeader","split","map","v","trimStart","get","getHeaders","hasHeader","has","appendHeader","send","resolve","sent","toResponse","promise","readable","bodyInit","canAddListenersLater","shouldTrackBody","listeners","dispatchClose","Response","status","statusCode","statusText","statusMessage","onClose","callback","isClosed"],"mappings":";;;;AAGA,SAASA,yBAAyB,QAAQ,eAAc;AACxD,SAASC,eAAe,EAAEC,gBAAgB,QAAQ,UAAS;AAC3D,SAASC,eAAe,QAAQ,6BAA4B;AAE5D,SAASC,eAAe,EAAEC,iBAAiB,QAAQ,sBAAqB;AACxE,SAASC,cAAc,QAAQ,mCAAkC;;;;;;AAE1D,MAAMC,sMAAuBN,kBAAAA;IAKlCO,YAAYC,OAAwB,CAAE;QACpC,MAAMC,MAAM,IAAIC,IAAIF,QAAQC,GAAG;QAE/B,KAAK,CACHD,QAAQG,MAAM,EACdF,IAAIG,IAAI,CAACC,KAAK,CAACJ,IAAIK,MAAM,CAACC,MAAM,GAChCP,QAAQQ,KAAK,GAAGC,IAAI;QAEtB,IAAI,CAACT,OAAO,GAAGA;QACf,IAAI,CAACU,YAAY,GAAGV,QAAQU,YAAY;QAExC,IAAI,CAACC,OAAO,GAAG,CAAC;QAChB,KAAK,MAAM,CAACC,MAAMC,MAAM,IAAIb,QAAQW,OAAO,CAACG,OAAO,GAAI;YACrD,IAAI,CAACH,OAAO,CAACC,KAAK,GAAGC;QACvB;IACF;IAEA,MAAME,UAAUC,MAAuB,EAAgB;QACrD,MAAM,IAAIC,MAAM;IAClB;AACF;AAEO,MAAMC,uMAAwBzB,mBAAAA;IASnCM,YACSoB,kBAAkB,IAAIC,iBAAiB,EACtCC,eAAe,KAAK,CAC5B;QACA,KAAK,CAACF,gBAAgBG,QAAQ;aAHvBH,eAAAA,GAAAA;aACCE,YAAAA,GAAAA;aAVFV,OAAAA,GAAU,IAAIY;aACdC,QAAAA,GAA+BC;aAE/BC,eAAAA,GAAkB,uLAAI/B,kBAAAA;aAsDbgC,WAAAA,GAAc,6KAAIjC,mBAAAA;aAE3BkC,KAAAA,GAAQ;IA9ChB;IAEAC,UAAUjB,IAAY,EAAEC,KAAwB,EAAQ;QACtD,IAAI,CAACF,OAAO,CAACmB,MAAM,CAAClB;QACpB,KAAK,MAAMmB,OAAOC,MAAMC,OAAO,CAACpB,SAASA,QAAQ;YAACA;SAAM,CAAE;YACxD,IAAI,CAACF,OAAO,CAACuB,MAAM,CAACtB,MAAMmB;QAC5B;QACA,OAAO,IAAI;IACb;IAEAI,aAAavB,IAAY,EAAQ;QAC/B,IAAI,CAACD,OAAO,CAACmB,MAAM,CAAClB;QACpB,OAAO,IAAI;IACb;IAEAwB,gBAAgBxB,IAAY,EAAwB;YAE3C;QADP,iEAAiE;QACjE,OAAA,CAAO,kBAAA,IAAI,CAACyB,SAAS,CAACzB,KAAAA,KAAAA,OAAAA,KAAAA,IAAf,gBACH0B,KAAK,CAAC,KACPC,GAAG,CAAC,CAACC,IAAMA,EAAEC,SAAS;IAC3B;IAEAJ,UAAUzB,IAAY,EAAsB;QAC1C,OAAO,IAAI,CAACD,OAAO,CAAC+B,GAAG,CAAC9B,SAASa;IACnC;IAEAkB,aAAkC;QAChC,iLAAOpD,4BAAAA,EAA0B,IAAI,CAACoB,OAAO;IAC/C;IAEAiC,UAAUhC,IAAY,EAAW;QAC/B,OAAO,IAAI,CAACD,OAAO,CAACkC,GAAG,CAACjC;IAC1B;IAEAkC,aAAalC,IAAY,EAAEC,KAAa,EAAQ;QAC9C,IAAI,CAACF,OAAO,CAACuB,MAAM,CAACtB,MAAMC;QAC1B,OAAO,IAAI;IACb;IAEAJ,KAAKI,KAAa,EAAE;QAClB,IAAI,CAACW,QAAQ,GAAGX;QAChB,OAAO,IAAI;IACb;IAKOkC,OAAO;QACZ,IAAI,CAACpB,WAAW,CAACqB,OAAO;QACxB,IAAI,CAACpB,KAAK,GAAG;IACf;IAEA,IAAIqB,OAAO;QACT,OAAO,IAAI,CAACrB,KAAK;IACnB;IAEA,MAAasB,aAAa;QACxB,6DAA6D;QAC7D,IAAI,CAAC,IAAI,CAACD,IAAI,EAAE,MAAM,IAAI,CAACtB,WAAW,CAACwB,OAAO;QAE9C,MAAM1C,OAAO,IAAI,CAACe,QAAQ,IAAI,IAAI,CAACL,eAAe,CAACiC,QAAQ;QAE3D,IAAIC,WAAqB5C;QAEzB,MAAM6C,uBAAuB,OAAOD,aAAa;QACjD,MAAME,kBACJ,IAAI,CAAClC,YAAY,IAChBiC,CAAAA,uBAAuB,OAAO,IAAI,CAAC5B,eAAe,CAAC8B,SAAS,GAAG,CAAA;QAElE,IAAID,iBAAiB;YACnBF,kMAAWzD,oBAAAA,EAAkBa,MAAM;gBACjC,IAAI,CAACiB,eAAe,CAAC+B,aAAa;YACpC;QACF;QAEA,OAAO,IAAIC,SAASL,UAAU;YAC5B1C,SAAS,IAAI,CAACA,OAAO;YACrBgD,QAAQ,IAAI,CAACC,UAAU;YACvBC,YAAY,IAAI,CAACC,aAAa;QAChC;IACF;IAEOC,QAAQC,QAAoB,EAAE;QACnC,IAAI,CAAC,IAAI,CAAC3C,YAAY,EAAE;YACtB,MAAM,uLAAIxB,iBAAAA,CACR;QAEJ;QACA,IAAI,IAAI,CAAC6B,eAAe,CAACuC,QAAQ,EAAE;YACjC,MAAM,uLAAIpE,iBAAAA,CACR;QAEJ;QACA,OAAO,IAAI,CAAC6B,eAAe,CAACqC,OAAO,CAACC;IACtC;AACF","ignoreList":[0]}},
    {"offset": {"line": 3309, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3315, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/base-http/helpers.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n"],"names":["isWebNextRequest","req","process","env","NEXT_RUNTIME","isWebNextResponse","res","isNodeNextRequest","isNodeNextResponse"],"mappings":"AAIA;;;;;CAKC,GAED;;;;;CAKC,GACD;;;;;;AAAO,MAAMA,mBAAmB,CAACC,MAC/BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQ9B,MAAMC,oBAAoB,CAC/BC,MAC2BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMG,oBAAoB,CAC/BN,MAC2BC,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM;AAQzD,MAAMI,qBAAqB,CAChCF,MAC4BJ,QAAQC,GAAG,CAACC,YAAY,qBAAK,OAAM","ignoreList":[0]}},
    {"offset": {"line": 3335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3341, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/client-component-renderer-logger.ts"],"sourcesContent":["// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(ComponentMod: any) {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args: any[]) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args: any[]) => {\n      const startTime = performance.now()\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.loadChunk(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n"],"names":["clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","wrapClientComponentLoader","ComponentMod","globalThis","__next_app__","require","args","startTime","performance","now","loadChunk","getClientComponentLoaderMetrics","options","metrics","undefined","reset"],"mappings":"AAAA,oDAAoD;;;;;AACpD,IAAIA,2BAA2B;AAC/B,IAAIC,2BAA2B;AAC/B,IAAIC,2BAA2B;AAExB,SAASC,0BAA0BC,YAAiB;IACzD,IAAI,CAAE,CAAA,iBAAiBC,UAAS,GAAI;QAClC,OAAOD,aAAaE,YAAY;IAClC;IAEA,OAAO;QACLC,SAAS,CAAC,GAAGC;YACX,MAAMC,YAAYC,YAAYC,GAAG;YAEjC,IAAIX,6BAA6B,GAAG;gBAClCA,2BAA2BS;YAC7B;YAEA,IAAI;gBACFP,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACC,OAAO,IAAIC;YAC9C,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;QACAG,WAAW,CAAC,GAAGJ;YACb,MAAMC,YAAYC,YAAYC,GAAG;YACjC,IAAI;gBACFT,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACM,SAAS,IAAIJ;YAChD,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;IACF;AACF;AAEO,SAASI,gCACdC,UAA+B,CAAC,CAAC;IAEjC,MAAMC,UACJf,6BAA6B,IACzBgB,YACA;QACEhB;QACAC;QACAC;IACF;IAEN,IAAIY,QAAQG,KAAK,EAAE;QACjBjB,2BAA2B;QAC3BC,2BAA2B;QAC3BC,2BAA2B;IAC7B;IAEA,OAAOa;AACT","ignoreList":[0]}},
    {"offset": {"line": 3390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3396, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/pipe-readable.ts"],"sourcesContent":["import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n"],"names":["ResponseAbortedName","createAbortController","DetachedPromise","getTracer","NextNodeServerSpan","getClientComponentLoaderMetrics","isAbortError","e","name","createWriterFromResponse","res","waitUntilForEnd","started","drained","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","globalThis","process","env","NEXT_OTEL_PERFORMANCE_PREFIX","metrics","performance","measure","start","clientComponentLoadStart","end","clientComponentLoadTimes","flushHeaders","trace","startResponse","spanName","undefined","ok","flush","promise","err","Error","cause","abort","writableFinished","destroy","close","pipeToNodeResponse","readable","errored","destroyed","controller","writer","pipeTo","signal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3513, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3519, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/render-result.ts"],"sourcesContent":["import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { Revalidate } from './lib/revalidate'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToBuffer,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { PrerenderResumeDataCache } from './resume-data-cache/resume-data-cache'\n\ntype ContentTypeOption = string | undefined\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  revalidate?: Revalidate\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentFlightData?: Map<string, Buffer>\n\n  /**\n   * In development, the cache is warmed up before the render. This is attached\n   * to the metadata so that it can be used during the render.\n   */\n  devWarmupPrerenderResumeDataCache?: PrerenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  revalidate?: Revalidate\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType?: ContentTypeOption\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(value: string | Buffer) {\n    return new RenderResult<StaticRenderResultMetadata>(value, { metadata: {} })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  public toUnchunkedBuffer(stream?: false): Buffer\n  public toUnchunkedBuffer(stream: true): Promise<Buffer>\n  public toUnchunkedBuffer(stream = false): Promise<Buffer> | Buffer {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToBuffer(this.readable)\n    }\n\n    return Buffer.from(this.response)\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns the response if it is a stream, or throws an error if it is a\n   * string.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be streamed')\n    }\n    if (typeof this.response === 'string') {\n      throw new Error('Invariant: static responses cannot be streamed')\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public chain(readable: ReadableStream<Uint8Array>) {\n    if (this.response === null) {\n      throw new Error('Invariant: response is null. This is a bug in Next.js')\n    }\n\n    // If the response is not an array of streams already, make it one.\n    let responses: ReadableStream<Uint8Array>[]\n    if (typeof this.response === 'string') {\n      responses = [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      responses = this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      responses = [streamFromBuffer(this.response)]\n    } else {\n      responses = [this.response]\n    }\n\n    // Add the new stream to the array.\n    responses.push(readable)\n\n    // Update the response.\n    this.response = responses\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n"],"names":["chainStreams","streamFromBuffer","streamFromString","streamToBuffer","streamToString","isAbortError","pipeToNodeResponse","RenderResult","fromStatic","value","metadata","constructor","response","contentType","waitUntil","assignMetadata","Object","assign","isNull","isDynamic","toUnchunkedBuffer","stream","Error","readable","Buffer","from","toUnchunkedString","isBuffer","Array","isArray","chain","responses","push","pipeTo","writable","preventClose","close","err","abort","res"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3679, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3685, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;;UAAkBA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;GAtBeA,aAAAA,CAAAA,YAAAA,CAAAA,CAAAA","ignoreList":[0]}},
    {"offset": {"line": 3708, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3714, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/utils.ts"],"sourcesContent":["import { BLOCKED_PAGES } from '../shared/lib/constants'\n\nexport function isBlockedPage(page: string): boolean {\n  return BLOCKED_PAGES.includes(page)\n}\n\nexport function cleanAmpPath(pathname: string): string {\n  if (pathname.match(/\\?amp=(y|yes|true|1)/)) {\n    pathname = pathname.replace(/\\?amp=(y|yes|true|1)&?/, '?')\n  }\n  if (pathname.match(/&amp=(y|yes|true|1)/)) {\n    pathname = pathname.replace(/&amp=(y|yes|true|1)/, '')\n  }\n  pathname = pathname.replace(/\\?$/, '')\n  return pathname\n}\n\ntype AnyFunc<T> = (this: T, ...args: any) => any\nexport function debounce<T, F extends AnyFunc<T>>(\n  fn: F,\n  ms: number,\n  maxWait = Infinity\n) {\n  let timeoutId: undefined | NodeJS.Timeout\n\n  // The time the debouncing function was first called during this debounce queue.\n  let startTime = 0\n  // The time the debouncing function was last called.\n  let lastCall = 0\n\n  // The arguments and this context of the last call to the debouncing function.\n  let args: Parameters<F>, context: T\n\n  // A helper used to that either invokes the debounced function, or\n  // reschedules the timer if a more recent call was made.\n  function run() {\n    const now = Date.now()\n    const diff = lastCall + ms - now\n\n    // If the diff is non-positive, then we've waited at least `ms`\n    // milliseconds since the last call. Or if we've waited for longer than the\n    // max wait time, we must call the debounced function.\n    if (diff <= 0 || startTime + maxWait >= now) {\n      // It's important to clear the timeout id before invoking the debounced\n      // function, in case the function calls the debouncing function again.\n      timeoutId = undefined\n      fn.apply(context, args)\n    } else {\n      // Else, a new call was made after the original timer was scheduled. We\n      // didn't clear the timeout (doing so is very slow), so now we need to\n      // reschedule the timer for the time difference.\n      timeoutId = setTimeout(run, diff)\n    }\n  }\n\n  return function (this: T, ...passedArgs: Parameters<F>) {\n    // The arguments and this context of the most recent call are saved so the\n    // debounced function can be invoked with them later.\n    args = passedArgs\n    context = this\n\n    // Instead of constantly clearing and scheduling a timer, we record the\n    // time of the last call. If a second call comes in before the timer fires,\n    // then we'll reschedule in the run function. Doing this is considerably\n    // faster.\n    lastCall = Date.now()\n\n    // Only schedule a new timer if we're not currently waiting.\n    if (timeoutId === undefined) {\n      startTime = lastCall\n      timeoutId = setTimeout(run, ms)\n    }\n  }\n}\n"],"names":["BLOCKED_PAGES","isBlockedPage","page","includes","cleanAmpPath","pathname","match","replace","debounce","fn","ms","maxWait","Infinity","timeoutId","startTime","lastCall","args","context","run","now","Date","diff","undefined","apply","setTimeout","passedArgs"],"mappings":";;;;;;AAAA,SAASA,aAAa,QAAQ,0BAAyB;;AAEhD,SAASC,cAAcC,IAAY;IACxC,iMAAOF,gBAAAA,CAAcG,QAAQ,CAACD;AAChC;AAEO,SAASE,aAAaC,QAAgB;IAC3C,IAAIA,SAASC,KAAK,CAAC,yBAAyB;QAC1CD,WAAWA,SAASE,OAAO,CAAC,0BAA0B;IACxD;IACA,IAAIF,SAASC,KAAK,CAAC,wBAAwB;QACzCD,WAAWA,SAASE,OAAO,CAAC,uBAAuB;IACrD;IACAF,WAAWA,SAASE,OAAO,CAAC,OAAO;IACnC,OAAOF;AACT;AAGO,SAASG,SACdC,EAAK,EACLC,EAAU,EACVC,UAAUC,QAAQ;IAElB,IAAIC;IAEJ,gFAAgF;IAChF,IAAIC,YAAY;IAChB,oDAAoD;IACpD,IAAIC,WAAW;IAEf,8EAA8E;IAC9E,IAAIC,MAAqBC;IAEzB,kEAAkE;IAClE,wDAAwD;IACxD,SAASC;QACP,MAAMC,MAAMC,KAAKD,GAAG;QACpB,MAAME,OAAON,WAAWL,KAAKS;QAE7B,+DAA+D;QAC/D,2EAA2E;QAC3E,sDAAsD;QACtD,IAAIE,QAAQ,KAAKP,YAAYH,WAAWQ,KAAK;YAC3C,uEAAuE;YACvE,sEAAsE;YACtEN,YAAYS;YACZb,GAAGc,KAAK,CAACN,SAASD;QACpB,OAAO;YACL,uEAAuE;YACvE,sEAAsE;YACtE,gDAAgD;YAChDH,YAAYW,WAAWN,KAAKG;QAC9B;IACF;IAEA,OAAO,SAAmB,GAAGI,UAAyB;QACpD,0EAA0E;QAC1E,qDAAqD;QACrDT,OAAOS;QACPR,UAAU,IAAI;QAEd,uEAAuE;QACvE,2EAA2E;QAC3E,wEAAwE;QACxE,UAAU;QACVF,WAAWK,KAAKD,GAAG;QAEnB,4DAA4D;QAC5D,IAAIN,cAAcS,WAAW;YAC3BR,YAAYC;YACZF,YAAYW,WAAWN,KAAKR;QAC9B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3780, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3786, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/server-utils.ts"],"sourcesContent":["import type { Rewrite } from '../lib/load-custom-routes'\nimport type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'\nimport type { NextConfig } from './config'\nimport type { BaseNextRequest } from './base-http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\n\nimport { format as formatUrl, parse as parseUrl } from 'url'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport { getPathMatch } from '../shared/lib/router/utils/path-match'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport {\n  matchHas,\n  prepareDestination,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { normalizeRscURL } from '../shared/lib/router/utils/app-paths'\nimport {\n  NEXT_INTERCEPTION_MARKER_PREFIX,\n  NEXT_QUERY_PARAM_PREFIX,\n} from '../lib/constants'\n\nexport function normalizeVercelUrl(\n  req: BaseNextRequest,\n  trustQuery: boolean,\n  paramKeys?: string[],\n  pageIsDynamic?: boolean,\n  defaultRouteRegex?: ReturnType<typeof getNamedRouteRegex> | undefined\n) {\n  // make sure to normalize req.url on Vercel to strip dynamic params\n  // from the query which are added during routing\n  if (pageIsDynamic && trustQuery && defaultRouteRegex) {\n    const _parsedUrl = parseUrl(req.url!, true)\n    delete (_parsedUrl as any).search\n\n    for (const key of Object.keys(_parsedUrl.query)) {\n      const isNextQueryPrefix =\n        key !== NEXT_QUERY_PARAM_PREFIX &&\n        key.startsWith(NEXT_QUERY_PARAM_PREFIX)\n\n      const isNextInterceptionMarkerPrefix =\n        key !== NEXT_INTERCEPTION_MARKER_PREFIX &&\n        key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)\n\n      if (\n        isNextQueryPrefix ||\n        isNextInterceptionMarkerPrefix ||\n        (paramKeys || Object.keys(defaultRouteRegex.groups)).includes(key)\n      ) {\n        delete _parsedUrl.query[key]\n      }\n    }\n    req.url = formatUrl(_parsedUrl)\n  }\n}\n\nexport function interpolateDynamicPath(\n  pathname: string,\n  params: ParsedUrlQuery,\n  defaultRouteRegex?: ReturnType<typeof getNamedRouteRegex> | undefined\n) {\n  if (!defaultRouteRegex) return pathname\n\n  for (const param of Object.keys(defaultRouteRegex.groups)) {\n    const { optional, repeat } = defaultRouteRegex.groups[param]\n    let builtParam = `[${repeat ? '...' : ''}${param}]`\n\n    if (optional) {\n      builtParam = `[${builtParam}]`\n    }\n\n    let paramValue: string\n    const value = params[param]\n\n    if (Array.isArray(value)) {\n      paramValue = value.map((v) => v && encodeURIComponent(v)).join('/')\n    } else if (value) {\n      paramValue = encodeURIComponent(value)\n    } else {\n      paramValue = ''\n    }\n\n    pathname = pathname.replaceAll(builtParam, paramValue)\n  }\n\n  return pathname\n}\n\nexport function normalizeDynamicRouteParams(\n  params: ParsedUrlQuery,\n  ignoreOptional?: boolean,\n  defaultRouteRegex?: ReturnType<typeof getNamedRouteRegex> | undefined,\n  defaultRouteMatches?: ParsedUrlQuery | undefined\n) {\n  let hasValidParams = true\n  if (!defaultRouteRegex) return { params, hasValidParams: false }\n\n  params = Object.keys(defaultRouteRegex.groups).reduce((prev, key) => {\n    let value: string | string[] | undefined = params[key]\n\n    if (typeof value === 'string') {\n      value = normalizeRscURL(value)\n    }\n    if (Array.isArray(value)) {\n      value = value.map((val) => {\n        if (typeof val === 'string') {\n          val = normalizeRscURL(val)\n        }\n        return val\n      })\n    }\n\n    // if the value matches the default value we can't rely\n    // on the parsed params, this is used to signal if we need\n    // to parse x-now-route-matches or not\n    const defaultValue = defaultRouteMatches![key]\n    const isOptional = defaultRouteRegex!.groups[key].optional\n\n    const isDefaultValue = Array.isArray(defaultValue)\n      ? defaultValue.some((defaultVal) => {\n          return Array.isArray(value)\n            ? value.some((val) => val.includes(defaultVal))\n            : value?.includes(defaultVal)\n        })\n      : value?.includes(defaultValue as string)\n\n    if (\n      isDefaultValue ||\n      (typeof value === 'undefined' && !(isOptional && ignoreOptional))\n    ) {\n      hasValidParams = false\n    }\n\n    // non-provided optional values should be undefined so normalize\n    // them to undefined\n    if (\n      isOptional &&\n      (!value ||\n        (Array.isArray(value) &&\n          value.length === 1 &&\n          // fallback optional catch-all SSG pages have\n          // [[...paramName]] for the root path on Vercel\n          (value[0] === 'index' || value[0] === `[[...${key}]]`)))\n    ) {\n      value = undefined\n      delete params[key]\n    }\n\n    // query values from the proxy aren't already split into arrays\n    // so make sure to normalize catch-all values\n    if (\n      value &&\n      typeof value === 'string' &&\n      defaultRouteRegex!.groups[key].repeat\n    ) {\n      value = value.split('/')\n    }\n\n    if (value) {\n      prev[key] = value\n    }\n    return prev\n  }, {} as ParsedUrlQuery)\n\n  return {\n    params,\n    hasValidParams,\n  }\n}\n\nexport function getUtils({\n  page,\n  i18n,\n  basePath,\n  rewrites,\n  pageIsDynamic,\n  trailingSlash,\n  caseSensitive,\n}: {\n  page: string\n  i18n?: NextConfig['i18n']\n  basePath: string\n  rewrites: {\n    fallback?: ReadonlyArray<Rewrite>\n    afterFiles?: ReadonlyArray<Rewrite>\n    beforeFiles?: ReadonlyArray<Rewrite>\n  }\n  pageIsDynamic: boolean\n  trailingSlash?: boolean\n  caseSensitive: boolean\n}) {\n  let defaultRouteRegex: ReturnType<typeof getNamedRouteRegex> | undefined\n  let dynamicRouteMatcher: RouteMatchFn | undefined\n  let defaultRouteMatches: ParsedUrlQuery | undefined\n\n  if (pageIsDynamic) {\n    defaultRouteRegex = getNamedRouteRegex(page, false)\n    dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)\n    defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery\n  }\n\n  function handleRewrites(req: BaseNextRequest, parsedUrl: UrlWithParsedQuery) {\n    const rewriteParams = {}\n    let fsPathname = parsedUrl.pathname\n\n    const matchesPage = () => {\n      const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')\n      return (\n        fsPathnameNoSlash === removeTrailingSlash(page) ||\n        dynamicRouteMatcher?.(fsPathnameNoSlash)\n      )\n    }\n\n    const checkRewrite = (rewrite: Rewrite): boolean => {\n      const matcher = getPathMatch(\n        rewrite.source + (trailingSlash ? '(/)?' : ''),\n        {\n          removeUnnamedParams: true,\n          strict: true,\n          sensitive: !!caseSensitive,\n        }\n      )\n      let params = matcher(parsedUrl.pathname)\n\n      if ((rewrite.has || rewrite.missing) && params) {\n        const hasParams = matchHas(\n          req,\n          parsedUrl.query,\n          rewrite.has,\n          rewrite.missing\n        )\n\n        if (hasParams) {\n          Object.assign(params, hasParams)\n        } else {\n          params = false\n        }\n      }\n\n      if (params) {\n        const { parsedDestination, destQuery } = prepareDestination({\n          appendParamsToQuery: true,\n          destination: rewrite.destination,\n          params: params,\n          query: parsedUrl.query,\n        })\n\n        // if the rewrite destination is external break rewrite chain\n        if (parsedDestination.protocol) {\n          return true\n        }\n\n        Object.assign(rewriteParams, destQuery, params)\n        Object.assign(parsedUrl.query, parsedDestination.query)\n        delete (parsedDestination as any).query\n\n        Object.assign(parsedUrl, parsedDestination)\n\n        fsPathname = parsedUrl.pathname\n\n        if (basePath) {\n          fsPathname =\n            fsPathname!.replace(new RegExp(`^${basePath}`), '') || '/'\n        }\n\n        if (i18n) {\n          const destLocalePathResult = normalizeLocalePath(\n            fsPathname!,\n            i18n.locales\n          )\n          fsPathname = destLocalePathResult.pathname\n          parsedUrl.query.nextInternalLocale =\n            destLocalePathResult.detectedLocale || params.nextInternalLocale\n        }\n\n        if (fsPathname === page) {\n          return true\n        }\n\n        if (pageIsDynamic && dynamicRouteMatcher) {\n          const dynamicParams = dynamicRouteMatcher(fsPathname)\n          if (dynamicParams) {\n            parsedUrl.query = {\n              ...parsedUrl.query,\n              ...dynamicParams,\n            }\n            return true\n          }\n        }\n      }\n      return false\n    }\n\n    for (const rewrite of rewrites.beforeFiles || []) {\n      checkRewrite(rewrite)\n    }\n\n    if (fsPathname !== page) {\n      let finished = false\n\n      for (const rewrite of rewrites.afterFiles || []) {\n        finished = checkRewrite(rewrite)\n        if (finished) break\n      }\n\n      if (!finished && !matchesPage()) {\n        for (const rewrite of rewrites.fallback || []) {\n          finished = checkRewrite(rewrite)\n          if (finished) break\n        }\n      }\n    }\n    return rewriteParams\n  }\n\n  function getParamsFromRouteMatches(\n    req: BaseNextRequest,\n    renderOpts?: any,\n    detectedLocale?: string\n  ) {\n    return getRouteMatcher(\n      (function () {\n        const { groups, routeKeys } = defaultRouteRegex!\n\n        return {\n          re: {\n            // Simulate a RegExp match from the \\`req.url\\` input\n            exec: (str: string) => {\n              const obj = Object.fromEntries(new URLSearchParams(str))\n              const matchesHasLocale =\n                i18n && detectedLocale && obj['1'] === detectedLocale\n\n              for (const key of Object.keys(obj)) {\n                const value = obj[key]\n\n                if (\n                  key !== NEXT_QUERY_PARAM_PREFIX &&\n                  key.startsWith(NEXT_QUERY_PARAM_PREFIX)\n                ) {\n                  const normalizedKey = key.substring(\n                    NEXT_QUERY_PARAM_PREFIX.length\n                  )\n                  obj[normalizedKey] = value\n                  delete obj[key]\n                }\n              }\n\n              // favor named matches if available\n              const routeKeyNames = Object.keys(routeKeys || {})\n              const filterLocaleItem = (val: string | string[] | undefined) => {\n                if (i18n) {\n                  // locale items can be included in route-matches\n                  // for fallback SSG pages so ensure they are\n                  // filtered\n                  const isCatchAll = Array.isArray(val)\n                  const _val = isCatchAll ? val[0] : val\n\n                  if (\n                    typeof _val === 'string' &&\n                    i18n.locales.some((item) => {\n                      if (item.toLowerCase() === _val.toLowerCase()) {\n                        detectedLocale = item\n                        renderOpts.locale = detectedLocale\n                        return true\n                      }\n                      return false\n                    })\n                  ) {\n                    // remove the locale item from the match\n                    if (isCatchAll) {\n                      ;(val as string[]).splice(0, 1)\n                    }\n\n                    // the value is only a locale item and\n                    // shouldn't be added\n                    return isCatchAll ? val.length === 0 : true\n                  }\n                }\n                return false\n              }\n\n              if (routeKeyNames.every((name) => obj[name])) {\n                return routeKeyNames.reduce((prev, keyName) => {\n                  const paramName = routeKeys?.[keyName]\n\n                  if (paramName && !filterLocaleItem(obj[keyName])) {\n                    prev[groups[paramName].pos] = obj[keyName]\n                  }\n                  return prev\n                }, {} as any)\n              }\n\n              return Object.keys(obj).reduce((prev, key) => {\n                if (!filterLocaleItem(obj[key])) {\n                  let normalizedKey = key\n\n                  if (matchesHasLocale) {\n                    normalizedKey = parseInt(key, 10) - 1 + ''\n                  }\n                  return Object.assign(prev, {\n                    [normalizedKey]: obj[key],\n                  })\n                }\n                return prev\n              }, {})\n            },\n          },\n          groups,\n        }\n      })() as any\n    )(req.headers['x-now-route-matches'] as string) as ParsedUrlQuery\n  }\n\n  return {\n    handleRewrites,\n    defaultRouteRegex,\n    dynamicRouteMatcher,\n    defaultRouteMatches,\n    getParamsFromRouteMatches,\n    normalizeDynamicRouteParams: (\n      params: ParsedUrlQuery,\n      ignoreOptional?: boolean\n    ) =>\n      normalizeDynamicRouteParams(\n        params,\n        ignoreOptional,\n        defaultRouteRegex,\n        defaultRouteMatches\n      ),\n    normalizeVercelUrl: (\n      req: BaseNextRequest,\n      trustQuery: boolean,\n      paramKeys?: string[]\n    ) =>\n      normalizeVercelUrl(\n        req,\n        trustQuery,\n        paramKeys,\n        pageIsDynamic,\n        defaultRouteRegex\n      ),\n    interpolateDynamicPath: (\n      pathname: string,\n      params: Record<string, undefined | string | string[]>\n    ) => interpolateDynamicPath(pathname, params, defaultRouteRegex),\n  }\n}\n"],"names":["format","formatUrl","parse","parseUrl","normalizeLocalePath","getPathMatch","getNamedRouteRegex","getRouteMatcher","matchHas","prepareDestination","removeTrailingSlash","normalizeRscURL","NEXT_INTERCEPTION_MARKER_PREFIX","NEXT_QUERY_PARAM_PREFIX","normalizeVercelUrl","req","trustQuery","paramKeys","pageIsDynamic","defaultRouteRegex","_parsedUrl","url","search","key","Object","keys","query","isNextQueryPrefix","startsWith","isNextInterceptionMarkerPrefix","groups","includes","interpolateDynamicPath","pathname","params","param","optional","repeat","builtParam","paramValue","value","Array","isArray","map","v","encodeURIComponent","join","replaceAll","normalizeDynamicRouteParams","ignoreOptional","defaultRouteMatches","hasValidParams","reduce","prev","val","defaultValue","isOptional","isDefaultValue","some","defaultVal","length","undefined","split","getUtils","page","i18n","basePath","rewrites","trailingSlash","caseSensitive","dynamicRouteMatcher","handleRewrites","parsedUrl","rewriteParams","fsPathname","matchesPage","fsPathnameNoSlash","checkRewrite","rewrite","matcher","source","removeUnnamedParams","strict","sensitive","has","missing","hasParams","assign","parsedDestination","destQuery","appendParamsToQuery","destination","protocol","replace","RegExp","destLocalePathResult","locales","nextInternalLocale","detectedLocale","dynamicParams","beforeFiles","finished","afterFiles","fallback","getParamsFromRouteMatches","renderOpts","routeKeys","re","exec","str","obj","fromEntries","URLSearchParams","matchesHasLocale","normalizedKey","substring","routeKeyNames","filterLocaleItem","isCatchAll","_val","item","toLowerCase","locale","splice","every","name","keyName","paramName","pos","parseInt","headers"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4078, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/locale-route-normalizer.ts"],"sourcesContent":["import type { I18NProvider } from '../lib/i18n-provider'\nimport type { Normalizer } from './normalizer'\n\n/**\n * Normalizes the pathname by removing the locale prefix if any.\n */\nexport class LocaleRouteNormalizer implements Normalizer {\n  constructor(private readonly provider: I18NProvider) {}\n\n  /**\n   * Normalizes the pathname by removing the locale prefix if any.\n   *\n   * @param pathname The pathname to normalize.\n   * @returns The pathname without the locale prefix (if any).\n   */\n  public normalize(pathname: string): string {\n    const match = this.provider.analyze(pathname)\n    return match.pathname\n  }\n}\n"],"names":["LocaleRouteNormalizer","constructor","provider","normalize","pathname","match","analyze"],"mappings":"AAGA;;CAEC,GACD;;;AAAO,MAAMA;IACXC,YAA6BC,QAAsB,CAAE;aAAxBA,QAAAA,GAAAA;IAAyB;IAEtD;;;;;GAKC,GACMC,UAAUC,QAAgB,EAAU;QACzC,MAAMC,QAAQ,IAAI,CAACH,QAAQ,CAACI,OAAO,CAACF;QACpC,OAAOC,MAAMD,QAAQ;IACvB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4097, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4103, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/normalizers.ts"],"sourcesContent":["import type { Normalizer } from './normalizer'\n\n/**\n * Normalizers combines many normalizers into a single normalizer interface that\n * will normalize the inputted pathname with each normalizer in order.\n */\nexport class Normalizers implements Normalizer {\n  constructor(private readonly normalizers: Array<Normalizer> = []) {}\n\n  public push(normalizer: Normalizer) {\n    this.normalizers.push(normalizer)\n  }\n\n  public normalize(pathname: string): string {\n    return this.normalizers.reduce<string>(\n      (normalized, normalizer) => normalizer.normalize(normalized),\n      pathname\n    )\n  }\n}\n"],"names":["Normalizers","constructor","normalizers","push","normalizer","normalize","pathname","reduce","normalized"],"mappings":"AAEA;;;CAGC,GACD;;;AAAO,MAAMA;IACXC,YAA6BC,cAAiC,EAAE,CAAE;aAArCA,WAAAA,GAAAA;IAAsC;IAE5DC,KAAKC,UAAsB,EAAE;QAClC,IAAI,CAACF,WAAW,CAACC,IAAI,CAACC;IACxB;IAEOC,UAAUC,QAAgB,EAAU;QACzC,OAAO,IAAI,CAACJ,WAAW,CAACK,MAAM,CAC5B,CAACC,YAAYJ,aAAeA,WAAWC,SAAS,CAACG,aACjDF;IAEJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 4120, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4126, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/prefixing-normalizer.ts"],"sourcesContent":["import path from '../../shared/lib/isomorphic/path'\nimport type { Normalizer } from './normalizer'\n\nexport class PrefixingNormalizer implements Normalizer {\n  private readonly prefix: string\n\n  constructor(...prefixes: ReadonlyArray<string>) {\n    this.prefix = path.posix.join(...prefixes)\n  }\n\n  public normalize(pathname: string): string {\n    return path.posix.join(this.prefix, pathname)\n  }\n}\n"],"names":["path","PrefixingNormalizer","constructor","prefixes","prefix","posix","join","normalize","pathname"],"mappings":";;;AAAA,OAAOA,UAAU,mCAAkC;;AAG5C,MAAMC;IAGXC,YAAY,GAAGC,QAA+B,CAAE;QAC9C,IAAI,CAACC,MAAM,sLAAGJ,UAAAA,CAAKK,KAAK,CAACC,IAAI,IAAIH;IACnC;IAEOI,UAAUC,QAAgB,EAAU;QACzC,0LAAOR,UAAAA,CAAKK,KAAK,CAACC,IAAI,CAAC,IAAI,CAACF,MAAM,EAAEI;IACtC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4139, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4145, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/app/app-bundle-path-normalizer.ts"],"sourcesContent":["import { Normalizers } from '../../normalizers'\nimport type { Normalizer } from '../../normalizer'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\nimport { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path'\n\nexport class AppBundlePathNormalizer extends PrefixingNormalizer {\n  constructor() {\n    super('app')\n  }\n\n  public normalize(page: string): string {\n    return super.normalize(normalizePagePath(page))\n  }\n}\n\nexport class DevAppBundlePathNormalizer extends Normalizers {\n  constructor(pageNormalizer: Normalizer) {\n    super([\n      // This should normalize the filename to a page.\n      pageNormalizer,\n      // Normalize the app page to a pathname.\n      new AppBundlePathNormalizer(),\n    ])\n  }\n\n  public normalize(filename: string): string {\n    return super.normalize(filename)\n  }\n}\n"],"names":["Normalizers","PrefixingNormalizer","normalizePagePath","AppBundlePathNormalizer","constructor","normalize","page","DevAppBundlePathNormalizer","pageNormalizer","filename"],"mappings":";;;;AAAA,SAASA,WAAW,QAAQ,oBAAmB;AAE/C,SAASC,mBAAmB,QAAQ,6BAA4B;AAChE,SAASC,iBAAiB,QAAQ,uDAAsD;;;;AAEjF,MAAMC,gOAAgCF,sBAAAA;IAC3CG,aAAc;QACZ,KAAK,CAAC;IACR;IAEOC,UAAUC,IAAY,EAAU;QACrC,OAAO,KAAK,CAACD,wNAAUH,oBAAAA,EAAkBI;IAC3C;AACF;AAEO,MAAMC,uNAAmCP,cAAAA;IAC9CI,YAAYI,cAA0B,CAAE;QACtC,KAAK,CAAC;YACJ,gDAAgD;YAChDA;YACA,wCAAwC;YACxC,IAAIL;SACL;IACH;IAEOE,UAAUI,QAAgB,EAAU;QACzC,OAAO,KAAK,CAACJ,UAAUI;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4176, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4182, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/app/app-filename-normalizer.ts"],"sourcesContent":["import { SERVER_DIRECTORY } from '../../../../shared/lib/constants'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\n\nexport class AppFilenameNormalizer extends PrefixingNormalizer {\n  constructor(distDir: string) {\n    super(distDir, SERVER_DIRECTORY)\n  }\n\n  public normalize(manifestFilename: string): string {\n    return super.normalize(manifestFilename)\n  }\n}\n"],"names":["SERVER_DIRECTORY","PrefixingNormalizer","AppFilenameNormalizer","constructor","distDir","normalize","manifestFilename"],"mappings":";;;AAAA,SAASA,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,mBAAmB,QAAQ,6BAA4B;;;;AAEzD,MAAMC,8NAA8BD,sBAAAA;IACzCE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,mMAASJ,mBAAAA;IACjB;IAEOK,UAAUC,gBAAwB,EAAU;QACjD,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4198, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4204, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/absolute-filename-normalizer.ts"],"sourcesContent":["import type { PAGE_TYPES } from '../../lib/page-types'\nimport { absolutePathToPage } from '../../shared/lib/page-path/absolute-path-to-page'\nimport type { Normalizer } from './normalizer'\n\n/**\n * Normalizes a given filename so that it's relative to the provided directory.\n * It will also strip the extension (if provided) and the trailing `/index`.\n */\nexport class AbsoluteFilenameNormalizer implements Normalizer {\n  /**\n   *\n   * @param dir the directory for which the files should be made relative to\n   * @param extensions the extensions the file could have\n   * @param keepIndex when `true` the trailing `/index` is _not_ removed\n   */\n  constructor(\n    private readonly dir: string,\n    private readonly extensions: ReadonlyArray<string>,\n    private readonly pagesType: PAGE_TYPES\n  ) {}\n\n  public normalize(filename: string): string {\n    return absolutePathToPage(filename, {\n      extensions: this.extensions,\n      keepIndex: false,\n      dir: this.dir,\n      pagesType: this.pagesType,\n    })\n  }\n}\n"],"names":["absolutePathToPage","AbsoluteFilenameNormalizer","constructor","dir","extensions","pagesType","normalize","filename","keepIndex"],"mappings":";;;AACA,SAASA,kBAAkB,QAAQ,mDAAkD;;AAO9E,MAAMC;IACX;;;;;GAKC,GACDC,YACmBC,GAAW,EACXC,UAAiC,EACjCC,SAAqB,CACtC;aAHiBF,GAAAA,GAAAA;aACAC,UAAAA,GAAAA;aACAC,SAAAA,GAAAA;IAChB;IAEIC,UAAUC,QAAgB,EAAU;QACzC,0NAAOP,qBAAAA,EAAmBO,UAAU;YAClCH,YAAY,IAAI,CAACA,UAAU;YAC3BI,WAAW;YACXL,KAAK,IAAI,CAACA,GAAG;YACbE,WAAW,IAAI,CAACA,SAAS;QAC3B;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4229, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4235, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/app/app-page-normalizer.ts"],"sourcesContent":["import { PAGE_TYPES } from '../../../../lib/page-types'\nimport { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer'\n\n/**\n * DevAppPageNormalizer is a normalizer that is used to normalize a pathname\n * to a page in the `app` directory.\n */\nexport class DevAppPageNormalizer extends AbsoluteFilenameNormalizer {\n  constructor(appDir: string, extensions: ReadonlyArray<string>) {\n    super(appDir, extensions, PAGE_TYPES.APP)\n  }\n}\n"],"names":["PAGE_TYPES","AbsoluteFilenameNormalizer","DevAppPageNormalizer","constructor","appDir","extensions","APP"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,0BAA0B,QAAQ,qCAAoC;;;AAMxE,MAAMC,wOAA6BD,6BAAAA;IACxCE,YAAYC,MAAc,EAAEC,UAAiC,CAAE;QAC7D,KAAK,CAACD,QAAQC,gLAAYL,aAAAA,CAAWM,GAAG;IAC1C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4247, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4253, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/wrap-normalizer-fn.ts"],"sourcesContent":["import type { Normalizer } from './normalizer'\n\nexport function wrapNormalizerFn(fn: (pathname: string) => string): Normalizer {\n  return { normalize: fn }\n}\n"],"names":["wrapNormalizerFn","fn","normalize"],"mappings":";;;AAEO,SAASA,iBAAiBC,EAAgC;IAC/D,OAAO;QAAEC,WAAWD;IAAG;AACzB","ignoreList":[0]}},
    {"offset": {"line": 4261, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4267, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/underscore-normalizer.ts"],"sourcesContent":["import type { Normalizer } from './normalizer'\n\n/**\n * UnderscoreNormalizer replaces all instances of %5F with _.\n */\nexport class UnderscoreNormalizer implements Normalizer {\n  public normalize(pathname: string): string {\n    return pathname.replace(/%5F/g, '_')\n  }\n}\n"],"names":["UnderscoreNormalizer","normalize","pathname","replace"],"mappings":"AAEA;;CAEC,GACD;;;AAAO,MAAMA;IACJC,UAAUC,QAAgB,EAAU;QACzC,OAAOA,SAASC,OAAO,CAAC,QAAQ;IAClC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4277, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4283, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/app/app-pathname-normalizer.ts"],"sourcesContent":["import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths'\nimport { Normalizers } from '../../normalizers'\nimport { wrapNormalizerFn } from '../../wrap-normalizer-fn'\nimport { UnderscoreNormalizer } from '../../underscore-normalizer'\nimport type { Normalizer } from '../../normalizer'\n\nexport class AppPathnameNormalizer extends Normalizers {\n  constructor() {\n    super([\n      // The pathname to match should have the trailing `/page` and other route\n      // group information stripped from it.\n      wrapNormalizerFn(normalizeAppPath),\n      // The page should have the `%5F` characters replaced with `_` characters.\n      new UnderscoreNormalizer(),\n    ])\n  }\n\n  public normalize(page: string): string {\n    return super.normalize(page)\n  }\n}\n\nexport class DevAppPathnameNormalizer extends Normalizers {\n  constructor(pageNormalizer: Normalizer) {\n    super([\n      // This should normalize the filename to a page.\n      pageNormalizer,\n      // Normalize the app page to a pathname.\n      new AppPathnameNormalizer(),\n    ])\n  }\n\n  public normalize(filename: string): string {\n    return super.normalize(filename)\n  }\n}\n"],"names":["normalizeAppPath","Normalizers","wrapNormalizerFn","UnderscoreNormalizer","AppPathnameNormalizer","constructor","normalize","page","DevAppPathnameNormalizer","pageNormalizer","filename"],"mappings":";;;;AAAA,SAASA,gBAAgB,QAAQ,gDAA+C;AAChF,SAASC,WAAW,QAAQ,oBAAmB;AAC/C,SAASC,gBAAgB,QAAQ,2BAA0B;AAC3D,SAASC,oBAAoB,QAAQ,8BAA6B;;;;;AAG3D,MAAMC,kNAA8BH,cAAAA;IACzCI,aAAc;QACZ,KAAK,CAAC;YACJ,yEAAyE;YACzE,sCAAsC;aACtCH,uNAAAA,kMAAiBF,mBAAAA;YACjB,0EAA0E;YAC1E,qMAAIG,uBAAAA;SACL;IACH;IAEOG,UAAUC,IAAY,EAAU;QACrC,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF;AAEO,MAAMC,qNAAiCP,cAAAA;IAC5CI,YAAYI,cAA0B,CAAE;QACtC,KAAK,CAAC;YACJ,gDAAgD;YAChDA;YACA,wCAAwC;YACxC,IAAIL;SACL;IACH;IAEOE,UAAUI,QAAgB,EAAU;QACzC,OAAO,KAAK,CAACJ,UAAUI;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4322, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4328, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/app/index.ts"],"sourcesContent":["import {\n  AppBundlePathNormalizer,\n  DevAppBundlePathNormalizer,\n} from './app-bundle-path-normalizer'\nimport { AppFilenameNormalizer } from './app-filename-normalizer'\nimport { DevAppPageNormalizer } from './app-page-normalizer'\nimport {\n  AppPathnameNormalizer,\n  DevAppPathnameNormalizer,\n} from './app-pathname-normalizer'\n\nexport class AppNormalizers {\n  public readonly filename: AppFilenameNormalizer\n  public readonly pathname: AppPathnameNormalizer\n  public readonly bundlePath: AppBundlePathNormalizer\n\n  constructor(distDir: string) {\n    this.filename = new AppFilenameNormalizer(distDir)\n    this.pathname = new AppPathnameNormalizer()\n    this.bundlePath = new AppBundlePathNormalizer()\n  }\n}\n\nexport class DevAppNormalizers {\n  public readonly page: DevAppPageNormalizer\n  public readonly pathname: DevAppPathnameNormalizer\n  public readonly bundlePath: DevAppBundlePathNormalizer\n\n  constructor(appDir: string, extensions: ReadonlyArray<string>) {\n    this.page = new DevAppPageNormalizer(appDir, extensions)\n    this.pathname = new DevAppPathnameNormalizer(this.page)\n    this.bundlePath = new DevAppBundlePathNormalizer(this.page)\n  }\n}\n"],"names":["AppBundlePathNormalizer","DevAppBundlePathNormalizer","AppFilenameNormalizer","DevAppPageNormalizer","AppPathnameNormalizer","DevAppPathnameNormalizer","AppNormalizers","constructor","distDir","filename","pathname","bundlePath","DevAppNormalizers","appDir","extensions","page"],"mappings":";;;;AAAA,SACEA,uBAAuB,EACvBC,0BAA0B,QACrB,+BAA8B;AACrC,SAASC,qBAAqB,QAAQ,4BAA2B;AACjE,SAASC,oBAAoB,QAAQ,wBAAuB;AAC5D,SACEC,qBAAqB,EACrBC,wBAAwB,QACnB,4BAA2B;;;;;AAE3B,MAAMC;IAKXC,YAAYC,OAAe,CAAE;QAC3B,IAAI,CAACC,QAAQ,GAAG,0NAAIP,wBAAAA,CAAsBM;QAC1C,IAAI,CAACE,QAAQ,GAAG,0NAAIN,wBAAAA;QACpB,IAAI,CAACO,UAAU,GAAG,gOAAIX,0BAAAA;IACxB;AACF;AAEO,MAAMY;IAKXL,YAAYM,MAAc,EAAEC,UAAiC,CAAE;QAC7D,IAAI,CAACC,IAAI,GAAG,sNAAIZ,uBAAAA,CAAqBU,QAAQC;QAC7C,IAAI,CAACJ,QAAQ,GAAG,0NAAIL,2BAAAA,CAAyB,IAAI,CAACU,IAAI;QACtD,IAAI,CAACJ,UAAU,GAAG,gOAAIV,6BAAAA,CAA2B,IAAI,CAACc,IAAI;IAC5D;AACF","ignoreList":[0]}},
    {"offset": {"line": 4354, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4360, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-bundle-path-normalizer.ts"],"sourcesContent":["import { normalizePagePath } from '../../../../shared/lib/page-path/normalize-page-path'\nimport type { Normalizer } from '../../normalizer'\nimport { Normalizers } from '../../normalizers'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\nimport { wrapNormalizerFn } from '../../wrap-normalizer-fn'\n\nexport class PagesBundlePathNormalizer extends Normalizers {\n  constructor() {\n    super([\n      // The bundle path should have the trailing `/index` stripped from\n      // it.\n      wrapNormalizerFn(normalizePagePath),\n      // The page should prefixed with `pages/`.\n      new PrefixingNormalizer('pages'),\n    ])\n  }\n\n  public normalize(page: string): string {\n    return super.normalize(page)\n  }\n}\n\nexport class DevPagesBundlePathNormalizer extends Normalizers {\n  constructor(pagesNormalizer: Normalizer) {\n    super([\n      // This should normalize the filename to a page.\n      pagesNormalizer,\n      // Normalize the app page to a pathname.\n      new PagesBundlePathNormalizer(),\n    ])\n  }\n\n  public normalize(filename: string): string {\n    return super.normalize(filename)\n  }\n}\n"],"names":["normalizePagePath","Normalizers","PrefixingNormalizer","wrapNormalizerFn","PagesBundlePathNormalizer","constructor","normalize","page","DevPagesBundlePathNormalizer","pagesNormalizer","filename"],"mappings":";;;;AAAA,SAASA,iBAAiB,QAAQ,uDAAsD;AAExF,SAASC,WAAW,QAAQ,oBAAmB;AAC/C,SAASC,mBAAmB,QAAQ,6BAA4B;AAChE,SAASC,gBAAgB,QAAQ,2BAA0B;;;;;AAEpD,MAAMC,sNAAkCH,cAAAA;IAC7CI,aAAc;QACZ,KAAK,CAAC;YACJ,kEAAkE;YAClE,MAAM;aACNF,uNAAAA,4MAAiBH,oBAAAA;YACjB,0CAA0C;YAC1C,oMAAIE,sBAAAA,CAAoB;SACzB;IACH;IAEOI,UAAUC,IAAY,EAAU;QACrC,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF;AAEO,MAAMC,yNAAqCP,cAAAA;IAChDI,YAAYI,eAA2B,CAAE;QACvC,KAAK,CAAC;YACJ,gDAAgD;YAChDA;YACA,wCAAwC;YACxC,IAAIL;SACL;IACH;IAEOE,UAAUI,QAAgB,EAAU;QACzC,OAAO,KAAK,CAACJ,UAAUI;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4399, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4405, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-filename-normalizer.ts"],"sourcesContent":["import { SERVER_DIRECTORY } from '../../../../shared/lib/constants'\nimport { PrefixingNormalizer } from '../../prefixing-normalizer'\n\nexport class PagesFilenameNormalizer extends PrefixingNormalizer {\n  constructor(distDir: string) {\n    super(distDir, SERVER_DIRECTORY)\n  }\n\n  public normalize(manifestFilename: string): string {\n    return super.normalize(manifestFilename)\n  }\n}\n"],"names":["SERVER_DIRECTORY","PrefixingNormalizer","PagesFilenameNormalizer","constructor","distDir","normalize","manifestFilename"],"mappings":";;;AAAA,SAASA,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,mBAAmB,QAAQ,6BAA4B;;;;AAEzD,MAAMC,gOAAgCD,sBAAAA;IAC3CE,YAAYC,OAAe,CAAE;QAC3B,KAAK,CAACA,mMAASJ,mBAAAA;IACjB;IAEOK,UAAUC,gBAAwB,EAAU;QACjD,OAAO,KAAK,CAACD,UAAUC;IACzB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4421, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4427, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-page-normalizer.ts"],"sourcesContent":["import { PAGE_TYPES } from '../../../../lib/page-types'\nimport { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer'\n\nexport class DevPagesPageNormalizer extends AbsoluteFilenameNormalizer {\n  constructor(pagesDir: string, extensions: ReadonlyArray<string>) {\n    super(pagesDir, extensions, PAGE_TYPES.PAGES)\n  }\n}\n"],"names":["PAGE_TYPES","AbsoluteFilenameNormalizer","DevPagesPageNormalizer","constructor","pagesDir","extensions","PAGES"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,0BAA0B,QAAQ,qCAAoC;;;AAExE,MAAMC,0OAA+BD,6BAAAA;IAC1CE,YAAYC,QAAgB,EAAEC,UAAiC,CAAE;QAC/D,KAAK,CAACD,UAAUC,gLAAYL,aAAAA,CAAWM,KAAK;IAC9C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4439, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4445, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/pages/pages-pathname-normalizer.ts"],"sourcesContent":["import { PAGE_TYPES } from '../../../../lib/page-types'\nimport { AbsoluteFilenameNormalizer } from '../../absolute-filename-normalizer'\n\nexport class DevPagesPathnameNormalizer extends AbsoluteFilenameNormalizer {\n  constructor(pagesDir: string, extensions: ReadonlyArray<string>) {\n    super(pagesDir, extensions, PAGE_TYPES.PAGES)\n  }\n}\n"],"names":["PAGE_TYPES","AbsoluteFilenameNormalizer","DevPagesPathnameNormalizer","constructor","pagesDir","extensions","PAGES"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,0BAA0B,QAAQ,qCAAoC;;;AAExE,MAAMC,8OAAmCD,6BAAAA;IAC9CE,YAAYC,QAAgB,EAAEC,UAAiC,CAAE;QAC/D,KAAK,CAACD,UAAUC,gLAAYL,aAAAA,CAAWM,KAAK;IAC9C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4463, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/built/pages/index.ts"],"sourcesContent":["import {\n  DevPagesBundlePathNormalizer,\n  PagesBundlePathNormalizer,\n} from './pages-bundle-path-normalizer'\nimport { PagesFilenameNormalizer } from './pages-filename-normalizer'\nimport { DevPagesPageNormalizer } from './pages-page-normalizer'\nimport { DevPagesPathnameNormalizer } from './pages-pathname-normalizer'\n\nexport class PagesNormalizers {\n  public readonly filename: PagesFilenameNormalizer\n  public readonly bundlePath: PagesBundlePathNormalizer\n\n  constructor(distDir: string) {\n    this.filename = new PagesFilenameNormalizer(distDir)\n    this.bundlePath = new PagesBundlePathNormalizer()\n\n    // You'd think that we'd require a `pathname` normalizer here, but for\n    // `/pages` we have to handle i18n routes, which means that we need to\n    // analyze the page path to determine the locale prefix and it's locale.\n  }\n}\n\nexport class DevPagesNormalizers {\n  public readonly page: DevPagesPageNormalizer\n  public readonly pathname: DevPagesPathnameNormalizer\n  public readonly bundlePath: DevPagesBundlePathNormalizer\n\n  constructor(pagesDir: string, extensions: ReadonlyArray<string>) {\n    this.page = new DevPagesPageNormalizer(pagesDir, extensions)\n    this.pathname = new DevPagesPathnameNormalizer(pagesDir, extensions)\n    this.bundlePath = new DevPagesBundlePathNormalizer(this.page)\n  }\n}\n"],"names":["DevPagesBundlePathNormalizer","PagesBundlePathNormalizer","PagesFilenameNormalizer","DevPagesPageNormalizer","DevPagesPathnameNormalizer","PagesNormalizers","constructor","distDir","filename","bundlePath","DevPagesNormalizers","pagesDir","extensions","page","pathname"],"mappings":";;;;AAAA,SACEA,4BAA4B,EAC5BC,yBAAyB,QACpB,iCAAgC;AACvC,SAASC,uBAAuB,QAAQ,8BAA6B;AACrE,SAASC,sBAAsB,QAAQ,0BAAyB;AAChE,SAASC,0BAA0B,QAAQ,8BAA6B;;;;;AAEjE,MAAMC;IAIXC,YAAYC,OAAe,CAAE;QAC3B,IAAI,CAACC,QAAQ,GAAG,8NAAIN,0BAAAA,CAAwBK;QAC5C,IAAI,CAACE,UAAU,GAAG,oOAAIR,4BAAAA;IAEtB,sEAAsE;IACtE,sEAAsE;IACtE,wEAAwE;IAC1E;AACF;AAEO,MAAMS;IAKXJ,YAAYK,QAAgB,EAAEC,UAAiC,CAAE;QAC/D,IAAI,CAACC,IAAI,GAAG,0NAAIV,yBAAAA,CAAuBQ,UAAUC;QACjD,IAAI,CAACE,QAAQ,GAAG,8NAAIV,6BAAAA,CAA2BO,UAAUC;QACzD,IAAI,CAACH,UAAU,GAAG,oOAAIT,+BAAAA,CAA6B,IAAI,CAACa,IAAI;IAC9D;AACF","ignoreList":[0]}},
    {"offset": {"line": 4491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4497, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/request/suffix.ts"],"sourcesContent":["import type { Normalizer } from '../normalizer'\n\nexport class SuffixPathnameNormalizer implements Normalizer {\n  constructor(private readonly suffix: string) {}\n\n  public match(pathname: string) {\n    // If the pathname doesn't end in the suffix, we don't match.\n    if (!pathname.endsWith(this.suffix)) return false\n\n    return true\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    // If we're not matched and we don't match, we don't need to normalize.\n    if (!matched && !this.match(pathname)) return pathname\n\n    return pathname.substring(0, pathname.length - this.suffix.length)\n  }\n}\n"],"names":["SuffixPathnameNormalizer","constructor","suffix","match","pathname","endsWith","normalize","matched","substring","length"],"mappings":";;;AAEO,MAAMA;IACXC,YAA6BC,MAAc,CAAE;aAAhBA,MAAAA,GAAAA;IAAiB;IAEvCC,MAAMC,QAAgB,EAAE;QAC7B,6DAA6D;QAC7D,IAAI,CAACA,SAASC,QAAQ,CAAC,IAAI,CAACH,MAAM,GAAG,OAAO;QAE5C,OAAO;IACT;IAEOI,UAAUF,QAAgB,EAAEG,OAAiB,EAAU;QAC5D,uEAAuE;QACvE,IAAI,CAACA,WAAW,CAAC,IAAI,CAACJ,KAAK,CAACC,WAAW,OAAOA;QAE9C,OAAOA,SAASI,SAAS,CAAC,GAAGJ,SAASK,MAAM,GAAG,IAAI,CAACP,MAAM,CAACO,MAAM;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 4515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4521, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/request/rsc.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport { RSC_SUFFIX } from '../../../lib/constants'\nimport { SuffixPathnameNormalizer } from './suffix'\n\nexport class RSCPathnameNormalizer\n  extends SuffixPathnameNormalizer\n  implements PathnameNormalizer\n{\n  constructor() {\n    super(RSC_SUFFIX)\n  }\n}\n"],"names":["RSC_SUFFIX","SuffixPathnameNormalizer","RSCPathnameNormalizer","constructor"],"mappings":";;;AAEA,SAASA,UAAU,QAAQ,yBAAwB;AACnD,SAASC,wBAAwB,QAAQ,WAAU;;;AAE5C,MAAMC,wNACHD,2BAAAA;IAGRE,aAAc;QACZ,KAAK,iKAACH,aAAAA;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 4533, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4539, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/request/prefetch-rsc.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport { RSC_PREFETCH_SUFFIX } from '../../../lib/constants'\nimport { SuffixPathnameNormalizer } from './suffix'\n\nexport class PrefetchRSCPathnameNormalizer\n  extends SuffixPathnameNormalizer\n  implements PathnameNormalizer\n{\n  constructor() {\n    super(RSC_PREFETCH_SUFFIX)\n  }\n\n  public match(pathname: string): boolean {\n    if (pathname === '/__index' + RSC_PREFETCH_SUFFIX) {\n      return true\n    }\n\n    return super.match(pathname)\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    if (pathname === '/__index' + RSC_PREFETCH_SUFFIX) {\n      return '/'\n    }\n\n    return super.normalize(pathname, matched)\n  }\n}\n"],"names":["RSC_PREFETCH_SUFFIX","SuffixPathnameNormalizer","PrefetchRSCPathnameNormalizer","constructor","match","pathname","normalize","matched"],"mappings":";;;AAEA,SAASA,mBAAmB,QAAQ,yBAAwB;AAC5D,SAASC,wBAAwB,QAAQ,WAAU;;;AAE5C,MAAMC,gOACHD,2BAAAA;IAGRE,aAAc;QACZ,KAAK,iKAACH,sBAAAA;IACR;IAEOI,MAAMC,QAAgB,EAAW;QACtC,IAAIA,aAAa,6KAAaL,sBAAAA,EAAqB;YACjD,OAAO;QACT;QAEA,OAAO,KAAK,CAACI,MAAMC;IACrB;IAEOC,UAAUD,QAAgB,EAAEE,OAAiB,EAAU;QAC5D,IAAIF,aAAa,6KAAaL,sBAAAA,EAAqB;YACjD,OAAO;QACT;QAEA,OAAO,KAAK,CAACM,UAAUD,UAAUE;IACnC;AACF","ignoreList":[0]}},
    {"offset": {"line": 4563, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4569, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/request/prefix.ts"],"sourcesContent":["import type { Normalizer } from '../normalizer'\n\nexport class PrefixPathnameNormalizer implements Normalizer {\n  constructor(private readonly prefix: string) {\n    if (prefix.endsWith('/')) {\n      throw new Error(\n        `PrefixPathnameNormalizer: prefix \"${prefix}\" should not end with a slash`\n      )\n    }\n  }\n\n  public match(pathname: string) {\n    // If the pathname doesn't start with the prefix, we don't match.\n    if (pathname !== this.prefix && !pathname.startsWith(this.prefix + '/')) {\n      return false\n    }\n\n    return true\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    // If we're not matched and we don't match, we don't need to normalize.\n    if (!matched && !this.match(pathname)) return pathname\n\n    if (pathname.length === this.prefix.length) {\n      return '/'\n    }\n\n    return pathname.substring(this.prefix.length)\n  }\n}\n"],"names":["PrefixPathnameNormalizer","constructor","prefix","endsWith","Error","match","pathname","startsWith","normalize","matched","length","substring"],"mappings":";;;AAEO,MAAMA;IACXC,YAA6BC,MAAc,CAAE;aAAhBA,MAAAA,GAAAA;QAC3B,IAAIA,OAAOC,QAAQ,CAAC,MAAM;YACxB,MAAM,IAAIC,MACR,CAAC,kCAAkC,EAAEF,OAAO,6BAA6B,CAAC;QAE9E;IACF;IAEOG,MAAMC,QAAgB,EAAE;QAC7B,iEAAiE;QACjE,IAAIA,aAAa,IAAI,CAACJ,MAAM,IAAI,CAACI,SAASC,UAAU,CAAC,IAAI,CAACL,MAAM,GAAG,MAAM;YACvE,OAAO;QACT;QAEA,OAAO;IACT;IAEOM,UAAUF,QAAgB,EAAEG,OAAiB,EAAU;QAC5D,uEAAuE;QACvE,IAAI,CAACA,WAAW,CAAC,IAAI,CAACJ,KAAK,CAACC,WAAW,OAAOA;QAE9C,IAAIA,SAASI,MAAM,KAAK,IAAI,CAACR,MAAM,CAACQ,MAAM,EAAE;YAC1C,OAAO;QACT;QAEA,OAAOJ,SAASK,SAAS,CAAC,IAAI,CAACT,MAAM,CAACQ,MAAM;IAC9C;AACF","ignoreList":[0]}},
    {"offset": {"line": 4595, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4601, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/normalizers/request/next-data.ts"],"sourcesContent":["import type { PathnameNormalizer } from './pathname-normalizer'\n\nimport { denormalizePagePath } from '../../../shared/lib/page-path/denormalize-page-path'\nimport { PrefixPathnameNormalizer } from './prefix'\nimport { SuffixPathnameNormalizer } from './suffix'\n\nexport class NextDataPathnameNormalizer implements PathnameNormalizer {\n  private readonly prefix: PrefixPathnameNormalizer\n  private readonly suffix = new SuffixPathnameNormalizer('.json')\n  constructor(buildID: string) {\n    if (!buildID) {\n      throw new Error('Invariant: buildID is required')\n    }\n\n    this.prefix = new PrefixPathnameNormalizer(`/_next/data/${buildID}`)\n  }\n\n  public match(pathname: string) {\n    return this.prefix.match(pathname) && this.suffix.match(pathname)\n  }\n\n  public normalize(pathname: string, matched?: boolean): string {\n    // If we're not matched and we don't match, we don't need to normalize.\n    if (!matched && !this.match(pathname)) return pathname\n\n    pathname = this.prefix.normalize(pathname, true)\n    pathname = this.suffix.normalize(pathname, true)\n\n    return denormalizePagePath(pathname)\n  }\n}\n"],"names":["denormalizePagePath","PrefixPathnameNormalizer","SuffixPathnameNormalizer","NextDataPathnameNormalizer","constructor","buildID","suffix","Error","prefix","match","pathname","normalize","matched"],"mappings":";;;AAEA,SAASA,mBAAmB,QAAQ,sDAAqD;AACzF,SAASC,wBAAwB,QAAQ,WAAU;AACnD,SAASC,wBAAwB,QAAQ,WAAU;;;;AAE5C,MAAMC;IAGXC,YAAYC,OAAe,CAAE;aADZC,MAAAA,GAAS,8LAAIJ,2BAAAA,CAAyB;QAErD,IAAI,CAACG,SAAS;YACZ,MAAM,IAAIE,MAAM;QAClB;QAEA,IAAI,CAACC,MAAM,GAAG,8LAAIP,2BAAAA,CAAyB,CAAC,YAAY,EAAEI,QAAQ,CAAC;IACrE;IAEOI,MAAMC,QAAgB,EAAE;QAC7B,OAAO,IAAI,CAACF,MAAM,CAACC,KAAK,CAACC,aAAa,IAAI,CAACJ,MAAM,CAACG,KAAK,CAACC;IAC1D;IAEOC,UAAUD,QAAgB,EAAEE,OAAiB,EAAU;QAC5D,uEAAuE;QACvE,IAAI,CAACA,WAAW,CAAC,IAAI,CAACH,KAAK,CAACC,WAAW,OAAOA;QAE9CA,WAAW,IAAI,CAACF,MAAM,CAACG,SAAS,CAACD,UAAU;QAC3CA,WAAW,IAAI,CAACJ,MAAM,CAACK,SAAS,CAACD,UAAU;QAE3C,uNAAOV,sBAAAA,EAAoBU;IAC7B;AACF","ignoreList":[0]}},
    {"offset": {"line": 4629, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4635, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matchers/route-matcher.ts"],"sourcesContent":["import type { RouteMatch } from '../route-matches/route-match'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { Params } from '../request/params'\n\nimport { isDynamicRoute } from '../../shared/lib/router/utils'\nimport {\n  getRouteMatcher,\n  type RouteMatchFn,\n} from '../../shared/lib/router/utils/route-matcher'\nimport { getRouteRegex } from '../../shared/lib/router/utils/route-regex'\n\ntype RouteMatchResult = {\n  params?: Params\n}\n\nexport class RouteMatcher<D extends RouteDefinition = RouteDefinition> {\n  private readonly dynamic?: RouteMatchFn\n\n  /**\n   * When set, this is an array of all the other matchers that are duplicates of\n   * this one. This is used by the managers to warn the users about possible\n   * duplicate matches on routes.\n   */\n  public duplicated?: Array<RouteMatcher>\n\n  constructor(public readonly definition: D) {\n    if (isDynamicRoute(definition.pathname)) {\n      this.dynamic = getRouteMatcher(getRouteRegex(definition.pathname))\n    }\n  }\n\n  /**\n   * Identity returns the identity part of the matcher. This is used to compare\n   * a unique matcher to another. This is also used when sorting dynamic routes,\n   * so it must contain the pathname part.\n   */\n  public get identity(): string {\n    return this.definition.pathname\n  }\n\n  public get isDynamic() {\n    return this.dynamic !== undefined\n  }\n\n  public match(pathname: string): RouteMatch<D> | null {\n    const result = this.test(pathname)\n    if (!result) return null\n\n    return { definition: this.definition, params: result.params }\n  }\n\n  public test(pathname: string): RouteMatchResult | null {\n    if (this.dynamic) {\n      const params = this.dynamic(pathname)\n      if (!params) return null\n\n      return { params }\n    }\n\n    if (pathname === this.definition.pathname) {\n      return {}\n    }\n\n    return null\n  }\n}\n"],"names":["isDynamicRoute","getRouteMatcher","getRouteRegex","RouteMatcher","constructor","definition","pathname","dynamic","identity","isDynamic","undefined","match","result","test","params"],"mappings":";;;AAIA,SAASA,cAAc,QAAQ,gCAA+B;AAC9D,SACEC,eAAe,QAEV,8CAA6C;AACpD,SAASC,aAAa,QAAQ,4CAA2C;;;;;AAMlE,MAAMC;IAUXC,YAA4BC,UAAa,CAAE;aAAfA,UAAAA,GAAAA;QAC1B,yMAAIL,iBAAAA,EAAeK,WAAWC,QAAQ,GAAG;YACvC,IAAI,CAACC,OAAO,2MAAGN,kBAAAA,wMAAgBC,gBAAAA,EAAcG,WAAWC,QAAQ;QAClE;IACF;IAEA;;;;GAIC,GACD,IAAWE,WAAmB;QAC5B,OAAO,IAAI,CAACH,UAAU,CAACC,QAAQ;IACjC;IAEA,IAAWG,YAAY;QACrB,OAAO,IAAI,CAACF,OAAO,KAAKG;IAC1B;IAEOC,MAAML,QAAgB,EAAwB;QACnD,MAAMM,SAAS,IAAI,CAACC,IAAI,CAACP;QACzB,IAAI,CAACM,QAAQ,OAAO;QAEpB,OAAO;YAAEP,YAAY,IAAI,CAACA,UAAU;YAAES,QAAQF,OAAOE,MAAM;QAAC;IAC9D;IAEOD,KAAKP,QAAgB,EAA2B;QACrD,IAAI,IAAI,CAACC,OAAO,EAAE;YAChB,MAAMO,SAAS,IAAI,CAACP,OAAO,CAACD;YAC5B,IAAI,CAACQ,QAAQ,OAAO;YAEpB,OAAO;gBAAEA;YAAO;QAClB;QAEA,IAAIR,aAAa,IAAI,CAACD,UAAU,CAACC,QAAQ,EAAE;YACzC,OAAO,CAAC;QACV;QAEA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 4684, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4690, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matchers/locale-route-matcher.ts"],"sourcesContent":["import type { LocaleAnalysisResult } from '../lib/i18n-provider'\nimport type { LocaleRouteDefinition } from '../route-definitions/locale-route-definition'\nimport type { LocaleRouteMatch } from '../route-matches/locale-route-match'\nimport { RouteMatcher } from './route-matcher'\n\nexport type LocaleMatcherMatchOptions = {\n  /**\n   * If defined, this indicates to the matcher that the request should be\n   * treated as locale-aware. If this is undefined, it means that this\n   * application was not configured for additional locales.\n   */\n  i18n?: LocaleAnalysisResult\n}\n\nexport class LocaleRouteMatcher<\n  D extends LocaleRouteDefinition = LocaleRouteDefinition,\n> extends RouteMatcher<D> {\n  /**\n   * Identity returns the identity part of the matcher. This is used to compare\n   * a unique matcher to another. This is also used when sorting dynamic routes,\n   * so it must contain the pathname part as well.\n   */\n  public get identity(): string {\n    return `${this.definition.pathname}?__nextLocale=${this.definition.i18n?.locale}`\n  }\n\n  /**\n   * Match will attempt to match the given pathname against this route while\n   * also taking into account the locale information.\n   *\n   * @param pathname The pathname to match against.\n   * @param options The options to use when matching.\n   * @returns The match result, or `null` if there was no match.\n   */\n  public match(\n    pathname: string,\n    options?: LocaleMatcherMatchOptions\n  ): LocaleRouteMatch<D> | null {\n    // This is like the parent `match` method but instead this injects the\n    // additional `options` into the\n    const result = this.test(pathname, options)\n    if (!result) return null\n\n    return {\n      definition: this.definition,\n      params: result.params,\n      detectedLocale:\n        // If the options have a detected locale, then use that, otherwise use\n        // the route's locale.\n        options?.i18n?.detectedLocale ?? this.definition.i18n?.locale,\n    }\n  }\n\n  /**\n   * Test will attempt to match the given pathname against this route while\n   * also taking into account the locale information.\n   *\n   * @param pathname The pathname to match against.\n   * @param options The options to use when matching.\n   * @returns The match result, or `null` if there was no match.\n   */\n  public test(pathname: string, options?: LocaleMatcherMatchOptions) {\n    // If this route has locale information and we have detected a locale, then\n    // we need to compare the detected locale to the route's locale.\n    if (this.definition.i18n && options?.i18n) {\n      // If we have detected a locale and it does not match this route's locale,\n      // then this isn't a match!\n      if (\n        this.definition.i18n.locale &&\n        options.i18n.detectedLocale &&\n        this.definition.i18n.locale !== options.i18n.detectedLocale\n      ) {\n        return null\n      }\n\n      // Perform regular matching against the locale stripped pathname now, the\n      // locale information matches!\n      return super.test(options.i18n.pathname)\n    }\n\n    // If we don't have locale information, then we can just perform regular\n    // matching.\n    return super.test(pathname)\n  }\n}\n"],"names":["RouteMatcher","LocaleRouteMatcher","identity","definition","pathname","i18n","locale","match","options","result","test","params","detectedLocale"],"mappings":";;;AAGA,SAASA,YAAY,QAAQ,kBAAiB;;AAWvC,MAAMC,0NAEHD,eAAAA;IACR;;;;GAIC,GACD,IAAWE,WAAmB;YACuB;QAAnD,OAAO,CAAC,EAAE,IAAI,CAACC,UAAU,CAACC,QAAQ,CAAC,cAAc,EAAA,CAAE,wBAAA,IAAI,CAACD,UAAU,CAACE,IAAI,KAAA,OAAA,KAAA,IAApB,sBAAsBC,MAAM,CAAC,CAAC;IACnF;IAEA;;;;;;;GAOC,GACMC,MACLH,QAAgB,EAChBI,OAAmC,EACP;YAUxB,AACA,sBAAsB,gDADgD;QAEtEA,eAAiC;QAXrC,sEAAsE;QACtE,gCAAgC;QAChC,MAAMC,SAAS,IAAI,CAACC,IAAI,CAACN,UAAUI;QACnC,IAAI,CAACC,QAAQ,OAAO;QAEpB,OAAO;YACLN,YAAY,IAAI,CAACA,UAAU;YAC3BQ,QAAQF,OAAOE,MAAM;YACrBC,gBAGEJ,CAAAA,WAAAA,OAAAA,KAAAA,IAAAA,CAAAA,gBAAAA,QAASH,IAAI,KAAA,OAAA,KAAA,IAAbG,cAAeI,cAAc,KAAA,CAAA,CAAI,wBAAA,IAAI,CAACT,UAAU,CAACE,IAAI,KAAA,OAAA,KAAA,IAApB,sBAAsBC,MAAM;QACjE;IACF;IAEA;;;;;;;GAOC,GACMI,KAAKN,QAAgB,EAAEI,OAAmC,EAAE;QACjE,2EAA2E;QAC3E,gEAAgE;QAChE,IAAI,IAAI,CAACL,UAAU,CAACE,IAAI,IAAA,CAAIG,WAAAA,OAAAA,KAAAA,IAAAA,QAASH,IAAI,GAAE;YACzC,0EAA0E;YAC1E,2BAA2B;YAC3B,IACE,IAAI,CAACF,UAAU,CAACE,IAAI,CAACC,MAAM,IAC3BE,QAAQH,IAAI,CAACO,cAAc,IAC3B,IAAI,CAACT,UAAU,CAACE,IAAI,CAACC,MAAM,KAAKE,QAAQH,IAAI,CAACO,cAAc,EAC3D;gBACA,OAAO;YACT;YAEA,yEAAyE;YACzE,8BAA8B;YAC9B,OAAO,KAAK,CAACF,KAAKF,QAAQH,IAAI,CAACD,QAAQ;QACzC;QAEA,wEAAwE;QACxE,YAAY;QACZ,OAAO,KAAK,CAACM,KAAKN;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4749, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4755, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matchers/app-page-route-matcher.ts"],"sourcesContent":["import { RouteMatcher } from './route-matcher'\nimport type { AppPageRouteDefinition } from '../route-definitions/app-page-route-definition'\n\nexport class AppPageRouteMatcher extends RouteMatcher<AppPageRouteDefinition> {\n  public get identity(): string {\n    return `${this.definition.pathname}?__nextPage=${this.definition.page}`\n  }\n}\n"],"names":["RouteMatcher","AppPageRouteMatcher","identity","definition","pathname","page"],"mappings":";;;AAAA,SAASA,YAAY,QAAQ,kBAAiB;;AAGvC,MAAMC,2NAA4BD,eAAAA;IACvC,IAAWE,WAAmB;QAC5B,OAAO,CAAC,EAAE,IAAI,CAACC,UAAU,CAACC,QAAQ,CAAC,YAAY,EAAE,IAAI,CAACD,UAAU,CAACE,IAAI,CAAC,CAAC;IACzE;AACF","ignoreList":[0]}},
    {"offset": {"line": 4765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4771, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matchers/app-route-route-matcher.ts"],"sourcesContent":["import { RouteMatcher } from './route-matcher'\nimport type { AppRouteRouteDefinition } from '../route-definitions/app-route-route-definition'\n\nexport class AppRouteRouteMatcher extends RouteMatcher<AppRouteRouteDefinition> {}\n"],"names":["RouteMatcher","AppRouteRouteMatcher"],"mappings":";;;AAAA,SAASA,YAAY,QAAQ,kBAAiB;;AAGvC,MAAMC,4NAA6BD,eAAAA;AAAuC","ignoreList":[0]}},
    {"offset": {"line": 4778, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4784, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matchers/pages-api-route-matcher.ts"],"sourcesContent":["import type { PagesAPIRouteDefinition } from '../route-definitions/pages-api-route-definition'\nimport { LocaleRouteMatcher } from './locale-route-matcher'\nimport { RouteMatcher } from './route-matcher'\n\nexport class PagesAPIRouteMatcher extends RouteMatcher<PagesAPIRouteDefinition> {}\n\nexport class PagesAPILocaleRouteMatcher extends LocaleRouteMatcher<PagesAPIRouteDefinition> {}\n"],"names":["LocaleRouteMatcher","RouteMatcher","PagesAPIRouteMatcher","PagesAPILocaleRouteMatcher"],"mappings":";;;;AACA,SAASA,kBAAkB,QAAQ,yBAAwB;AAC3D,SAASC,YAAY,QAAQ,kBAAiB;;;AAEvC,MAAMC,4NAA6BD,eAAAA;AAAuC;AAE1E,MAAME,4OAAmCH,qBAAAA;AAA6C","ignoreList":[0]}},
    {"offset": {"line": 4796, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4802, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matchers/pages-route-matcher.ts"],"sourcesContent":["import type { PagesRouteDefinition } from '../route-definitions/pages-route-definition'\nimport { LocaleRouteMatcher } from './locale-route-matcher'\nimport { RouteMatcher } from './route-matcher'\n\nexport class PagesRouteMatcher extends RouteMatcher<PagesRouteDefinition> {}\n\nexport class PagesLocaleRouteMatcher extends LocaleRouteMatcher<PagesRouteDefinition> {}\n"],"names":["LocaleRouteMatcher","RouteMatcher","PagesRouteMatcher","PagesLocaleRouteMatcher"],"mappings":";;;;AACA,SAASA,kBAAkB,QAAQ,yBAAwB;AAC3D,SAASC,YAAY,QAAQ,kBAAiB;;;AAEvC,MAAMC,yNAA0BD,eAAAA;AAAoC;AAEpE,MAAME,yOAAgCH,qBAAAA;AAA0C","ignoreList":[0]}},
    {"offset": {"line": 4814, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4820, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-managers/default-route-matcher-manager.ts"],"sourcesContent":["import { isDynamicRoute } from '../../shared/lib/router/utils'\nimport type { RouteKind } from '../route-kind'\nimport type { RouteMatch } from '../route-matches/route-match'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { RouteMatcherProvider } from '../route-matcher-providers/route-matcher-provider'\nimport type { RouteMatcher } from '../route-matchers/route-matcher'\nimport type { MatchOptions, RouteMatcherManager } from './route-matcher-manager'\nimport { getSortedRoutes } from '../../shared/lib/router/utils'\nimport { LocaleRouteMatcher } from '../route-matchers/locale-route-matcher'\nimport { ensureLeadingSlash } from '../../shared/lib/page-path/ensure-leading-slash'\nimport { DetachedPromise } from '../../lib/detached-promise'\n\ninterface RouteMatchers {\n  static: ReadonlyArray<RouteMatcher>\n  dynamic: ReadonlyArray<RouteMatcher>\n  duplicates: Record<string, ReadonlyArray<RouteMatcher>>\n}\n\nexport class DefaultRouteMatcherManager implements RouteMatcherManager {\n  private readonly providers: Array<RouteMatcherProvider> = []\n  protected readonly matchers: RouteMatchers = {\n    static: [],\n    dynamic: [],\n    duplicates: {},\n  }\n  private lastCompilationID = this.compilationID\n\n  /**\n   * When this value changes, it indicates that a change has been introduced\n   * that requires recompilation.\n   */\n  private get compilationID() {\n    return this.providers.length\n  }\n\n  private waitTillReadyPromise?: Promise<void>\n  public async waitTillReady(): Promise<void> {\n    if (this.waitTillReadyPromise) {\n      await this.waitTillReadyPromise\n      delete this.waitTillReadyPromise\n    }\n  }\n\n  private previousMatchers: ReadonlyArray<RouteMatcher> = []\n  public async reload() {\n    const { promise, resolve, reject } = new DetachedPromise<void>()\n    this.waitTillReadyPromise = promise\n\n    // Grab the compilation ID for this run, we'll verify it at the end to\n    // ensure that if any routes were added before reloading is finished that\n    // we error out.\n    const compilationID = this.compilationID\n\n    try {\n      // Collect all the matchers from each provider.\n      const matchers: Array<RouteMatcher> = []\n\n      // Get all the providers matchers.\n      const providersMatchers: ReadonlyArray<ReadonlyArray<RouteMatcher>> =\n        await Promise.all(this.providers.map((provider) => provider.matchers()))\n\n      // Use this to detect duplicate pathnames.\n      const all = new Map<string, RouteMatcher>()\n      const duplicates: Record<string, RouteMatcher[]> = {}\n      for (const providerMatchers of providersMatchers) {\n        for (const matcher of providerMatchers) {\n          // Reset duplicated matches when reloading from pages conflicting state.\n          if (matcher.duplicated) delete matcher.duplicated\n          // Test to see if the matcher being added is a duplicate.\n          const duplicate = all.get(matcher.definition.pathname)\n          if (duplicate) {\n            // This looks a little weird, but essentially if the pathname\n            // already exists in the duplicates map, then we got that array\n            // reference. Otherwise, we create a new array with the original\n            // duplicate first. Then we push the new matcher into the duplicate\n            // array, and reset it to the duplicates object (which may be a\n            // no-op if the pathname already existed in the duplicates object).\n            // Then we set the array of duplicates on both the original\n            // duplicate object and the new one, so we can keep them in sync.\n            // If a new duplicate is found, and it matches an existing pathname,\n            // the retrieval of the `other` will actually return the array\n            // reference used by all other duplicates. This is why ReadonlyArray\n            // is so important! Array's are always references!\n            const others = duplicates[matcher.definition.pathname] ?? [\n              duplicate,\n            ]\n            others.push(matcher)\n            duplicates[matcher.definition.pathname] = others\n\n            // Add duplicated details to each route.\n            duplicate.duplicated = others\n            matcher.duplicated = others\n\n            // TODO: see if we should error for duplicates in production?\n          }\n\n          matchers.push(matcher)\n\n          // Add the matcher's pathname to the set.\n          all.set(matcher.definition.pathname, matcher)\n        }\n      }\n\n      // Update the duplicate matchers. This is used in the development manager\n      // to warn about duplicates.\n      this.matchers.duplicates = duplicates\n\n      // If the cache is the same as what we just parsed, we can exit now. We\n      // can tell by using the `===` which compares object identity, which for\n      // the manifest matchers, will return the same matcher each time.\n      if (\n        this.previousMatchers.length === matchers.length &&\n        this.previousMatchers.every(\n          (cachedMatcher, index) => cachedMatcher === matchers[index]\n        )\n      ) {\n        return\n      }\n      this.previousMatchers = matchers\n\n      // For matchers that are for static routes, filter them now.\n      this.matchers.static = matchers.filter((matcher) => !matcher.isDynamic)\n\n      // For matchers that are for dynamic routes, filter them and sort them now.\n      const dynamic = matchers.filter((matcher) => matcher.isDynamic)\n\n      // As `getSortedRoutes` only takes an array of strings, we need to create\n      // a map of the pathnames (used for sorting) and the matchers. When we\n      // have locales, there may be multiple matches for the same pathname. To\n      // handle this, we keep a map of all the indexes (in `reference`) and\n      // merge them in later.\n\n      const reference = new Map<string, number[]>()\n      const pathnames = new Array<string>()\n      for (let index = 0; index < dynamic.length; index++) {\n        // Grab the pathname from the definition.\n        const pathname = dynamic[index].definition.pathname\n\n        // Grab the index in the dynamic array, push it into the reference.\n        const indexes = reference.get(pathname) ?? []\n        indexes.push(index)\n\n        // If this is the first one set it. If it isn't, we don't need to\n        // because pushing above on the array will mutate the array already\n        // stored there because array's are always a reference!\n        if (indexes.length === 1) reference.set(pathname, indexes)\n        // Otherwise, continue, we've already added this pathname before.\n        else continue\n\n        pathnames.push(pathname)\n      }\n\n      // Sort the array of pathnames.\n      const sorted = getSortedRoutes(pathnames)\n\n      // For each of the sorted pathnames, iterate over them, grabbing the list\n      // of indexes and merging them back into the new `sortedDynamicMatchers`\n      // array. The order of the same matching pathname doesn't matter because\n      // they will have other matching characteristics (like the locale) that\n      // is considered.\n      const sortedDynamicMatchers: Array<RouteMatcher> = []\n      for (const pathname of sorted) {\n        const indexes = reference.get(pathname)\n        if (!Array.isArray(indexes)) {\n          throw new Error('Invariant: expected to find identity in indexes map')\n        }\n\n        const dynamicMatches = indexes.map((index) => dynamic[index])\n\n        sortedDynamicMatchers.push(...dynamicMatches)\n      }\n\n      this.matchers.dynamic = sortedDynamicMatchers\n\n      // This means that there was a new matcher pushed while we were waiting\n      if (this.compilationID !== compilationID) {\n        throw new Error(\n          'Invariant: expected compilation to finish before new matchers were added, possible missing await'\n        )\n      }\n    } catch (err) {\n      reject(err)\n    } finally {\n      // The compilation ID matched, so mark the complication as finished.\n      this.lastCompilationID = compilationID\n      resolve()\n    }\n  }\n\n  public push(provider: RouteMatcherProvider): void {\n    this.providers.push(provider)\n  }\n\n  public async test(pathname: string, options: MatchOptions): Promise<boolean> {\n    // See if there's a match for the pathname...\n    const match = await this.match(pathname, options)\n\n    // This default implementation only needs to check to see if there _was_ a\n    // match. The development matcher actually changes it's behavior by not\n    // recompiling the routes.\n    return match !== null\n  }\n\n  public async match(\n    pathname: string,\n    options: MatchOptions\n  ): Promise<RouteMatch<RouteDefinition<RouteKind>> | null> {\n    // \"Iterate\" over the match options. Once we found a single match, exit with\n    // it, otherwise return null below. If no match is found, the inner block\n    // won't be called.\n    for await (const match of this.matchAll(pathname, options)) {\n      return match\n    }\n\n    return null\n  }\n\n  /**\n   * This is a point for other managers to override to inject other checking\n   * behavior like duplicate route checking on a per-request basis.\n   *\n   * @param pathname the pathname to validate against\n   * @param matcher the matcher to validate/test with\n   * @returns the match if found\n   */\n  protected validate(\n    pathname: string,\n    matcher: RouteMatcher,\n    options: MatchOptions\n  ): RouteMatch | null {\n    if (matcher instanceof LocaleRouteMatcher) {\n      return matcher.match(pathname, options)\n    }\n\n    // If the locale was inferred from the default locale, then it will have\n    // already added a locale to the pathname. We need to remove it before\n    // matching because this matcher is not locale aware.\n    if (options.i18n?.inferredFromDefault) {\n      return matcher.match(options.i18n.pathname)\n    }\n\n    return matcher.match(pathname)\n  }\n\n  public async *matchAll(\n    pathname: string,\n    options: MatchOptions\n  ): AsyncGenerator<RouteMatch<RouteDefinition<RouteKind>>, null, undefined> {\n    // Guard against the matcher manager from being run before it needs to be\n    // recompiled. This was preferred to re-running the compilation here because\n    // it should be re-ran only when it changes. If a match is attempted before\n    // this is done, it indicates that there is a case where a provider is added\n    // before it was recompiled (an error). We also don't want to affect request\n    // times.\n    if (this.lastCompilationID !== this.compilationID) {\n      throw new Error(\n        'Invariant: expected routes to have been loaded before match'\n      )\n    }\n\n    // Ensure that path matching is done with a leading slash.\n    pathname = ensureLeadingSlash(pathname)\n\n    // If this pathname doesn't look like a dynamic route, and this pathname is\n    // listed in the normalized list of routes, then return it. This ensures\n    // that when a route like `/user/[id]` is encountered, it doesn't just match\n    // with the list of normalized routes.\n    if (!isDynamicRoute(pathname)) {\n      for (const matcher of this.matchers.static) {\n        const match = this.validate(pathname, matcher, options)\n        if (!match) continue\n\n        yield match\n      }\n    }\n\n    // If we should skip handling dynamic routes, exit now.\n    if (options?.skipDynamic) return null\n\n    // Loop over the dynamic matchers, yielding each match.\n    for (const matcher of this.matchers.dynamic) {\n      const match = this.validate(pathname, matcher, options)\n      if (!match) continue\n\n      yield match\n    }\n\n    // We tried direct matching against the pathname and against all the dynamic\n    // paths, so there was no match.\n    return null\n  }\n}\n"],"names":["isDynamicRoute","getSortedRoutes","LocaleRouteMatcher","ensureLeadingSlash","DetachedPromise","DefaultRouteMatcherManager","compilationID","providers","length","waitTillReady","waitTillReadyPromise","reload","promise","resolve","reject","matchers","providersMatchers","Promise","all","map","provider","Map","duplicates","providerMatchers","matcher","duplicated","duplicate","get","definition","pathname","others","push","set","previousMatchers","every","cachedMatcher","index","static","filter","isDynamic","dynamic","reference","pathnames","Array","indexes","sorted","sortedDynamicMatchers","isArray","Error","dynamicMatches","err","lastCompilationID","test","options","match","matchAll","validate","i18n","inferredFromDefault","skipDynamic"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5045, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5051, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/helpers/cached-route-matcher-provider.ts"],"sourcesContent":["import type { RouteMatcherProvider } from '../route-matcher-provider'\nimport type { RouteMatcher } from '../../route-matchers/route-matcher'\n\ninterface LoaderComparable<D> {\n  load(): Promise<D>\n  compare(left: D, right: D): boolean\n}\n\n/**\n * This will memoize the matchers if the loaded data is comparable.\n */\nexport abstract class CachedRouteMatcherProvider<\n  M extends RouteMatcher = RouteMatcher,\n  D = any,\n> implements RouteMatcherProvider<M>\n{\n  private data?: D\n  private cached: ReadonlyArray<M> = []\n\n  constructor(private readonly loader: LoaderComparable<D>) {}\n\n  protected abstract transform(data: D): Promise<ReadonlyArray<M>>\n\n  public async matchers(): Promise<readonly M[]> {\n    const data = await this.loader.load()\n    if (!data) return []\n\n    // Return the cached matchers if the data has not changed.\n    if (this.data && this.loader.compare(this.data, data)) return this.cached\n    this.data = data\n\n    // Transform the manifest into matchers.\n    const matchers = await this.transform(data)\n\n    // Cache the matchers.\n    this.cached = matchers\n\n    return matchers\n  }\n}\n"],"names":["CachedRouteMatcherProvider","constructor","loader","cached","matchers","data","load","compare","transform"],"mappings":"AAQA;;CAEC,GACD;;;AAAO,MAAeA;IAQpBC,YAA6BC,MAA2B,CAAE;aAA7BA,MAAAA,GAAAA;aAFrBC,MAAAA,GAA2B,EAAE;IAEsB;IAI3D,MAAaC,WAAkC;QAC7C,MAAMC,OAAO,MAAM,IAAI,CAACH,MAAM,CAACI,IAAI;QACnC,IAAI,CAACD,MAAM,OAAO,EAAE;QAEpB,0DAA0D;QAC1D,IAAI,IAAI,CAACA,IAAI,IAAI,IAAI,CAACH,MAAM,CAACK,OAAO,CAAC,IAAI,CAACF,IAAI,EAAEA,OAAO,OAAO,IAAI,CAACF,MAAM;QACzE,IAAI,CAACE,IAAI,GAAGA;QAEZ,wCAAwC;QACxC,MAAMD,WAAW,MAAM,IAAI,CAACI,SAAS,CAACH;QAEtC,sBAAsB;QACtB,IAAI,CAACF,MAAM,GAAGC;QAEd,OAAOA;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5074, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5080, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/manifest-route-matcher-provider.ts"],"sourcesContent":["import type { RouteMatcher } from '../route-matchers/route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { CachedRouteMatcherProvider } from './helpers/cached-route-matcher-provider'\n\nexport abstract class ManifestRouteMatcherProvider<\n  M extends RouteMatcher = RouteMatcher,\n> extends CachedRouteMatcherProvider<M, Manifest | null> {\n  constructor(manifestName: string, manifestLoader: ManifestLoader) {\n    super({\n      load: async () => manifestLoader.load(manifestName),\n      compare: (left, right) => left === right,\n    })\n  }\n}\n"],"names":["CachedRouteMatcherProvider","ManifestRouteMatcherProvider","constructor","manifestName","manifestLoader","load","compare","left","right"],"mappings":";;;AAKA,SAASA,0BAA0B,QAAQ,0CAAyC;;AAE7E,MAAeC,iRAEZD,6BAAAA;IACRE,YAAYC,YAAoB,EAAEC,cAA8B,CAAE;QAChE,KAAK,CAAC;YACJC,MAAM,UAAYD,eAAeC,IAAI,CAACF;YACtCG,SAAS,CAACC,MAAMC,QAAUD,SAASC;QACrC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 5093, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5099, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/app-page-route-matcher-provider.ts"],"sourcesContent":["import { isAppPageRoute } from '../../lib/is-app-page-route'\n\nimport { APP_PATHS_MANIFEST } from '../../shared/lib/constants'\nimport { AppNormalizers } from '../normalizers/built/app'\nimport { RouteKind } from '../route-kind'\nimport { AppPageRouteMatcher } from '../route-matchers/app-page-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\n\nexport class AppPageRouteMatcherProvider extends ManifestRouteMatcherProvider<AppPageRouteMatcher> {\n  private readonly normalizers: AppNormalizers\n\n  constructor(distDir: string, manifestLoader: ManifestLoader) {\n    super(APP_PATHS_MANIFEST, manifestLoader)\n\n    this.normalizers = new AppNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<AppPageRouteMatcher>> {\n    // This matcher only matches app pages.\n    const pages = Object.keys(manifest).filter((page) => isAppPageRoute(page))\n\n    // Collect all the app paths for each page. This could include any parallel\n    // routes.\n    const allAppPaths: Record<string, string[]> = {}\n    for (const page of pages) {\n      const pathname = this.normalizers.pathname.normalize(page)\n      if (pathname in allAppPaths) allAppPaths[pathname].push(page)\n      else allAppPaths[pathname] = [page]\n    }\n\n    // Format the routes.\n    const matchers: Array<AppPageRouteMatcher> = []\n    for (const [pathname, appPaths] of Object.entries(allAppPaths)) {\n      // TODO-APP: (wyattjoh) this is a hack right now, should be more deterministic\n      const page = appPaths[0]\n\n      const filename = this.normalizers.filename.normalize(manifest[page])\n      const bundlePath = this.normalizers.bundlePath.normalize(page)\n\n      matchers.push(\n        new AppPageRouteMatcher({\n          kind: RouteKind.APP_PAGE,\n          pathname,\n          page,\n          bundlePath,\n          filename,\n          appPaths,\n        })\n      )\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAppPageRoute","APP_PATHS_MANIFEST","AppNormalizers","RouteKind","AppPageRouteMatcher","ManifestRouteMatcherProvider","AppPageRouteMatcherProvider","constructor","distDir","manifestLoader","normalizers","transform","manifest","pages","Object","keys","filter","page","allAppPaths","pathname","normalize","push","matchers","appPaths","entries","filename","bundlePath","kind","APP_PAGE"],"mappings":";;;AAAA,SAASA,cAAc,QAAQ,8BAA6B;AAE5D,SAASC,kBAAkB,QAAQ,6BAA4B;AAC/D,SAASC,cAAc,QAAQ,2BAA0B;AACzD,SAASC,SAAS,QAAQ,gBAAe;AACzC,SAASC,mBAAmB,QAAQ,2CAA0C;AAK9E,SAASC,4BAA4B,QAAQ,oCAAmC;;;;;;;;AAEzE,MAAMC,uQAAoCD,+BAAAA;IAG/CE,YAAYC,OAAe,EAAEC,cAA8B,CAAE;QAC3D,KAAK,2LAACR,qBAAAA,EAAoBQ;QAE1B,IAAI,CAACC,WAAW,GAAG,kMAAIR,iBAAAA,CAAeM;IACxC;IAEA,MAAgBG,UACdC,QAAkB,EAC2B;QAC7C,uCAAuC;QACvC,MAAMC,QAAQC,OAAOC,IAAI,CAACH,UAAUI,MAAM,CAAC,CAACC,OAASjB,sMAAAA,EAAeiB;QAEpE,2EAA2E;QAC3E,UAAU;QACV,MAAMC,cAAwC,CAAC;QAC/C,KAAK,MAAMD,QAAQJ,MAAO;YACxB,MAAMM,WAAW,IAAI,CAACT,WAAW,CAACS,QAAQ,CAACC,SAAS,CAACH;YACrD,IAAIE,YAAYD,aAAaA,WAAW,CAACC,SAAS,CAACE,IAAI,CAACJ;iBACnDC,WAAW,CAACC,SAAS,GAAG;gBAACF;aAAK;QACrC;QAEA,qBAAqB;QACrB,MAAMK,WAAuC,EAAE;QAC/C,KAAK,MAAM,CAACH,UAAUI,SAAS,IAAIT,OAAOU,OAAO,CAACN,aAAc;YAC9D,8EAA8E;YAC9E,MAAMD,OAAOM,QAAQ,CAAC,EAAE;YAExB,MAAME,WAAW,IAAI,CAACf,WAAW,CAACe,QAAQ,CAACL,SAAS,CAACR,QAAQ,CAACK,KAAK;YACnE,MAAMS,aAAa,IAAI,CAAChB,WAAW,CAACgB,UAAU,CAACN,SAAS,CAACH;YAEzDK,SAASD,IAAI,CACX,kNAAIjB,sBAAAA,CAAoB;gBACtBuB,6KAAMxB,YAAAA,CAAUyB,QAAQ;gBACxBT;gBACAF;gBACAS;gBACAD;gBACAF;YACF;QAEJ;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5158, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/app-route-route-matcher-provider.ts"],"sourcesContent":["import { isAppRouteRoute } from '../../lib/is-app-route-route'\nimport { APP_PATHS_MANIFEST } from '../../shared/lib/constants'\nimport { RouteKind } from '../route-kind'\nimport { AppRouteRouteMatcher } from '../route-matchers/app-route-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\nimport { AppNormalizers } from '../normalizers/built/app'\n\nexport class AppRouteRouteMatcherProvider extends ManifestRouteMatcherProvider<AppRouteRouteMatcher> {\n  private readonly normalizers: AppNormalizers\n\n  constructor(distDir: string, manifestLoader: ManifestLoader) {\n    super(APP_PATHS_MANIFEST, manifestLoader)\n\n    this.normalizers = new AppNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<AppRouteRouteMatcher>> {\n    // This matcher only matches app routes.\n    const pages = Object.keys(manifest).filter((page) => isAppRouteRoute(page))\n\n    // Format the routes.\n    const matchers: Array<AppRouteRouteMatcher> = []\n    for (const page of pages) {\n      const filename = this.normalizers.filename.normalize(manifest[page])\n      const pathname = this.normalizers.pathname.normalize(page)\n      const bundlePath = this.normalizers.bundlePath.normalize(page)\n\n      matchers.push(\n        new AppRouteRouteMatcher({\n          kind: RouteKind.APP_ROUTE,\n          pathname,\n          page,\n          bundlePath,\n          filename,\n        })\n      )\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAppRouteRoute","APP_PATHS_MANIFEST","RouteKind","AppRouteRouteMatcher","ManifestRouteMatcherProvider","AppNormalizers","AppRouteRouteMatcherProvider","constructor","distDir","manifestLoader","normalizers","transform","manifest","pages","Object","keys","filter","page","matchers","filename","normalize","pathname","bundlePath","push","kind","APP_ROUTE"],"mappings":";;;AAAA,SAASA,eAAe,QAAQ,+BAA8B;AAC9D,SAASC,kBAAkB,QAAQ,6BAA4B;AAC/D,SAASC,SAAS,QAAQ,gBAAe;AACzC,SAASC,oBAAoB,QAAQ,4CAA2C;AAKhF,SAASC,4BAA4B,QAAQ,oCAAmC;AAChF,SAASC,cAAc,QAAQ,2BAA0B;;;;;;;;AAElD,MAAMC,wQAAqCF,+BAAAA;IAGhDG,YAAYC,OAAe,EAAEC,cAA8B,CAAE;QAC3D,KAAK,2LAACR,qBAAAA,EAAoBQ;QAE1B,IAAI,CAACC,WAAW,GAAG,kMAAIL,iBAAAA,CAAeG;IACxC;IAEA,MAAgBG,UACdC,QAAkB,EAC4B;QAC9C,wCAAwC;QACxC,MAAMC,QAAQC,OAAOC,IAAI,CAACH,UAAUI,MAAM,CAAC,CAACC,6LAASjB,kBAAAA,EAAgBiB;QAErE,qBAAqB;QACrB,MAAMC,WAAwC,EAAE;QAChD,KAAK,MAAMD,QAAQJ,MAAO;YACxB,MAAMM,WAAW,IAAI,CAACT,WAAW,CAACS,QAAQ,CAACC,SAAS,CAACR,QAAQ,CAACK,KAAK;YACnE,MAAMI,WAAW,IAAI,CAACX,WAAW,CAACW,QAAQ,CAACD,SAAS,CAACH;YACrD,MAAMK,aAAa,IAAI,CAACZ,WAAW,CAACY,UAAU,CAACF,SAAS,CAACH;YAEzDC,SAASK,IAAI,CACX,mNAAIpB,uBAAAA,CAAqB;gBACvBqB,6KAAMtB,YAAAA,CAAUuB,SAAS;gBACzBJ;gBACAJ;gBACAK;gBACAH;YACF;QAEJ;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5199, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5205, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/pages-api-route-matcher-provider.ts"],"sourcesContent":["import { isAPIRoute } from '../../lib/is-api-route'\nimport { PAGES_MANIFEST } from '../../shared/lib/constants'\nimport { RouteKind } from '../route-kind'\nimport {\n  PagesAPILocaleRouteMatcher,\n  PagesAPIRouteMatcher,\n} from '../route-matchers/pages-api-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\nimport type { I18NProvider } from '../lib/i18n-provider'\nimport { PagesNormalizers } from '../normalizers/built/pages'\n\nexport class PagesAPIRouteMatcherProvider extends ManifestRouteMatcherProvider<PagesAPIRouteMatcher> {\n  private readonly normalizers: PagesNormalizers\n\n  constructor(\n    distDir: string,\n    manifestLoader: ManifestLoader,\n    private readonly i18nProvider?: I18NProvider\n  ) {\n    super(PAGES_MANIFEST, manifestLoader)\n\n    this.normalizers = new PagesNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<PagesAPIRouteMatcher>> {\n    // This matcher is only for Pages API routes.\n    const pathnames = Object.keys(manifest).filter((pathname) =>\n      isAPIRoute(pathname)\n    )\n\n    const matchers: Array<PagesAPIRouteMatcher> = []\n\n    for (const page of pathnames) {\n      if (this.i18nProvider) {\n        // Match the locale on the page name, or default to the default locale.\n        const { detectedLocale, pathname } = this.i18nProvider.analyze(page)\n\n        matchers.push(\n          new PagesAPILocaleRouteMatcher({\n            kind: RouteKind.PAGES_API,\n            pathname,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n            i18n: {\n              locale: detectedLocale,\n            },\n          })\n        )\n      } else {\n        matchers.push(\n          new PagesAPIRouteMatcher({\n            kind: RouteKind.PAGES_API,\n            // In `pages/`, the page is the same as the pathname.\n            pathname: page,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n          })\n        )\n      }\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAPIRoute","PAGES_MANIFEST","RouteKind","PagesAPILocaleRouteMatcher","PagesAPIRouteMatcher","ManifestRouteMatcherProvider","PagesNormalizers","PagesAPIRouteMatcherProvider","constructor","distDir","manifestLoader","i18nProvider","normalizers","transform","manifest","pathnames","Object","keys","filter","pathname","matchers","page","detectedLocale","analyze","push","kind","PAGES_API","bundlePath","normalize","filename","i18n","locale"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,yBAAwB;AACnD,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,SAAS,QAAQ,gBAAe;AACzC,SACEC,0BAA0B,EAC1BC,oBAAoB,QACf,4CAA2C;AAKlD,SAASC,4BAA4B,QAAQ,oCAAmC;AAEhF,SAASC,gBAAgB,QAAQ,6BAA4B;;;;;;;;AAEtD,MAAMC,wQAAqCF,+BAAAA;IAGhDG,YACEC,OAAe,EACfC,cAA8B,EACbC,YAA2B,CAC5C;QACA,KAAK,2LAACV,iBAAAA,EAAgBS;aAFLC,YAAAA,GAAAA;QAIjB,IAAI,CAACC,WAAW,GAAG,oMAAIN,mBAAAA,CAAiBG;IAC1C;IAEA,MAAgBI,UACdC,QAAkB,EAC4B;QAC9C,6CAA6C;QAC7C,MAAMC,YAAYC,OAAOC,IAAI,CAACH,UAAUI,MAAM,CAAC,CAACC,wLAC9CnB,aAAAA,EAAWmB;QAGb,MAAMC,WAAwC,EAAE;QAEhD,KAAK,MAAMC,QAAQN,UAAW;YAC5B,IAAI,IAAI,CAACJ,YAAY,EAAE;gBACrB,uEAAuE;gBACvE,MAAM,EAAEW,cAAc,EAAEH,QAAQ,EAAE,GAAG,IAAI,CAACR,YAAY,CAACY,OAAO,CAACF;gBAE/DD,SAASI,IAAI,CACX,mNAAIrB,6BAAAA,CAA2B;oBAC7BsB,4KAAMvB,aAAAA,CAAUwB,SAAS;oBACzBP;oBACAE;oBACAM,YAAY,IAAI,CAACf,WAAW,CAACe,UAAU,CAACC,SAAS,CAACP;oBAClDQ,UAAU,IAAI,CAACjB,WAAW,CAACiB,QAAQ,CAACD,SAAS,CAACd,QAAQ,CAACO,KAAK;oBAC5DS,MAAM;wBACJC,QAAQT;oBACV;gBACF;YAEJ,OAAO;gBACLF,SAASI,IAAI,CACX,mNAAIpB,uBAAAA,CAAqB;oBACvBqB,4KAAMvB,aAAAA,CAAUwB,SAAS;oBACzB,qDAAqD;oBACrDP,UAAUE;oBACVA;oBACAM,YAAY,IAAI,CAACf,WAAW,CAACe,UAAU,CAACC,SAAS,CAACP;oBAClDQ,UAAU,IAAI,CAACjB,WAAW,CAACiB,QAAQ,CAACD,SAAS,CAACd,QAAQ,CAACO,KAAK;gBAC9D;YAEJ;QACF;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5259, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5265, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/pages-route-matcher-provider.ts"],"sourcesContent":["import { isAPIRoute } from '../../lib/is-api-route'\nimport { BLOCKED_PAGES, PAGES_MANIFEST } from '../../shared/lib/constants'\nimport { RouteKind } from '../route-kind'\nimport {\n  PagesLocaleRouteMatcher,\n  PagesRouteMatcher,\n} from '../route-matchers/pages-route-matcher'\nimport type {\n  Manifest,\n  ManifestLoader,\n} from './helpers/manifest-loaders/manifest-loader'\nimport { ManifestRouteMatcherProvider } from './manifest-route-matcher-provider'\nimport type { I18NProvider } from '../lib/i18n-provider'\nimport { PagesNormalizers } from '../normalizers/built/pages'\n\nexport class PagesRouteMatcherProvider extends ManifestRouteMatcherProvider<PagesRouteMatcher> {\n  private readonly normalizers: PagesNormalizers\n\n  constructor(\n    distDir: string,\n    manifestLoader: ManifestLoader,\n    private readonly i18nProvider?: I18NProvider\n  ) {\n    super(PAGES_MANIFEST, manifestLoader)\n\n    this.normalizers = new PagesNormalizers(distDir)\n  }\n\n  protected async transform(\n    manifest: Manifest\n  ): Promise<ReadonlyArray<PagesRouteMatcher>> {\n    // This matcher is only for Pages routes, not Pages API routes which are\n    // included in this manifest.\n    const pathnames = Object.keys(manifest)\n      .filter((pathname) => !isAPIRoute(pathname))\n      // Remove any blocked pages (page that can't be routed to, like error or\n      // internal pages).\n      .filter((pathname) => {\n        const normalized =\n          this.i18nProvider?.analyze(pathname).pathname ?? pathname\n\n        // Skip any blocked pages.\n        if (BLOCKED_PAGES.includes(normalized)) return false\n\n        return true\n      })\n\n    const matchers: Array<PagesRouteMatcher> = []\n    for (const page of pathnames) {\n      if (this.i18nProvider) {\n        // Match the locale on the page name, or default to the default locale.\n        const { detectedLocale, pathname } = this.i18nProvider.analyze(page)\n\n        matchers.push(\n          new PagesLocaleRouteMatcher({\n            kind: RouteKind.PAGES,\n            pathname,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n            i18n: {\n              locale: detectedLocale,\n            },\n          })\n        )\n      } else {\n        matchers.push(\n          new PagesRouteMatcher({\n            kind: RouteKind.PAGES,\n            // In `pages/`, the page is the same as the pathname.\n            pathname: page,\n            page,\n            bundlePath: this.normalizers.bundlePath.normalize(page),\n            filename: this.normalizers.filename.normalize(manifest[page]),\n          })\n        )\n      }\n    }\n\n    return matchers\n  }\n}\n"],"names":["isAPIRoute","BLOCKED_PAGES","PAGES_MANIFEST","RouteKind","PagesLocaleRouteMatcher","PagesRouteMatcher","ManifestRouteMatcherProvider","PagesNormalizers","PagesRouteMatcherProvider","constructor","distDir","manifestLoader","i18nProvider","normalizers","transform","manifest","pathnames","Object","keys","filter","pathname","normalized","analyze","includes","matchers","page","detectedLocale","push","kind","PAGES","bundlePath","normalize","filename","i18n","locale"],"mappings":";;;AAAA,SAASA,UAAU,QAAQ,yBAAwB;AACnD,SAASC,aAAa,EAAEC,cAAc,QAAQ,6BAA4B;AAC1E,SAASC,SAAS,QAAQ,gBAAe;AACzC,SACEC,uBAAuB,EACvBC,iBAAiB,QACZ,wCAAuC;AAK9C,SAASC,4BAA4B,QAAQ,oCAAmC;AAEhF,SAASC,gBAAgB,QAAQ,6BAA4B;;;;;;;;AAEtD,MAAMC,qQAAkCF,+BAAAA;IAG7CG,YACEC,OAAe,EACfC,cAA8B,EACbC,YAA2B,CAC5C;QACA,KAAK,2LAACV,iBAAAA,EAAgBS;aAFLC,YAAAA,GAAAA;QAIjB,IAAI,CAACC,WAAW,GAAG,oMAAIN,mBAAAA,CAAiBG;IAC1C;IAEA,MAAgBI,UACdC,QAAkB,EACyB;QAC3C,wEAAwE;QACxE,6BAA6B;QAC7B,MAAMC,YAAYC,OAAOC,IAAI,CAACH,UAC3BI,MAAM,CAAC,CAACC,WAAa,8KAACpB,aAAAA,EAAWoB,WAClC,wEAAwE;QACxE,mBAAmB;SAClBD,MAAM,CAAC,CAACC;gBAEL;YADF,MAAMC,aACJ,CAAA,CAAA,qBAAA,IAAI,CAACT,YAAY,KAAA,OAAA,KAAA,IAAjB,mBAAmBU,OAAO,CAACF,UAAUA,QAAQ,KAAIA;YAEnD,0BAA0B;YAC1B,8LAAInB,gBAAAA,CAAcsB,QAAQ,CAACF,aAAa,OAAO;YAE/C,OAAO;QACT;QAEF,MAAMG,WAAqC,EAAE;QAC7C,KAAK,MAAMC,QAAQT,UAAW;YAC5B,IAAI,IAAI,CAACJ,YAAY,EAAE;gBACrB,uEAAuE;gBACvE,MAAM,EAAEc,cAAc,EAAEN,QAAQ,EAAE,GAAG,IAAI,CAACR,YAAY,CAACU,OAAO,CAACG;gBAE/DD,SAASG,IAAI,CACX,4MAAIvB,0BAAAA,CAAwB;oBAC1BwB,6KAAMzB,YAAAA,CAAU0B,KAAK;oBACrBT;oBACAK;oBACAK,YAAY,IAAI,CAACjB,WAAW,CAACiB,UAAU,CAACC,SAAS,CAACN;oBAClDO,UAAU,IAAI,CAACnB,WAAW,CAACmB,QAAQ,CAACD,SAAS,CAAChB,QAAQ,CAACU,KAAK;oBAC5DQ,MAAM;wBACJC,QAAQR;oBACV;gBACF;YAEJ,OAAO;gBACLF,SAASG,IAAI,CACX,4MAAItB,oBAAAA,CAAkB;oBACpBuB,6KAAMzB,YAAAA,CAAU0B,KAAK;oBACrB,qDAAqD;oBACrDT,UAAUK;oBACVA;oBACAK,YAAY,IAAI,CAACjB,WAAW,CAACiB,UAAU,CAACC,SAAS,CAACN;oBAClDO,UAAU,IAAI,CAACnB,WAAW,CAACmB,QAAQ,CAACD,SAAS,CAAChB,QAAQ,CAACU,KAAK;gBAC9D;YAEJ;QACF;QAEA,OAAOD;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 5328, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5334, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-matcher-providers/helpers/manifest-loaders/server-manifest-loader.ts"],"sourcesContent":["import type { Manifest, ManifestLoader } from './manifest-loader'\n\nexport class ServerManifestLoader implements ManifestLoader {\n  constructor(private readonly getter: (name: string) => Manifest | null) {}\n\n  public load(name: string): Manifest | null {\n    return this.getter(name)\n  }\n}\n"],"names":["ServerManifestLoader","constructor","getter","load","name"],"mappings":";;;AAEO,MAAMA;IACXC,YAA6BC,MAAyC,CAAE;aAA3CA,MAAAA,GAAAA;IAA4C;IAElEC,KAAKC,IAAY,EAAmB;QACzC,OAAO,IAAI,CAACF,MAAM,CAACE;IACrB;AACF","ignoreList":[0]}},
    {"offset": {"line": 5345, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5351, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/send-response.ts"],"sourcesContent":["import type { BaseNextRequest, BaseNextResponse } from './base-http'\nimport { isNodeNextResponse } from './base-http/helpers'\n\nimport { pipeToNodeResponse } from './pipe-readable'\nimport { splitCookiesString } from './web/utils'\n\n/**\n * Sends the response on the underlying next response object.\n *\n * @param req the underlying request object\n * @param res the underlying response object\n * @param response the response to send\n */\nexport async function sendResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  response: Response,\n  waitUntil?: Promise<unknown>\n): Promise<void> {\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextResponse(res)\n  ) {\n    // Copy over the response status.\n    res.statusCode = response.status\n    res.statusMessage = response.statusText\n\n    // can add more headers to this list if needed\n    const headersWithMultipleValuesAllowed = [\n      'set-cookie',\n      'www-authenticate',\n      'proxy-authenticate',\n    ]\n\n    // Copy over the response headers.\n    response.headers?.forEach((value, name) => {\n      // The append handling is special cased for `set-cookie`.\n      if (name.toLowerCase() === 'set-cookie') {\n        // TODO: (wyattjoh) replace with native response iteration when we can upgrade undici\n        for (const cookie of splitCookiesString(value)) {\n          res.appendHeader(name, cookie)\n        }\n      } else {\n        // only append the header if it is either not present in the outbound response\n        // or if the header supports multiple values\n        const isHeaderPresent = typeof res.getHeader(name) !== 'undefined'\n        if (\n          headersWithMultipleValuesAllowed.includes(name.toLowerCase()) ||\n          !isHeaderPresent\n        ) {\n          res.appendHeader(name, value)\n        }\n      }\n    })\n\n    /**\n     * The response can't be directly piped to the underlying response. The\n     * following is duplicated from the edge runtime handler.\n     *\n     * See packages/next/server/next-server.ts\n     */\n\n    const { originalResponse } = res\n\n    // A response body must not be sent for HEAD requests. See https://httpwg.org/specs/rfc9110.html#HEAD\n    if (response.body && req.method !== 'HEAD') {\n      await pipeToNodeResponse(response.body, originalResponse, waitUntil)\n    } else {\n      originalResponse.end()\n    }\n  }\n}\n"],"names":["isNodeNextResponse","pipeToNodeResponse","splitCookiesString","sendResponse","req","res","response","waitUntil","process","env","NEXT_RUNTIME","statusCode","status","statusMessage","statusText","headersWithMultipleValuesAllowed","headers","forEach","value","name","toLowerCase","cookie","appendHeader","isHeaderPresent","getHeader","includes","originalResponse","body","method","end"],"mappings":";;;AACA,SAASA,kBAAkB,QAAQ,sBAAqB;AAExD,SAASC,kBAAkB,QAAQ,kBAAiB;AACpD,SAASC,kBAAkB,QAAQ,cAAa;;;;AASzC,eAAeC,aACpBC,GAAoB,EACpBC,GAAqB,EACrBC,QAAkB,EAClBC,SAA4B;IAE5B,IACE,mCAIA,kCAJqE;;YAgBrE,AACAD,kCADkC;IAoCpC;AACF","ignoreList":[0]}},
    {"offset": {"line": 5366, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5372, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-modules/checks.ts"],"sourcesContent":["import type { AppRouteRouteModule } from './app-route/module'\nimport type { AppPageRouteModule } from './app-page/module'\nimport type { PagesRouteModule } from './pages/module'\nimport type { PagesAPIRouteModule } from './pages-api/module'\n\nimport type { RouteModule } from './route-module'\n\nimport { RouteKind } from '../route-kind'\n\nexport function isAppRouteRouteModule(\n  routeModule: RouteModule\n): routeModule is AppRouteRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_ROUTE\n}\n\nexport function isAppPageRouteModule(\n  routeModule: RouteModule\n): routeModule is AppPageRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_PAGE\n}\n\nexport function isPagesRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES\n}\n\nexport function isPagesAPIRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesAPIRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES_API\n}\n"],"names":["RouteKind","isAppRouteRouteModule","routeModule","definition","kind","APP_ROUTE","isAppPageRouteModule","APP_PAGE","isPagesRouteModule","PAGES","isPagesAPIRouteModule","PAGES_API"],"mappings":";;;;;;AAOA,SAASA,SAAS,QAAQ,gBAAe;;AAElC,SAASC,sBACdC,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUK,SAAS;AAC5D;AAEO,SAASC,qBACdJ,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUO,QAAQ;AAC3D;AAEO,SAASC,mBACdN,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUS,KAAK;AACxD;AAEO,SAASC,sBACdR,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,4KAAKJ,YAAAA,CAAUW,SAAS;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 5392, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5398, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-modules/route-module.ts"],"sourcesContent":["import type { RouteDefinition } from '../route-definitions/route-definition'\n\n/**\n * RouteModuleOptions is the options that are passed to the route module, other\n * route modules should extend this class to add specific options for their\n * route.\n */\nexport interface RouteModuleOptions<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  readonly definition: Readonly<D>\n  readonly userland: Readonly<U>\n}\n\n/**\n * RouteHandlerContext is the base context for a route handler.\n */\nexport interface RouteModuleHandleContext {\n  /**\n   * Any matched parameters for the request. This is only defined for dynamic\n   * routes.\n   */\n  params: Record<string, string | string[] | undefined> | undefined\n}\n\n/**\n * RouteModule is the base class for all route modules. This class should be\n * extended by all route modules.\n */\nexport abstract class RouteModule<\n  D extends RouteDefinition = RouteDefinition,\n  U = unknown,\n> {\n  /**\n   * The userland module. This is the module that is exported from the user's\n   * code. This is marked as readonly to ensure that the module is not mutated\n   * because the module (when compiled) only provides getters.\n   */\n  public readonly userland: Readonly<U>\n\n  /**\n   * The definition of the route.\n   */\n  public readonly definition: Readonly<D>\n\n  /**\n   * The shared modules that are exposed and required for the route module.\n   */\n  public static readonly sharedModules: any\n\n  constructor({ userland, definition }: RouteModuleOptions<D, U>) {\n    this.userland = userland\n    this.definition = definition\n  }\n}\n"],"names":["RouteModule","constructor","userland","definition"],"mappings":"AA0BA;;;CAGC,GACD;;;AAAO,MAAeA;IAqBpBC,YAAY,EAAEC,QAAQ,EAAEC,UAAU,EAA4B,CAAE;QAC9D,IAAI,CAACD,QAAQ,GAAGA;QAChB,IAAI,CAACC,UAAU,GAAGA;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 5410, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-modules/app-page/vendored/contexts/entrypoints.ts"],"sourcesContent":["export * as HeadManagerContext from '../../../../../shared/lib/head-manager-context.shared-runtime'\nexport * as ServerInsertedHtml from '../../../../../shared/lib/server-inserted-html.shared-runtime'\nexport * as AppRouterContext from '../../../../../shared/lib/app-router-context.shared-runtime'\nexport * as HooksClientContext from '../../../../../shared/lib/hooks-client-context.shared-runtime'\nexport * as RouterContext from '../../../../../shared/lib/router-context.shared-runtime'\nexport * as AmpContext from '../../../../../shared/lib/amp-context.shared-runtime'\nexport * as ImageConfigContext from '../../../../../shared/lib/image-config-context.shared-runtime'\n"],"names":["HeadManagerContext","ServerInsertedHtml","AppRouterContext","HooksClientContext","RouterContext","AmpContext","ImageConfigContext"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 5425, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5486, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-modules/app-page/module.ts"],"sourcesContent":["import type { AppPageRouteDefinition } from '../../route-definitions/app-page-route-definition'\nimport type RenderResult from '../../render-result'\nimport type { RenderOpts } from '../../app-render/types'\nimport type { NextParsedUrlQuery } from '../../request-meta'\nimport type { LoaderTree } from '../../lib/app-dir-module'\n\nimport { renderToHTMLOrFlight } from '../../app-render/app-render'\nimport {\n  RouteModule,\n  type RouteModuleOptions,\n  type RouteModuleHandleContext,\n} from '../route-module'\nimport * as vendoredContexts from './vendored/contexts/entrypoints'\nimport type { BaseNextRequest, BaseNextResponse } from '../../base-http'\nimport type { ServerComponentsHmrCache } from '../../response-cache'\nimport type { FallbackRouteParams } from '../../request/fallback-params'\n\nlet vendoredReactRSC\nlet vendoredReactSSR\n\n// the vendored Reacts are loaded from their original source in the edge runtime\nif (process.env.NEXT_RUNTIME !== 'edge') {\n  vendoredReactRSC = require('./vendored/rsc/entrypoints')\n  vendoredReactSSR = require('./vendored/ssr/entrypoints')\n}\n\n/**\n * The AppPageModule is the type of the module exported by the bundled app page\n * module.\n */\nexport type AppPageModule = typeof import('../../../build/templates/app-page')\n\ntype AppPageUserlandModule = {\n  /**\n   * The tree created in next-app-loader that holds component segments and modules\n   */\n  loaderTree: LoaderTree\n}\n\nexport interface AppPageRouteHandlerContext extends RouteModuleHandleContext {\n  page: string\n  query: NextParsedUrlQuery\n  fallbackRouteParams: FallbackRouteParams | null\n  renderOpts: RenderOpts\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n}\n\nexport type AppPageRouteModuleOptions = RouteModuleOptions<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n>\n\nexport class AppPageRouteModule extends RouteModule<\n  AppPageRouteDefinition,\n  AppPageUserlandModule\n> {\n  public render(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      false\n    )\n  }\n\n  public warmup(\n    req: BaseNextRequest,\n    res: BaseNextResponse,\n    context: AppPageRouteHandlerContext\n  ): Promise<RenderResult> {\n    return renderToHTMLOrFlight(\n      req,\n      res,\n      context.page,\n      context.query,\n      context.fallbackRouteParams,\n      context.renderOpts,\n      context.serverComponentsHmrCache,\n      true\n    )\n  }\n}\n\nconst vendored = {\n  'react-rsc': vendoredReactRSC,\n  'react-ssr': vendoredReactSSR,\n  contexts: vendoredContexts,\n}\n\nexport { renderToHTMLOrFlight, vendored }\n\nexport default AppPageRouteModule\n"],"names":["renderToHTMLOrFlight","RouteModule","vendoredContexts","vendoredReactRSC","vendoredReactSSR","process","env","NEXT_RUNTIME","require","AppPageRouteModule","render","req","res","context","page","query","fallbackRouteParams","renderOpts","serverComponentsHmrCache","warmup","vendored","contexts"],"mappings":";;;;;AAMA,SAASA,oBAAoB,QAAQ,8BAA6B;AAClE,SACEC,WAAW,QAGN,kBAAiB;AACxB,YAAYC,sBAAsB,kCAAiC;;;;AAKnE,IAAIC;AACJ,IAAIC;AAEJ,gFAAgF;AAChF,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,MAAQ;;AAGzC;AA4BO,MAAME,wNAA2BR,cAAAA;IAI/BS,OACLC,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,mMAAOb,uBAAAA,EACLW,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChC;IAEJ;IAEOC,OACLR,GAAoB,EACpBC,GAAqB,EACrBC,OAAmC,EACZ;QACvB,mMAAOb,uBAAAA,EACLW,KACAC,KACAC,QAAQC,IAAI,EACZD,QAAQE,KAAK,EACbF,QAAQG,mBAAmB,EAC3BH,QAAQI,UAAU,EAClBJ,QAAQK,wBAAwB,EAChC;IAEJ;AACF;AAEA,MAAME,WAAW;IACf,aAAajB;IACb,aAAaC;IACbiB,UAAUnB;AACZ;;uCAIeO,mBAAkB","ignoreList":[0]}},
    {"offset": {"line": 5519, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5563, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n    } else if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n    } else if (process.env.TURBOPACK) {\n      module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n    } else {\n      module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,OAAQ;IACvCC,OAAOC,OAAO,GAAGC,QAAQ;AAC3B,OAAO;;AAkBP","ignoreList":[0]}},
    {"offset": {"line": 5568, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5574, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isRevalidate?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isRevalidate) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isRevalidate","undefined"],"mappings":";;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,YAAY,EAAE;QACvB,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 5586, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5592, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isRevalidate?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isRevalidate) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isRevalidate","undefined"],"mappings":";;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,YAAY,EAAE;QACvB,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 5604, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5610, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/resume-data-cache/cache-store.ts"],"sourcesContent":["import {\n  arrayBufferToString,\n  stringToUint8Array,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CachedFetchValue } from '../response-cache/types'\n\n/**\n * A generic cache store type that provides a subset of Map functionality\n */\ntype CacheStore<T> = Pick<Map<string, T>, 'entries' | 'size' | 'get' | 'set'>\n\n/**\n * A cache store specifically for fetch cache values\n */\nexport type FetchCacheStore = CacheStore<CachedFetchValue>\n\n/**\n * Parses fetch cache entries into a FetchCacheStore\n * @param entries - The entries to parse into the store\n * @returns A new FetchCacheStore containing the entries\n */\nexport function parseFetchCacheStore(\n  entries: Iterable<[string, CachedFetchValue]>\n): FetchCacheStore {\n  return new Map(entries)\n}\n\n/**\n * Stringifies a FetchCacheStore into an array of key-value pairs\n * @param store - The store to stringify\n * @returns A promise that resolves to an array of key-value pairs\n */\nexport function stringifyFetchCacheStore(\n  entries: IterableIterator<[string, CachedFetchValue]>\n): [string, CachedFetchValue][] {\n  return Array.from(entries)\n}\n\n/**\n * Serialized format for cache entries\n */\ninterface CacheCacheStoreSerialized {\n  value: string\n  tags: string[]\n  stale: number\n  timestamp: number\n  expire: number\n  revalidate: number\n}\n\n/**\n * A cache store specifically for \"use cache\" values that stores promises of\n * cache entries.\n */\nexport type UseCacheCacheStore = Pick<\n  Map<string, Promise<CacheEntry>>,\n  'entries' | 'size' | 'get' | 'set'\n>\n\n/**\n * Parses serialized cache entries into a UseCacheCacheStore\n * @param entries - The serialized entries to parse\n * @returns A new UseCacheCacheStore containing the parsed entries\n */\nexport function parseUseCacheCacheStore(\n  entries: Iterable<[string, CacheCacheStoreSerialized]>\n): UseCacheCacheStore {\n  const store = new Map<string, Promise<CacheEntry>>()\n\n  for (const [\n    key,\n    { value, tags, stale, timestamp, expire, revalidate },\n  ] of entries) {\n    store.set(\n      key,\n      Promise.resolve({\n        // Create a ReadableStream from the Uint8Array\n        value: new ReadableStream<Uint8Array>({\n          start(controller) {\n            // Enqueue the Uint8Array to the stream\n            controller.enqueue(stringToUint8Array(atob(value)))\n\n            // Close the stream\n            controller.close()\n          },\n        }),\n        tags,\n        stale,\n        timestamp,\n        expire,\n        revalidate,\n      })\n    )\n  }\n\n  return store\n}\n\n/**\n * Stringifies a UseCacheCacheStore into an array of key-value pairs\n * @param store - The store to stringify\n * @returns A promise that resolves to an array of key-value pairs with serialized values\n */\nexport async function stringifyUseCacheCacheStore(\n  entries: IterableIterator<[string, Promise<CacheEntry>]>\n): Promise<[string, CacheCacheStoreSerialized][]> {\n  return Promise.all(\n    Array.from(entries).map(([key, value]) => {\n      return value.then(async (entry) => {\n        const [left, right] = entry.value.tee()\n        entry.value = right\n\n        let binaryString: string = ''\n\n        // We want to encode the value as a string, but we aren't sure if the\n        // value is a a stream of UTF-8 bytes or not, so let's just encode it\n        // as a string using base64.\n        for await (const chunk of left) {\n          binaryString += arrayBufferToString(chunk)\n        }\n\n        return [\n          key,\n          {\n            // Encode the value as a base64 string.\n            value: btoa(binaryString),\n            tags: entry.tags,\n            stale: entry.stale,\n            timestamp: entry.timestamp,\n            expire: entry.expire,\n            revalidate: entry.revalidate,\n          },\n        ] as [string, CacheCacheStoreSerialized]\n      })\n    })\n  )\n}\n"],"names":["arrayBufferToString","stringToUint8Array","parseFetchCacheStore","entries","Map","stringifyFetchCacheStore","Array","from","parseUseCacheCacheStore","store","key","value","tags","stale","timestamp","expire","revalidate","set","Promise","resolve","ReadableStream","start","controller","enqueue","atob","close","stringifyUseCacheCacheStore","all","map","then","entry","left","right","tee","binaryString","chunk","btoa"],"mappings":";;;;;;AAAA,SACEA,mBAAmB,EACnBC,kBAAkB,QACb,iCAAgC;;AAmBhC,SAASC,qBACdC,OAA6C;IAE7C,OAAO,IAAIC,IAAID;AACjB;AAOO,SAASE,yBACdF,OAAqD;IAErD,OAAOG,MAAMC,IAAI,CAACJ;AACpB;AA4BO,SAASK,wBACdL,OAAsD;IAEtD,MAAMM,QAAQ,IAAIL;IAElB,KAAK,MAAM,CACTM,KACA,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,UAAU,EAAE,CACtD,IAAIb,QAAS;QACZM,MAAMQ,GAAG,CACPP,KACAQ,QAAQC,OAAO,CAAC;YACd,8CAA8C;YAC9CR,OAAO,IAAIS,eAA2B;gBACpCC,OAAMC,UAAU;oBACd,uCAAuC;oBACvCA,WAAWC,OAAO,mMAACtB,qBAAAA,EAAmBuB,KAAKb;oBAE3C,mBAAmB;oBACnBW,WAAWG,KAAK;gBAClB;YACF;YACAb;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,OAAOP;AACT;AAOO,eAAeiB,4BACpBvB,OAAwD;IAExD,OAAOe,QAAQS,GAAG,CAChBrB,MAAMC,IAAI,CAACJ,SAASyB,GAAG,CAAC,CAAC,CAAClB,KAAKC,MAAM;QACnC,OAAOA,MAAMkB,IAAI,CAAC,OAAOC;YACvB,MAAM,CAACC,MAAMC,MAAM,GAAGF,MAAMnB,KAAK,CAACsB,GAAG;YACrCH,MAAMnB,KAAK,GAAGqB;YAEd,IAAIE,eAAuB;YAE3B,qEAAqE;YACrE,qEAAqE;YACrE,4BAA4B;YAC5B,WAAW,MAAMC,SAASJ,KAAM;gBAC9BG,iBAAgBlC,uNAAAA,EAAoBmC;YACtC;YAEA,OAAO;gBACLzB;gBACA;oBACE,uCAAuC;oBACvCC,OAAOyB,KAAKF;oBACZtB,MAAMkB,MAAMlB,IAAI;oBAChBC,OAAOiB,MAAMjB,KAAK;oBAClBC,WAAWgB,MAAMhB,SAAS;oBAC1BC,QAAQe,MAAMf,MAAM;oBACpBC,YAAYc,MAAMd,UAAU;gBAC9B;aACD;QACH;IACF;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 5673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5679, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/resume-data-cache/resume-data-cache.ts"],"sourcesContent":["import {\n  type UseCacheCacheStore,\n  type FetchCacheStore,\n  stringifyFetchCacheStore,\n  stringifyUseCacheCacheStore,\n  parseUseCacheCacheStore,\n  parseFetchCacheStore,\n} from './cache-store'\n\n/**\n * An immutable version of the resume data cache used during rendering.\n * This cache is read-only and cannot be modified once created.\n */\nexport interface RenderResumeDataCache {\n  /**\n   * A read-only Map store for values cached by the 'use cache' React hook.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly cache: Omit<UseCacheCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for cached fetch responses.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly fetch: Omit<FetchCacheStore, 'set'>\n}\n\n/**\n * A mutable version of the resume data cache used during pre-rendering.\n * This cache allows both reading and writing of cached values.\n */\nexport interface PrerenderResumeDataCache {\n  /**\n   * A mutable Map store for values cached by the 'use cache' React hook.\n   * Supports both get and set operations to build the cache during pre-rendering.\n   */\n  readonly cache: UseCacheCacheStore\n\n  /**\n   * A mutable Map store for cached fetch responses.\n   * Supports both get and set operations to build the cache during pre-rendering.\n   */\n  readonly fetch: FetchCacheStore\n}\n\ntype ResumeStoreSerialized = {\n  store: {\n    cache: {\n      [key: string]: any\n    }\n    fetch: {\n      [key: string]: any\n    }\n  }\n}\n\n/**\n * Serializes a resume data cache into a JSON string for storage or transmission.\n * Handles both 'use cache' values and fetch responses.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or 'null' if empty\n */\nexport async function stringifyResumeDataCache(\n  resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n): Promise<string> {\n  if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n    return 'null'\n  }\n\n  const json: ResumeStoreSerialized = {\n    store: {\n      fetch: Object.fromEntries(\n        stringifyFetchCacheStore(resumeDataCache.fetch.entries())\n      ),\n      cache: Object.fromEntries(\n        await stringifyUseCacheCacheStore(resumeDataCache.cache.entries())\n      ),\n    },\n  }\n\n  return JSON.stringify(json)\n}\n\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */\nexport function createPrerenderResumeDataCache(): PrerenderResumeDataCache {\n  return {\n    cache: new Map(),\n    fetch: new Map(),\n  }\n}\n\n/**\n * Creates an immutable render resume data cache from either:\n * 1. An existing prerender cache instance\n * 2. A serialized cache string\n *\n * @param prerenderResumeDataCache - A PrerenderResumeDataCache instance to convert to immutable\n * @param persistedCache - A serialized cache string to parse\n * @returns An immutable RenderResumeDataCache instance\n */\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  persistedCache: string\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCacheOrPersistedCache: PrerenderResumeDataCache | string\n): RenderResumeDataCache {\n  if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n    // If the cache is already a prerender cache, we can return it directly,\n    // we're just performing a type change.\n    return prerenderResumeDataCacheOrPersistedCache\n  }\n\n  if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n    return {\n      cache: new Map(),\n      fetch: new Map(),\n    }\n  }\n\n  const json: ResumeStoreSerialized = JSON.parse(\n    prerenderResumeDataCacheOrPersistedCache\n  )\n  return {\n    cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n    fetch: parseFetchCacheStore(Object.entries(json.store.fetch)),\n  }\n}\n"],"names":["stringifyFetchCacheStore","stringifyUseCacheCacheStore","parseUseCacheCacheStore","parseFetchCacheStore","stringifyResumeDataCache","resumeDataCache","fetch","size","cache","json","store","Object","fromEntries","entries","JSON","stringify","createPrerenderResumeDataCache","Map","createRenderResumeDataCache","prerenderResumeDataCacheOrPersistedCache","parse"],"mappings":";;;;;AAAA,SAGEA,wBAAwB,EACxBC,2BAA2B,EAC3BC,uBAAuB,EACvBC,oBAAoB,QACf,gBAAe;;AAwDf,eAAeC,yBACpBC,eAAiE;IAEjE,IAAIA,gBAAgBC,KAAK,CAACC,IAAI,KAAK,KAAKF,gBAAgBG,KAAK,CAACD,IAAI,KAAK,GAAG;QACxE,OAAO;IACT;IAEA,MAAME,OAA8B;QAClCC,OAAO;YACLJ,OAAOK,OAAOC,WAAW,wMACvBZ,2BAAAA,EAAyBK,gBAAgBC,KAAK,CAACO,OAAO;YAExDL,OAAOG,OAAOC,WAAW,CACvB,6MAAMX,8BAAAA,EAA4BI,gBAAgBG,KAAK,CAACK,OAAO;QAEnE;IACF;IAEA,OAAOC,KAAKC,SAAS,CAACN;AACxB;AASO,SAASO;IACd,OAAO;QACLR,OAAO,IAAIS;QACXX,OAAO,IAAIW;IACb;AACF;AAiBO,SAASC,4BACdC,wCAA2E;IAE3E,IAAI,OAAOA,6CAA6C,UAAU;QAChE,wEAAwE;QACxE,uCAAuC;QACvC,OAAOA;IACT;IAEA,IAAIA,6CAA6C,QAAQ;QACvD,OAAO;YACLX,OAAO,IAAIS;YACXX,OAAO,IAAIW;QACb;IACF;IAEA,MAAMR,OAA8BK,KAAKM,KAAK,CAC5CD;IAEF,OAAO;QACLX,QAAON,gOAAAA,EAAwBS,OAAOE,OAAO,CAACJ,KAAKC,KAAK,CAACF,KAAK;QAC9DF,8MAAOH,uBAAAA,EAAqBQ,OAAOE,OAAO,CAACJ,KAAKC,KAAK,CAACJ,KAAK;IAC7D;AACF","ignoreList":[0]}},
    {"offset": {"line": 5722, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5728, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/resume-data-cache/cache-store.ts"],"sourcesContent":["import {\n  arrayBufferToString,\n  stringToUint8Array,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CachedFetchValue } from '../response-cache/types'\n\n/**\n * A generic cache store type that provides a subset of Map functionality\n */\ntype CacheStore<T> = Pick<Map<string, T>, 'entries' | 'size' | 'get' | 'set'>\n\n/**\n * A cache store specifically for fetch cache values\n */\nexport type FetchCacheStore = CacheStore<CachedFetchValue>\n\n/**\n * Parses fetch cache entries into a FetchCacheStore\n * @param entries - The entries to parse into the store\n * @returns A new FetchCacheStore containing the entries\n */\nexport function parseFetchCacheStore(\n  entries: Iterable<[string, CachedFetchValue]>\n): FetchCacheStore {\n  return new Map(entries)\n}\n\n/**\n * Stringifies a FetchCacheStore into an array of key-value pairs\n * @param store - The store to stringify\n * @returns A promise that resolves to an array of key-value pairs\n */\nexport function stringifyFetchCacheStore(\n  entries: IterableIterator<[string, CachedFetchValue]>\n): [string, CachedFetchValue][] {\n  return Array.from(entries)\n}\n\n/**\n * Serialized format for cache entries\n */\ninterface CacheCacheStoreSerialized {\n  value: string\n  tags: string[]\n  stale: number\n  timestamp: number\n  expire: number\n  revalidate: number\n}\n\n/**\n * A cache store specifically for \"use cache\" values that stores promises of\n * cache entries.\n */\nexport type UseCacheCacheStore = Pick<\n  Map<string, Promise<CacheEntry>>,\n  'entries' | 'size' | 'get' | 'set'\n>\n\n/**\n * Parses serialized cache entries into a UseCacheCacheStore\n * @param entries - The serialized entries to parse\n * @returns A new UseCacheCacheStore containing the parsed entries\n */\nexport function parseUseCacheCacheStore(\n  entries: Iterable<[string, CacheCacheStoreSerialized]>\n): UseCacheCacheStore {\n  const store = new Map<string, Promise<CacheEntry>>()\n\n  for (const [\n    key,\n    { value, tags, stale, timestamp, expire, revalidate },\n  ] of entries) {\n    store.set(\n      key,\n      Promise.resolve({\n        // Create a ReadableStream from the Uint8Array\n        value: new ReadableStream<Uint8Array>({\n          start(controller) {\n            // Enqueue the Uint8Array to the stream\n            controller.enqueue(stringToUint8Array(atob(value)))\n\n            // Close the stream\n            controller.close()\n          },\n        }),\n        tags,\n        stale,\n        timestamp,\n        expire,\n        revalidate,\n      })\n    )\n  }\n\n  return store\n}\n\n/**\n * Stringifies a UseCacheCacheStore into an array of key-value pairs\n * @param store - The store to stringify\n * @returns A promise that resolves to an array of key-value pairs with serialized values\n */\nexport async function stringifyUseCacheCacheStore(\n  entries: IterableIterator<[string, Promise<CacheEntry>]>\n): Promise<[string, CacheCacheStoreSerialized][]> {\n  return Promise.all(\n    Array.from(entries).map(([key, value]) => {\n      return value.then(async (entry) => {\n        const [left, right] = entry.value.tee()\n        entry.value = right\n\n        let binaryString: string = ''\n\n        // We want to encode the value as a string, but we aren't sure if the\n        // value is a a stream of UTF-8 bytes or not, so let's just encode it\n        // as a string using base64.\n        for await (const chunk of left) {\n          binaryString += arrayBufferToString(chunk)\n        }\n\n        return [\n          key,\n          {\n            // Encode the value as a base64 string.\n            value: btoa(binaryString),\n            tags: entry.tags,\n            stale: entry.stale,\n            timestamp: entry.timestamp,\n            expire: entry.expire,\n            revalidate: entry.revalidate,\n          },\n        ] as [string, CacheCacheStoreSerialized]\n      })\n    })\n  )\n}\n"],"names":["arrayBufferToString","stringToUint8Array","parseFetchCacheStore","entries","Map","stringifyFetchCacheStore","Array","from","parseUseCacheCacheStore","store","key","value","tags","stale","timestamp","expire","revalidate","set","Promise","resolve","ReadableStream","start","controller","enqueue","atob","close","stringifyUseCacheCacheStore","all","map","then","entry","left","right","tee","binaryString","chunk","btoa"],"mappings":";;;;;;AAAA,SACEA,mBAAmB,EACnBC,kBAAkB,QACb,iCAAgC;;AAmBhC,SAASC,qBACdC,OAA6C;IAE7C,OAAO,IAAIC,IAAID;AACjB;AAOO,SAASE,yBACdF,OAAqD;IAErD,OAAOG,MAAMC,IAAI,CAACJ;AACpB;AA4BO,SAASK,wBACdL,OAAsD;IAEtD,MAAMM,QAAQ,IAAIL;IAElB,KAAK,MAAM,CACTM,KACA,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,SAAS,EAAEC,MAAM,EAAEC,UAAU,EAAE,CACtD,IAAIb,QAAS;QACZM,MAAMQ,GAAG,CACPP,KACAQ,QAAQC,OAAO,CAAC;YACd,8CAA8C;YAC9CR,OAAO,IAAIS,eAA2B;gBACpCC,OAAMC,UAAU;oBACd,uCAAuC;oBACvCA,WAAWC,OAAO,mMAACtB,qBAAAA,EAAmBuB,KAAKb;oBAE3C,mBAAmB;oBACnBW,WAAWG,KAAK;gBAClB;YACF;YACAb;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,OAAOP;AACT;AAOO,eAAeiB,4BACpBvB,OAAwD;IAExD,OAAOe,QAAQS,GAAG,CAChBrB,MAAMC,IAAI,CAACJ,SAASyB,GAAG,CAAC,CAAC,CAAClB,KAAKC,MAAM;QACnC,OAAOA,MAAMkB,IAAI,CAAC,OAAOC;YACvB,MAAM,CAACC,MAAMC,MAAM,GAAGF,MAAMnB,KAAK,CAACsB,GAAG;YACrCH,MAAMnB,KAAK,GAAGqB;YAEd,IAAIE,eAAuB;YAE3B,qEAAqE;YACrE,qEAAqE;YACrE,4BAA4B;YAC5B,WAAW,MAAMC,SAASJ,KAAM;gBAC9BG,iBAAgBlC,uNAAAA,EAAoBmC;YACtC;YAEA,OAAO;gBACLzB;gBACA;oBACE,uCAAuC;oBACvCC,OAAOyB,KAAKF;oBACZtB,MAAMkB,MAAMlB,IAAI;oBAChBC,OAAOiB,MAAMjB,KAAK;oBAClBC,WAAWgB,MAAMhB,SAAS;oBAC1BC,QAAQe,MAAMf,MAAM;oBACpBC,YAAYc,MAAMd,UAAU;gBAC9B;aACD;QACH;IACF;AAEJ","ignoreList":[0]}},
    {"offset": {"line": 5791, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5797, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/resume-data-cache/resume-data-cache.ts"],"sourcesContent":["import {\n  type UseCacheCacheStore,\n  type FetchCacheStore,\n  stringifyFetchCacheStore,\n  stringifyUseCacheCacheStore,\n  parseUseCacheCacheStore,\n  parseFetchCacheStore,\n} from './cache-store'\n\n/**\n * An immutable version of the resume data cache used during rendering.\n * This cache is read-only and cannot be modified once created.\n */\nexport interface RenderResumeDataCache {\n  /**\n   * A read-only Map store for values cached by the 'use cache' React hook.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly cache: Omit<UseCacheCacheStore, 'set'>\n\n  /**\n   * A read-only Map store for cached fetch responses.\n   * The 'set' operation is omitted to enforce immutability.\n   */\n  readonly fetch: Omit<FetchCacheStore, 'set'>\n}\n\n/**\n * A mutable version of the resume data cache used during pre-rendering.\n * This cache allows both reading and writing of cached values.\n */\nexport interface PrerenderResumeDataCache {\n  /**\n   * A mutable Map store for values cached by the 'use cache' React hook.\n   * Supports both get and set operations to build the cache during pre-rendering.\n   */\n  readonly cache: UseCacheCacheStore\n\n  /**\n   * A mutable Map store for cached fetch responses.\n   * Supports both get and set operations to build the cache during pre-rendering.\n   */\n  readonly fetch: FetchCacheStore\n}\n\ntype ResumeStoreSerialized = {\n  store: {\n    cache: {\n      [key: string]: any\n    }\n    fetch: {\n      [key: string]: any\n    }\n  }\n}\n\n/**\n * Serializes a resume data cache into a JSON string for storage or transmission.\n * Handles both 'use cache' values and fetch responses.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or 'null' if empty\n */\nexport async function stringifyResumeDataCache(\n  resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache\n): Promise<string> {\n  if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n    return 'null'\n  }\n\n  const json: ResumeStoreSerialized = {\n    store: {\n      fetch: Object.fromEntries(\n        stringifyFetchCacheStore(resumeDataCache.fetch.entries())\n      ),\n      cache: Object.fromEntries(\n        await stringifyUseCacheCacheStore(resumeDataCache.cache.entries())\n      ),\n    },\n  }\n\n  return JSON.stringify(json)\n}\n\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */\nexport function createPrerenderResumeDataCache(): PrerenderResumeDataCache {\n  return {\n    cache: new Map(),\n    fetch: new Map(),\n  }\n}\n\n/**\n * Creates an immutable render resume data cache from either:\n * 1. An existing prerender cache instance\n * 2. A serialized cache string\n *\n * @param prerenderResumeDataCache - A PrerenderResumeDataCache instance to convert to immutable\n * @param persistedCache - A serialized cache string to parse\n * @returns An immutable RenderResumeDataCache instance\n */\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCache: PrerenderResumeDataCache\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  persistedCache: string\n): RenderResumeDataCache\nexport function createRenderResumeDataCache(\n  prerenderResumeDataCacheOrPersistedCache: PrerenderResumeDataCache | string\n): RenderResumeDataCache {\n  if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n    // If the cache is already a prerender cache, we can return it directly,\n    // we're just performing a type change.\n    return prerenderResumeDataCacheOrPersistedCache\n  }\n\n  if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n    return {\n      cache: new Map(),\n      fetch: new Map(),\n    }\n  }\n\n  const json: ResumeStoreSerialized = JSON.parse(\n    prerenderResumeDataCacheOrPersistedCache\n  )\n  return {\n    cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n    fetch: parseFetchCacheStore(Object.entries(json.store.fetch)),\n  }\n}\n"],"names":["stringifyFetchCacheStore","stringifyUseCacheCacheStore","parseUseCacheCacheStore","parseFetchCacheStore","stringifyResumeDataCache","resumeDataCache","fetch","size","cache","json","store","Object","fromEntries","entries","JSON","stringify","createPrerenderResumeDataCache","Map","createRenderResumeDataCache","prerenderResumeDataCacheOrPersistedCache","parse"],"mappings":";;;;;AAAA,SAGEA,wBAAwB,EACxBC,2BAA2B,EAC3BC,uBAAuB,EACvBC,oBAAoB,QACf,gBAAe;;AAwDf,eAAeC,yBACpBC,eAAiE;IAEjE,IAAIA,gBAAgBC,KAAK,CAACC,IAAI,KAAK,KAAKF,gBAAgBG,KAAK,CAACD,IAAI,KAAK,GAAG;QACxE,OAAO;IACT;IAEA,MAAME,OAA8B;QAClCC,OAAO;YACLJ,OAAOK,OAAOC,WAAW,wMACvBZ,2BAAAA,EAAyBK,gBAAgBC,KAAK,CAACO,OAAO;YAExDL,OAAOG,OAAOC,WAAW,CACvB,6MAAMX,8BAAAA,EAA4BI,gBAAgBG,KAAK,CAACK,OAAO;QAEnE;IACF;IAEA,OAAOC,KAAKC,SAAS,CAACN;AACxB;AASO,SAASO;IACd,OAAO;QACLR,OAAO,IAAIS;QACXX,OAAO,IAAIW;IACb;AACF;AAiBO,SAASC,4BACdC,wCAA2E;IAE3E,IAAI,OAAOA,6CAA6C,UAAU;QAChE,wEAAwE;QACxE,uCAAuC;QACvC,OAAOA;IACT;IAEA,IAAIA,6CAA6C,QAAQ;QACvD,OAAO;YACLX,OAAO,IAAIS;YACXX,OAAO,IAAIW;QACb;IACF;IAEA,MAAMR,OAA8BK,KAAKM,KAAK,CAC5CD;IAEF,OAAO;QACLX,QAAON,gOAAAA,EAAwBS,OAAOE,OAAO,CAACJ,KAAKC,KAAK,CAACF,KAAK;QAC9DF,8MAAOH,uBAAAA,EAAqBQ,OAAOE,OAAO,CAACJ,KAAKC,KAAK,CAACJ,KAAK;IAC7D;AACF","ignoreList":[0]}},
    {"offset": {"line": 5840, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5846, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/web-server.ts"],"sourcesContent":["import type { WebNextRequest, WebNextResponse } from './base-http/web'\nimport type RenderResult from './render-result'\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'\nimport type { Params } from './request/params'\nimport type { LoadComponentsReturnType } from './load-components'\nimport type {\n  LoadedRenderOpts,\n  MiddlewareRoutingItem,\n  NormalizedRouteManifest,\n  Options,\n  RouteHandler,\n} from './base-server'\nimport type { Revalidate, ExpireTime } from './lib/revalidate'\n\nimport { byteLength } from './api-utils/web'\nimport BaseServer, { NoFallbackError } from './base-server'\nimport { generateETag } from './lib/etag'\nimport { addRequestMeta } from './request-meta'\nimport WebResponseCache from './response-cache/web'\nimport { isAPIRoute } from '../lib/is-api-route'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport {\n  interpolateDynamicPath,\n  normalizeVercelUrl,\n  normalizeDynamicRouteParams,\n} from './server-utils'\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'\nimport { IncrementalCache } from './lib/incremental-cache'\nimport type { PAGE_TYPES } from '../lib/page-types'\nimport type { Rewrite } from '../lib/load-custom-routes'\nimport { buildCustomRoute } from '../lib/build-custom-route'\nimport { UNDERSCORE_NOT_FOUND_ROUTE } from '../api/constants'\nimport { getEdgeInstrumentationModule } from './web/globals'\nimport type { ServerOnInstrumentationRequestError } from './app-render/types'\nimport { getEdgePreviewProps } from './web/get-edge-preview-props'\n\ninterface WebServerOptions extends Options {\n  webServerConfig: {\n    page: string\n    pathname: string\n    pagesType: PAGE_TYPES\n    loadComponent: (page: string) => Promise<LoadComponentsReturnType | null>\n    extendRenderOpts: Partial<BaseServer['renderOpts']> &\n      Pick<BaseServer['renderOpts'], 'buildId'> & {\n        serverActionsManifest?: any\n      }\n    renderToHTML:\n      | typeof import('./app-render/app-render').renderToHTMLOrFlight\n      | undefined\n    incrementalCacheHandler?: any\n    interceptionRouteRewrites?: Rewrite[]\n  }\n}\n\ntype WebRouteHandler = RouteHandler<WebNextRequest, WebNextResponse>\n\nexport default class NextWebServer extends BaseServer<\n  WebServerOptions,\n  WebNextRequest,\n  WebNextResponse\n> {\n  constructor(options: WebServerOptions) {\n    super(options)\n\n    // Extend `renderOpts`.\n    Object.assign(this.renderOpts, options.webServerConfig.extendRenderOpts)\n  }\n\n  protected async getIncrementalCache({\n    requestHeaders,\n  }: {\n    requestHeaders: IncrementalCache['requestHeaders']\n  }) {\n    const dev = !!this.renderOpts.dev\n    // incremental-cache is request specific\n    // although can have shared caches in module scope\n    // per-cache handler\n    return new IncrementalCache({\n      dev,\n      requestHeaders,\n      dynamicIO: Boolean(this.nextConfig.experimental.dynamicIO),\n      requestProtocol: 'https',\n      allowedRevalidateHeaderKeys:\n        this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n      minimalMode: this.minimalMode,\n      fetchCache: true,\n      fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n      maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n      flushToDisk: false,\n      CurCacheHandler:\n        this.serverOptions.webServerConfig.incrementalCacheHandler,\n      getPrerenderManifest: () => this.getPrerenderManifest(),\n    })\n  }\n  protected getResponseCache() {\n    return new WebResponseCache(this.minimalMode)\n  }\n\n  protected async hasPage(page: string) {\n    return page === this.serverOptions.webServerConfig.page\n  }\n\n  protected getBuildId() {\n    return this.serverOptions.webServerConfig.extendRenderOpts.buildId\n  }\n\n  protected getEnabledDirectories() {\n    return {\n      app: this.serverOptions.webServerConfig.pagesType === 'app',\n      pages: this.serverOptions.webServerConfig.pagesType === 'pages',\n    }\n  }\n\n  protected getPagesManifest() {\n    return {\n      // keep same theme but server path doesn't need to be accurate\n      [this.serverOptions.webServerConfig.pathname]:\n        `server${this.serverOptions.webServerConfig.page}.js`,\n    }\n  }\n\n  protected getAppPathsManifest() {\n    const page = this.serverOptions.webServerConfig.page\n    return {\n      [this.serverOptions.webServerConfig.page]: `app${page}.js`,\n    }\n  }\n\n  protected attachRequestMeta(\n    req: WebNextRequest,\n    parsedUrl: NextUrlWithParsedQuery\n  ) {\n    addRequestMeta(req, 'initQuery', { ...parsedUrl.query })\n  }\n\n  protected getPrerenderManifest() {\n    return {\n      version: -1 as any, // letting us know this doesn't conform to spec\n      routes: {},\n      dynamicRoutes: {},\n      notFoundRoutes: [],\n      preview: getEdgePreviewProps(),\n    }\n  }\n\n  protected getNextFontManifest() {\n    return this.serverOptions.webServerConfig.extendRenderOpts.nextFontManifest\n  }\n\n  protected handleCatchallRenderRequest: WebRouteHandler = async (\n    req,\n    res,\n    parsedUrl\n  ) => {\n    let { pathname, query } = parsedUrl\n    if (!pathname) {\n      throw new Error('pathname is undefined')\n    }\n\n    // interpolate query information into page for dynamic route\n    // so that rewritten paths are handled properly\n    const normalizedPage = this.serverOptions.webServerConfig.pathname\n\n    if (pathname !== normalizedPage) {\n      pathname = normalizedPage\n\n      if (isDynamicRoute(pathname)) {\n        const routeRegex = getNamedRouteRegex(pathname, false)\n        const dynamicRouteMatcher = getRouteMatcher(routeRegex)\n        const defaultRouteMatches = dynamicRouteMatcher(\n          pathname\n        ) as NextParsedUrlQuery\n        const paramsResult = normalizeDynamicRouteParams(\n          query,\n          false,\n          routeRegex,\n          defaultRouteMatches\n        )\n        const normalizedParams = paramsResult.hasValidParams\n          ? paramsResult.params\n          : query\n\n        pathname = interpolateDynamicPath(\n          pathname,\n          normalizedParams,\n          routeRegex\n        )\n        normalizeVercelUrl(\n          req,\n          true,\n          Object.keys(routeRegex.routeKeys),\n          true,\n          routeRegex\n        )\n      }\n    }\n\n    // next.js core assumes page path without trailing slash\n    pathname = removeTrailingSlash(pathname)\n\n    if (this.i18nProvider) {\n      const { detectedLocale } = await this.i18nProvider.analyze(pathname)\n      if (detectedLocale) {\n        parsedUrl.query.__nextLocale = detectedLocale\n      }\n    }\n\n    const bubbleNoFallback = !!query._nextBubbleNoFallback\n\n    if (isAPIRoute(pathname)) {\n      delete query._nextBubbleNoFallback\n    }\n\n    try {\n      await this.render(req, res, pathname, query, parsedUrl, true)\n\n      return true\n    } catch (err) {\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        return false\n      }\n      throw err\n    }\n  }\n\n  protected renderHTML(\n    req: WebNextRequest,\n    res: WebNextResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult> {\n    const { renderToHTML } = this.serverOptions.webServerConfig\n    if (!renderToHTML) {\n      throw new Error(\n        'Invariant: routeModule should be configured when rendering pages'\n      )\n    }\n\n    // For edge runtime if the pathname hit as /_not-found entrypoint,\n    // override the pathname to /404 for rendering\n    if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n      pathname = '/404'\n    }\n    return renderToHTML(\n      req as any,\n      res as any,\n      pathname,\n      query,\n      // Edge runtime does not support ISR/PPR, so we don't need to pass in\n      // the unknown params.\n      null,\n      Object.assign(renderOpts, {\n        disableOptimizedLoading: true,\n        runtime: 'experimental-edge',\n      }),\n      undefined,\n      false\n    )\n  }\n\n  protected async sendRenderResult(\n    _req: WebNextRequest,\n    res: WebNextResponse,\n    options: {\n      result: RenderResult\n      type: 'html' | 'json'\n      generateEtags: boolean\n      poweredByHeader: boolean\n      revalidate: Revalidate | undefined\n      expireTime: ExpireTime | undefined\n    }\n  ): Promise<void> {\n    res.setHeader('X-Edge-Runtime', '1')\n\n    // Add necessary headers.\n    // @TODO: Share the isomorphic logic with server/send-payload.ts.\n    if (options.poweredByHeader && options.type === 'html') {\n      res.setHeader('X-Powered-By', 'Next.js')\n    }\n\n    if (!res.getHeader('Content-Type')) {\n      res.setHeader(\n        'Content-Type',\n        options.result.contentType\n          ? options.result.contentType\n          : options.type === 'json'\n            ? 'application/json'\n            : 'text/html; charset=utf-8'\n      )\n    }\n\n    let promise: Promise<void> | undefined\n    if (options.result.isDynamic) {\n      promise = options.result.pipeTo(res.transformStream.writable)\n    } else {\n      const payload = options.result.toUnchunkedString()\n      res.setHeader('Content-Length', String(byteLength(payload)))\n      if (options.generateEtags) {\n        res.setHeader('ETag', generateETag(payload))\n      }\n      res.body(payload)\n    }\n\n    res.send()\n\n    // If we have a promise, wait for it to resolve.\n    if (promise) await promise\n  }\n\n  protected async findPageComponents({\n    page,\n    query,\n    params,\n    url: _url,\n  }: {\n    page: string\n    query: NextParsedUrlQuery\n    params: Params | null\n    isAppPath: boolean\n    url?: string\n  }) {\n    const result = await this.serverOptions.webServerConfig.loadComponent(page)\n    if (!result) return null\n\n    return {\n      query: {\n        ...(query || {}),\n        ...(params || {}),\n      },\n      components: result,\n    }\n  }\n\n  // Below are methods that are not implemented by the web server as they are\n  // handled by the upstream proxy (edge runtime or node server).\n\n  protected async runApi() {\n    // This web server does not need to handle API requests.\n    return true\n  }\n\n  protected async handleApiRequest() {\n    // Edge API requests are handled separately in minimal mode.\n    return false\n  }\n\n  protected loadEnvConfig() {\n    // The web server does not need to load the env config. This is done by the\n    // runtime already.\n  }\n\n  protected getPublicDir() {\n    // Public files are not handled by the web server.\n    return ''\n  }\n\n  protected getHasStaticDir() {\n    return false\n  }\n\n  protected getFontManifest() {\n    return undefined\n  }\n\n  protected handleCompression() {\n    // For the web server layer, compression is automatically handled by the\n    // upstream proxy (edge runtime or node server) and we can simply skip here.\n  }\n\n  protected async handleUpgrade(): Promise<void> {\n    // The web server does not support web sockets.\n  }\n\n  protected async getFallbackErrorComponents(\n    _url?: string\n  ): Promise<LoadComponentsReturnType | null> {\n    // The web server does not need to handle fallback errors in production.\n    return null\n  }\n  protected getRoutesManifest(): NormalizedRouteManifest | undefined {\n    // The web server does not need to handle rewrite rules. This is done by the\n    // upstream proxy (edge runtime or node server).\n    return undefined\n  }\n\n  protected getMiddleware(): MiddlewareRoutingItem | undefined {\n    // The web server does not need to handle middleware. This is done by the\n    // upstream proxy (edge runtime or node server).\n    return undefined\n  }\n\n  protected getFilesystemPaths() {\n    return new Set<string>()\n  }\n\n  protected getinterceptionRoutePatterns(): RegExp[] {\n    return (\n      this.serverOptions.webServerConfig.interceptionRouteRewrites?.map(\n        (rewrite) => new RegExp(buildCustomRoute('rewrite', rewrite).regex)\n      ) ?? []\n    )\n  }\n\n  protected async loadInstrumentationModule() {\n    return await getEdgeInstrumentationModule()\n  }\n\n  protected async instrumentationOnRequestError(\n    ...args: Parameters<ServerOnInstrumentationRequestError>\n  ) {\n    await super.instrumentationOnRequestError(...args)\n    const err = args[0]\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof __next_log_error__ === 'function'\n    ) {\n      __next_log_error__(err)\n    } else {\n      console.error(err)\n    }\n  }\n}\n"],"names":["byteLength","BaseServer","NoFallbackError","generateETag","addRequestMeta","WebResponseCache","isAPIRoute","removeTrailingSlash","isDynamicRoute","interpolateDynamicPath","normalizeVercelUrl","normalizeDynamicRouteParams","getNamedRouteRegex","getRouteMatcher","IncrementalCache","buildCustomRoute","UNDERSCORE_NOT_FOUND_ROUTE","getEdgeInstrumentationModule","getEdgePreviewProps","NextWebServer","constructor","options","handleCatchallRenderRequest","req","res","parsedUrl","pathname","query","Error","normalizedPage","serverOptions","webServerConfig","routeRegex","dynamicRouteMatcher","defaultRouteMatches","paramsResult","normalizedParams","hasValidParams","params","Object","keys","routeKeys","i18nProvider","detectedLocale","analyze","__nextLocale","bubbleNoFallback","_nextBubbleNoFallback","render","err","assign","renderOpts","extendRenderOpts","getIncrementalCache","requestHeaders","dev","dynamicIO","Boolean","nextConfig","experimental","requestProtocol","allowedRevalidateHeaderKeys","minimalMode","fetchCache","fetchCacheKeyPrefix","maxMemoryCacheSize","cacheMaxMemorySize","flushToDisk","CurCacheHandler","incrementalCacheHandler","getPrerenderManifest","getResponseCache","hasPage","page","getBuildId","buildId","getEnabledDirectories","app","pagesType","pages","getPagesManifest","getAppPathsManifest","attachRequestMeta","version","routes","dynamicRoutes","notFoundRoutes","preview","getNextFontManifest","nextFontManifest","renderHTML","renderToHTML","disableOptimizedLoading","runtime","undefined","sendRenderResult","_req","setHeader","poweredByHeader","type","getHeader","result","contentType","promise","isDynamic","pipeTo","transformStream","writable","payload","toUnchunkedString","String","generateEtags","body","send","findPageComponents","url","_url","loadComponent","components","runApi","handleApiRequest","loadEnvConfig","getPublicDir","getHasStaticDir","getFontManifest","handleCompression","handleUpgrade","getFallbackErrorComponents","getRoutesManifest","getMiddleware","getFilesystemPaths","Set","getinterceptionRoutePatterns","interceptionRouteRewrites","map","rewrite","RegExp","regex","loadInstrumentationModule","instrumentationOnRequestError","args","process","env","NODE_ENV","__next_log_error__","console","error"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6118, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(\n          new Error(\n            `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`unstable_after\\`, or similar functions you may observe this error and you should handle it in that context.`\n          )\n        )\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"names":["makeHangingPromise","signal","expression","hangingPromise","Promise","_","reject","addEventListener","Error","once","catch","ignoreReject"],"mappings":"AAAA;;;;;;CAMC,GACD;;;AAAO,SAASA,mBACdC,MAAmB,EACnBC,UAAkB;IAElB,MAAMC,iBAAiB,IAAIC,QAAW,CAACC,GAAGC;QACxCL,OAAOM,gBAAgB,CACrB,SACA;YACED,OACE,IAAIE,MACF,CAAC,qBAAqB,EAAEN,WAAW,qGAAqG,EAAEA,WAAW,8JAA8J,CAAC;QAG1T,GACA;YAAEO,MAAM;QAAK;IAEjB;IACA,2GAA2G;IAC3G,6GAA6G;IAC7G,yFAAyF;IACzFN,eAAeO,KAAK,CAACC;IACrB,OAAOR;AACT;AAEA,SAASQ,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 6142, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6148, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/htmlescape.ts"],"sourcesContent":["// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\nconst ESCAPE_LOOKUP: { [match: string]: string } = {\n  '&': '\\\\u0026',\n  '>': '\\\\u003e',\n  '<': '\\\\u003c',\n  '\\u2028': '\\\\u2028',\n  '\\u2029': '\\\\u2029',\n}\n\nexport const ESCAPE_REGEX = /[&><\\u2028\\u2029]/g\n\nexport function htmlEscapeJsonString(str: string): string {\n  return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match])\n}\n"],"names":["ESCAPE_LOOKUP","ESCAPE_REGEX","htmlEscapeJsonString","str","replace","match"],"mappings":"AAAA,iEAAiE;AACjE,uGAAuG;;;;;AAEvG,MAAMA,gBAA6C;IACjD,KAAK;IACL,KAAK;IACL,KAAK;IACL,UAAU;IACV,UAAU;AACZ;AAEO,MAAMC,eAAe,qBAAoB;AAEzC,SAASC,qBAAqBC,GAAW;IAC9C,OAAOA,IAAIC,OAAO,CAACH,cAAc,CAACI,QAAUL,aAAa,CAACK,MAAM;AAClE","ignoreList":[0]}},
    {"offset": {"line": 6165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6171, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/create-deduped-by-callsite-server-error-logger.ts"],"sourcesContent":["import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n"],"names":["React","errorRef","current","cache","fn","logErrorOrWarn","process","env","__NEXT_DYNAMIC_IO","console","error","warn","flushCurrentErrorIfNew","key","createDedupedByCallsiteServerErrorLoggerDev","getMessage","logDedupedError","args","message","NODE_ENV","callStackFrames","Error","stack","split","undefined","length"],"mappings":";;;AAAA,YAAYA,WAAW,QAAO;;AAE9B,MAAMC,WAAsC;IAAEC,SAAS;AAAK;AAE5D,iFAAiF;AACjF,MAAMC,QACJ,OAAOH,sLAAMG,KAAK,KAAK,aACnBH,sLAAMG,KAAK,GACX,CAACC,KAA+BA;AAEtC,qEAAqE;AACrE,qEAAqE;AACrE,gBAAgB;AAChB,MAAMC,iBAAiBC,QAAQC,GAAG,CAACC,iBAAiB,GAChDC,QAAQC,KAAK,gCACbD,QAAQE,IAAI;AAEhB,2CAA2C;AAC3C,wGAAwG;AACxG,MAAMC,yBAAyBT,MAC7B,AACA,CAACU,yEADyE;IAExE,IAAI;QACFR,eAAeJ,SAASC,OAAO;IACjC,SAAU;QACRD,SAASC,OAAO,GAAG;IACrB;AACF;AAcK,SAASY,4CACdC,UAAoC;IAEpC,OAAO,SAASC,gBAAgB,GAAGC,IAAU;QAC3C,MAAMC,UAAUH,cAAcE;QAE9B,IAAIX,QAAQC,GAAG,CAACY,QAAQ,KAAK,WAAc;gBACjB;YAAxB,MAAMC,kBAAAA,CAAkB,SAAA,IAAIC,QAAQC,KAAK,KAAA,OAAA,KAAA,IAAjB,OAAmBC,KAAK,CAAC;YACjD,IAAIH,oBAAoBI,aAAaJ,gBAAgBK,MAAM,GAAG,GAAG;gBAC/DpB,eAAea;YACjB,OAAO;gBACL,SAAS;gBACT,oBAAoB;gBACpB,uCAAuC;gBACvC,wBAAwB;gBACxB,iEAAiE;gBACjE,MAAML,MAAMO,eAAe,CAAC,EAAE;gBAC9BnB,SAASC,OAAO,GAAGgB;gBACnBN,uBAAuBC;YACzB;QACF,OAAO;;QAEP;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 6217, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6223, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/request-meta.ts"],"sourcesContent":["/* eslint-disable no-redeclare */\nimport type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type { ServerComponentsHmrCache } from './response-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: any\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntry?: (\n    cacheEntry: any,\n    requestMeta: any\n  ) => Promise<boolean | void> | boolean | void\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the default route matches were set on the request during routing.\n   */\n  didSetDefaultRouteMatches?: boolean\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  __nextNotFoundSrcPage?: string\n  __nextDefaultLocale?: string\n  __nextFallback?: 'true'\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   *\n   * When this property is mutated, it's important to also update the request\n   * metadata for `_nextInferredDefaultLocale` to ensure that the correct\n   * behavior is applied.\n   */\n  __nextLocale?: string\n\n  /**\n   * `1` when the request did not have a locale in the pathname part of the\n   * URL but the default locale was inferred from either the domain or the\n   * configuration.\n   */\n  __nextInferredLocaleFromDefault?: '1'\n\n  __nextSsgPath?: string\n  _nextBubbleNoFallback?: '1'\n\n  /**\n   * When set to `1`, the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  __nextDataReq?: '1'\n  __nextCustomErrorRender?: '1'\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery &\n  NextQueryMetadata & {\n    amp?: '1'\n  }\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n\nexport function getNextInternalQuery(\n  query: NextParsedUrlQuery\n): NextQueryMetadata {\n  const keysToInclude: (keyof NextQueryMetadata)[] = [\n    '__nextDefaultLocale',\n    '__nextFallback',\n    '__nextLocale',\n    '__nextSsgPath',\n    '_nextBubbleNoFallback',\n    '__nextDataReq',\n    '__nextInferredLocaleFromDefault',\n  ]\n  const nextInternalQuery: NextQueryMetadata = {}\n\n  for (const key of keysToInclude) {\n    if (key in query) {\n      // @ts-ignore this can't be typed correctly\n      nextInternalQuery[key] = query[key]\n    }\n  }\n\n  return nextInternalQuery\n}\n"],"names":["NEXT_REQUEST_META","Symbol","for","getRequestMeta","req","key","meta","setRequestMeta","addRequestMeta","request","value","removeRequestMeta","getNextInternalQuery","query","keysToInclude","nextInternalQuery"],"mappings":"AAAA,+BAA+B,GAU/B,kGAAkG;;;;;;;;;AAC3F,MAAMA,oBAAoBC,OAAOC,GAAG,CAAC,2BAA0B;AAqJ/D,SAASC,eACdC,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACJ,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOK,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASC,eAAeH,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACJ,kBAAkB,GAAGM;IACzB,OAAOA;AACT;AAUO,SAASE,eACdC,OAA4B,EAC5BJ,GAAM,EACNK,KAAqB;IAErB,MAAMJ,OAAOH,eAAeM;IAC5BH,IAAI,CAACD,IAAI,GAAGK;IACZ,OAAOH,eAAeE,SAASH;AACjC;AASO,SAASK,kBACdF,OAA4B,EAC5BJ,GAAM;IAEN,MAAMC,OAAOH,eAAeM;IAC5B,OAAOH,IAAI,CAACD,IAAI;IAChB,OAAOE,eAAeE,SAASH;AACjC;AA4CO,SAASM,qBACdC,KAAyB;IAEzB,MAAMC,gBAA6C;QACjD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IACD,MAAMC,oBAAuC,CAAC;IAE9C,KAAK,MAAMV,OAAOS,cAAe;QAC/B,IAAIT,OAAOQ,OAAO;YAChB,2CAA2C;YAC3CE,iBAAiB,CAACV,IAAI,GAAGQ,KAAK,CAACR,IAAI;QACrC;IACF;IAEA,OAAOU;AACT","ignoreList":[0]}},
    {"offset": {"line": 6270, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6276, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/client-component-renderer-logger.ts"],"sourcesContent":["// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(ComponentMod: any) {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args: any[]) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args: any[]) => {\n      const startTime = performance.now()\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.loadChunk(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n"],"names":["clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","wrapClientComponentLoader","ComponentMod","globalThis","__next_app__","require","args","startTime","performance","now","loadChunk","getClientComponentLoaderMetrics","options","metrics","undefined","reset"],"mappings":"AAAA,oDAAoD;;;;;AACpD,IAAIA,2BAA2B;AAC/B,IAAIC,2BAA2B;AAC/B,IAAIC,2BAA2B;AAExB,SAASC,0BAA0BC,YAAiB;IACzD,IAAI,CAAE,CAAA,iBAAiBC,UAAS,GAAI;QAClC,OAAOD,aAAaE,YAAY;IAClC;IAEA,OAAO;QACLC,SAAS,CAAC,GAAGC;YACX,MAAMC,YAAYC,YAAYC,GAAG;YAEjC,IAAIX,6BAA6B,GAAG;gBAClCA,2BAA2BS;YAC7B;YAEA,IAAI;gBACFP,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACC,OAAO,IAAIC;YAC9C,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;QACAG,WAAW,CAAC,GAAGJ;YACb,MAAMC,YAAYC,YAAYC,GAAG;YACjC,IAAI;gBACFT,4BAA4B;gBAC5B,OAAOE,aAAaE,YAAY,CAACM,SAAS,IAAIJ;YAChD,SAAU;gBACRP,4BAA4BS,YAAYC,GAAG,KAAKF;YAClD;QACF;IACF;AACF;AAEO,SAASI,gCACdC,UAA+B,CAAC,CAAC;IAEjC,MAAMC,UACJf,6BAA6B,IACzBgB,YACA;QACEhB;QACAC;QACAC;IACF;IAEN,IAAIY,QAAQG,KAAK,EAAE;QACjBjB,2BAA2B;QAC3BC,2BAA2B;QAC3BC,2BAA2B;IAC7B;IAEA,OAAOa;AACT","ignoreList":[0]}},
    {"offset": {"line": 6325, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6331, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/pipe-readable.ts"],"sourcesContent":["import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n"],"names":["ResponseAbortedName","createAbortController","DetachedPromise","getTracer","NextNodeServerSpan","getClientComponentLoaderMetrics","isAbortError","e","name","createWriterFromResponse","res","waitUntilForEnd","started","drained","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","globalThis","process","env","NEXT_OTEL_PERFORMANCE_PREFIX","metrics","performance","measure","start","clientComponentLoadStart","end","clientComponentLoadTimes","flushHeaders","trace","startResponse","spanName","undefined","ok","flush","promise","err","Error","cause","abort","writableFinished","destroy","close","pipeToNodeResponse","readable","errored","destroyed","controller","writer","pipeTo","signal"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6448, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6454, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/render-result.ts"],"sourcesContent":["import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { Revalidate } from './lib/revalidate'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToBuffer,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { PrerenderResumeDataCache } from './resume-data-cache/resume-data-cache'\n\ntype ContentTypeOption = string | undefined\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  revalidate?: Revalidate\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentFlightData?: Map<string, Buffer>\n\n  /**\n   * In development, the cache is warmed up before the render. This is attached\n   * to the metadata so that it can be used during the render.\n   */\n  devWarmupPrerenderResumeDataCache?: PrerenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  revalidate?: Revalidate\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType?: ContentTypeOption\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(value: string | Buffer) {\n    return new RenderResult<StaticRenderResultMetadata>(value, { metadata: {} })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  public toUnchunkedBuffer(stream?: false): Buffer\n  public toUnchunkedBuffer(stream: true): Promise<Buffer>\n  public toUnchunkedBuffer(stream = false): Promise<Buffer> | Buffer {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToBuffer(this.readable)\n    }\n\n    return Buffer.from(this.response)\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be unchunked')\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new Error(\n          'Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns the response if it is a stream, or throws an error if it is a\n   * string.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      throw new Error('Invariant: null responses cannot be streamed')\n    }\n    if (typeof this.response === 'string') {\n      throw new Error('Invariant: static responses cannot be streamed')\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public chain(readable: ReadableStream<Uint8Array>) {\n    if (this.response === null) {\n      throw new Error('Invariant: response is null. This is a bug in Next.js')\n    }\n\n    // If the response is not an array of streams already, make it one.\n    let responses: ReadableStream<Uint8Array>[]\n    if (typeof this.response === 'string') {\n      responses = [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      responses = this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      responses = [streamFromBuffer(this.response)]\n    } else {\n      responses = [this.response]\n    }\n\n    // Add the new stream to the array.\n    responses.push(readable)\n\n    // Update the response.\n    this.response = responses\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n"],"names":["chainStreams","streamFromBuffer","streamFromString","streamToBuffer","streamToString","isAbortError","pipeToNodeResponse","RenderResult","fromStatic","value","metadata","constructor","response","contentType","waitUntil","assignMetadata","Object","assign","isNull","isDynamic","toUnchunkedBuffer","stream","Error","readable","Buffer","from","toUnchunkedString","isBuffer","Array","isArray","chain","responses","push","pipeTo","writable","preventClose","close","err","abort","res"],"mappings":";;;AAIA,SACEA,YAAY,EACZC,gBAAgB,EAChBC,gBAAgB,EAChBC,cAAc,EACdC,cAAc,QACT,yCAAwC;AAC/C,SAASC,YAAY,EAAEC,kBAAkB,QAAQ,kBAAiB;AAiJvDkB;;;AAlFI,MAAMjB;IAuBnB;;;;;GAKC,GACD,OAAcC,WAAWC,KAAsB,EAAE;QAC/C,OAAO,IAAIF,aAAyCE,OAAO;YAAEC,UAAU,CAAC;QAAE;IAC5E;IAIAC,YACEC,QAA8B,EAC9B,EAAEC,WAAW,EAAEC,SAAS,EAAEJ,QAAQ,EAAiC,CACnE;QACA,IAAI,CAACE,QAAQ,GAAGA;QAChB,IAAI,CAACC,WAAW,GAAGA;QACnB,IAAI,CAACH,QAAQ,GAAGA;QAChB,IAAI,CAACI,SAAS,GAAGA;IACnB;IAEOC,eAAeL,QAAkB,EAAE;QACxCM,OAAOC,MAAM,CAAC,IAAI,CAACP,QAAQ,EAAEA;IAC/B;IAEA;;;GAGC,GACD,IAAWQ,SAAkB;QAC3B,OAAO,IAAI,CAACN,QAAQ,KAAK;IAC3B;IAEA;;;GAGC,GACD,IAAWO,YAAqB;QAC9B,OAAO,OAAO,IAAI,CAACP,QAAQ,KAAK;IAClC;IAIOQ,kBAAkBC,SAAS,KAAK,EAA4B;QACjE,IAAI,IAAI,CAACT,QAAQ,KAAK,MAAM;YAC1B,MAAM,IAAIU,MAAM;QAClB;QAEA,IAAI,OAAO,IAAI,CAACV,QAAQ,KAAK,UAAU;YACrC,IAAI,CAACS,QAAQ;gBACX,MAAM,IAAIC,MACR;YAEJ;YAEA,QAAOnB,iOAAAA,EAAe,IAAI,CAACoB,QAAQ;QACrC;QAEA,wHAAOC,CAAOC,IAAI,CAAC,IAAI,CAACb,QAAQ;IAClC;IAWOc,kBAAkBL,SAAS,KAAK,EAA4B;QACjE,IAAI,IAAI,CAACT,QAAQ,KAAK,MAAM;YAC1B,MAAM,IAAIU,MAAM;QAClB;QAEA,IAAI,OAAO,IAAI,CAACV,QAAQ,KAAK,UAAU;YACrC,IAAI,CAACS,QAAQ;gBACX,MAAM,IAAIC,MACR;YAEJ;YAEA,QAAOlB,iOAAAA,EAAe,IAAI,CAACmB,QAAQ;QACrC;QAEA,OAAO,IAAI,CAACX,QAAQ;IACtB;IAEA;;;GAGC,GACD,IAAYW,WAAuC;QACjD,IAAI,IAAI,CAACX,QAAQ,KAAK,MAAM;YAC1B,MAAM,IAAIU,MAAM;QAClB;QACA,IAAI,OAAO,IAAI,CAACV,QAAQ,KAAK,UAAU;YACrC,MAAM,IAAIU,MAAM;QAClB;QAEA,IAAIE,iHAAAA,CAAOG,QAAQ,CAAC,IAAI,CAACf,QAAQ,GAAG;YAClC,wNAAOX,mBAAAA,EAAiB,IAAI,CAACW,QAAQ;QACvC;QAEA,oEAAoE;QACpE,IAAIgB,MAAMC,OAAO,CAAC,IAAI,CAACjB,QAAQ,GAAG;YAChC,wNAAOZ,eAAAA,KAAgB,IAAI,CAACY,QAAQ;QACtC;QAEA,OAAO,IAAI,CAACA,QAAQ;IACtB;IAEA;;;;;;;GAOC,GACMkB,MAAMP,QAAoC,EAAE;QACjD,IAAI,IAAI,CAACX,QAAQ,KAAK,MAAM;YAC1B,MAAM,IAAIU,MAAM;QAClB;QAEA,mEAAmE;QACnE,IAAIS;QACJ,IAAI,OAAO,IAAI,CAACnB,QAAQ,KAAK,UAAU;YACrCmB,YAAY;iOAAC7B,mBAAAA,EAAiB,IAAI,CAACU,QAAQ;aAAE;QAC/C,OAAO,IAAIgB,MAAMC,OAAO,CAAC,IAAI,CAACjB,QAAQ,GAAG;YACvCmB,YAAY,IAAI,CAACnB,QAAQ;QAC3B,OAAO,4GAAIY,SAAAA,CAAOG,QAAQ,CAAC,IAAI,CAACf,QAAQ,GAAG;YACzCmB,YAAY;iOAAC9B,mBAAAA,EAAiB,IAAI,CAACW,QAAQ;aAAE;QAC/C,OAAO;YACLmB,YAAY;gBAAC,IAAI,CAACnB,QAAQ;aAAC;QAC7B;QAEA,mCAAmC;QACnCmB,UAAUC,IAAI,CAACT;QAEf,uBAAuB;QACvB,IAAI,CAACX,QAAQ,GAAGmB;IAClB;IAEA;;;;;;GAMC,GACD,MAAaE,OAAOC,QAAoC,EAAiB;QACvE,IAAI;YACF,MAAM,IAAI,CAACX,QAAQ,CAACU,MAAM,CAACC,UAAU;gBACnC,qEAAqE;gBACrE,sEAAsE;gBACtE,sEAAsE;gBACtE,SAAS;gBACTC,cAAc;YAChB;YAEA,iEAAiE;YACjE,+BAA+B;YAC/B,IAAI,IAAI,CAACrB,SAAS,EAAE,MAAM,IAAI,CAACA,SAAS;YAExC,6BAA6B;YAC7B,MAAMoB,SAASE,KAAK;QACtB,EAAE,OAAOC,KAAK;YACZ,wEAAwE;YACxE,0EAA0E;YAC1E,gCAAgC;YAChC,kLAAIhC,eAAAA,EAAagC,MAAM;gBACrB,wDAAwD;gBACxD,MAAMH,SAASI,KAAK,CAACD;gBAErB;YACF;YAEA,yEAAyE;YACzE,wEAAwE;YACxE,0BAA0B;YAC1B,MAAMA;QACR;IACF;IAEA;;;;;GAKC,GACD,MAAa/B,mBAAmBiC,GAAmB,EAAE;QACnD,oLAAMjC,qBAAAA,EAAmB,IAAI,CAACiB,QAAQ,EAAEgB,KAAK,IAAI,CAACzB,SAAS;IAC7D;AACF","ignoreList":[0]}},
    {"offset": {"line": 6614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6620, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/internal-utils.ts"],"sourcesContent":["import type { NextParsedUrlQuery } from './request-meta'\n\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n\nconst INTERNAL_QUERY_NAMES = [\n  '__nextFallback',\n  '__nextLocale',\n  '__nextInferredLocaleFromDefault',\n  '__nextDefaultLocale',\n  '__nextIsNotFound',\n  NEXT_RSC_UNION_QUERY,\n] as const\n\nconst EDGE_EXTENDED_INTERNAL_QUERY_NAMES = ['__nextDataReq'] as const\n\nexport function stripInternalQueries(query: NextParsedUrlQuery) {\n  for (const name of INTERNAL_QUERY_NAMES) {\n    delete query[name]\n  }\n}\n\nexport function stripInternalSearchParams<T extends string | URL>(\n  url: T,\n  isEdge: boolean\n): T {\n  const isStringUrl = typeof url === 'string'\n  const instance = isStringUrl ? new URL(url) : (url as URL)\n  for (const name of INTERNAL_QUERY_NAMES) {\n    instance.searchParams.delete(name)\n  }\n\n  if (isEdge) {\n    for (const name of EDGE_EXTENDED_INTERNAL_QUERY_NAMES) {\n      instance.searchParams.delete(name)\n    }\n  }\n\n  return (isStringUrl ? instance.toString() : instance) as T\n}\n"],"names":["NEXT_RSC_UNION_QUERY","INTERNAL_QUERY_NAMES","EDGE_EXTENDED_INTERNAL_QUERY_NAMES","stripInternalQueries","query","name","stripInternalSearchParams","url","isEdge","isStringUrl","instance","URL","searchParams","delete","toString"],"mappings":";;;;AAEA,SAASA,oBAAoB,QAAQ,0CAAyC;;AAE9E,MAAMC,uBAAuB;IAC3B;IACA;IACA;IACA;IACA;oMACAD,uBAAAA;CACD;AAED,MAAME,qCAAqC;IAAC;CAAgB;AAErD,SAASC,qBAAqBC,KAAyB;IAC5D,KAAK,MAAMC,QAAQJ,qBAAsB;QACvC,OAAOG,KAAK,CAACC,KAAK;IACpB;AACF;AAEO,SAASC,0BACdC,GAAM,EACNC,MAAe;IAEf,MAAMC,cAAc,OAAOF,QAAQ;IACnC,MAAMG,WAAWD,cAAc,IAAIE,IAAIJ,OAAQA;IAC/C,KAAK,MAAMF,QAAQJ,qBAAsB;QACvCS,SAASE,YAAY,CAACC,MAAM,CAACR;IAC/B;IAEA,IAAIG,QAAQ;QACV,KAAK,MAAMH,QAAQH,mCAAoC;YACrDQ,SAASE,YAAY,CAACC,MAAM,CAACR;QAC/B;IACF;IAEA,OAAQI,cAAcC,SAASI,QAAQ,KAAKJ;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 6655, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6661, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(\n          new Error(\n            `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`unstable_after\\`, or similar functions you may observe this error and you should handle it in that context.`\n          )\n        )\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"names":["makeHangingPromise","signal","expression","hangingPromise","Promise","_","reject","addEventListener","Error","once","catch","ignoreReject"],"mappings":"AAAA;;;;;;CAMC,GACD;;;AAAO,SAASA,mBACdC,MAAmB,EACnBC,UAAkB;IAElB,MAAMC,iBAAiB,IAAIC,QAAW,CAACC,GAAGC;QACxCL,OAAOM,gBAAgB,CACrB,SACA;YACED,OACE,IAAIE,MACF,CAAC,qBAAqB,EAAEN,WAAW,qGAAqG,EAAEA,WAAW,8JAA8J,CAAC;QAG1T,GACA;YAAEO,MAAM;QAAK;IAEjB;IACA,2GAA2G;IAC3G,6GAA6G;IAC7G,yFAAyF;IACzFN,eAAeO,KAAK,CAACC;IACrB,OAAOR;AACT;AAEA,SAASQ,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 6685, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6691, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/htmlescape.ts"],"sourcesContent":["// This utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\nconst ESCAPE_LOOKUP: { [match: string]: string } = {\n  '&': '\\\\u0026',\n  '>': '\\\\u003e',\n  '<': '\\\\u003c',\n  '\\u2028': '\\\\u2028',\n  '\\u2029': '\\\\u2029',\n}\n\nexport const ESCAPE_REGEX = /[&><\\u2028\\u2029]/g\n\nexport function htmlEscapeJsonString(str: string): string {\n  return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match])\n}\n"],"names":["ESCAPE_LOOKUP","ESCAPE_REGEX","htmlEscapeJsonString","str","replace","match"],"mappings":"AAAA,iEAAiE;AACjE,uGAAuG;;;;;AAEvG,MAAMA,gBAA6C;IACjD,KAAK;IACL,KAAK;IACL,KAAK;IACL,UAAU;IACV,UAAU;AACZ;AAEO,MAAMC,eAAe,qBAAoB;AAEzC,SAASC,qBAAqBC,GAAW;IAC9C,OAAOA,IAAIC,OAAO,CAACH,cAAc,CAACI,QAAUL,aAAa,CAACK,MAAM;AAClE","ignoreList":[0]}},
    {"offset": {"line": 6708, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6714, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/route-kind.ts"],"sourcesContent":["export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n"],"names":["RouteKind"],"mappings":";;;;UAAkBA,SAAAA;IAChB;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;IAED;;GAEC,GAAA,SAAA,CAAA,YAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,WAAA,GAAA;IAED;;;GAGC,GAAA,SAAA,CAAA,YAAA,GAAA;IAGD;;GAEC,GAAA,SAAA,CAAA,QAAA,GAAA;GAtBeA,aAAAA,CAAAA,YAAAA,CAAAA,CAAAA","ignoreList":[0]}},
    {"offset": {"line": 6737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6743, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/dev/hot-reloader-types.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type { UrlObject } from 'url'\nimport type { Duplex } from 'stream'\nimport type { webpack } from 'next/dist/compiled/webpack/webpack'\nimport type getBaseWebpackConfig from '../../build/webpack-config'\nimport type { RouteDefinition } from '../route-definitions/route-definition'\nimport type { Project, Update as TurbopackUpdate } from '../../build/swc/types'\nimport type { VersionInfo } from './parse-version-info'\nimport type { DebugInfo } from '../../client/components/react-dev-overlay/types'\n\nexport const enum HMR_ACTIONS_SENT_TO_BROWSER {\n  ADDED_PAGE = 'addedPage',\n  REMOVED_PAGE = 'removedPage',\n  RELOAD_PAGE = 'reloadPage',\n  SERVER_COMPONENT_CHANGES = 'serverComponentChanges',\n  MIDDLEWARE_CHANGES = 'middlewareChanges',\n  CLIENT_CHANGES = 'clientChanges',\n  SERVER_ONLY_CHANGES = 'serverOnlyChanges',\n  SYNC = 'sync',\n  BUILT = 'built',\n  BUILDING = 'building',\n  DEV_PAGES_MANIFEST_UPDATE = 'devPagesManifestUpdate',\n  TURBOPACK_MESSAGE = 'turbopack-message',\n  SERVER_ERROR = 'serverError',\n  TURBOPACK_CONNECTED = 'turbopack-connected',\n  APP_ISR_MANIFEST = 'appIsrManifest',\n}\n\ninterface ServerErrorAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR\n  errorJSON: string\n}\n\nexport interface TurbopackMessageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE\n  data: TurbopackUpdate | TurbopackUpdate[]\n}\n\ninterface BuildingAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.BUILDING\n}\n\nexport interface CompilationError {\n  moduleName?: string\n  message: string\n  details?: string\n  moduleTrace?: Array<{ moduleName?: string }>\n  stack?: string\n}\nexport interface SyncAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SYNC\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  versionInfo: VersionInfo\n  updatedModules?: ReadonlyArray<string>\n  debug?: DebugInfo\n}\ninterface BuiltAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.BUILT\n  hash: string\n  errors: ReadonlyArray<CompilationError>\n  warnings: ReadonlyArray<CompilationError>\n  updatedModules?: ReadonlyArray<string>\n}\n\ninterface AddedPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE\n  data: [page: string | null]\n}\n\ninterface RemovedPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE\n  data: [page: string | null]\n}\n\nexport interface ReloadPageAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE\n  data: string\n}\n\ninterface ServerComponentChangesAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES\n}\n\ninterface MiddlewareChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n}\n\ninterface ClientChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES\n}\n\ninterface ServerOnlyChangesAction {\n  event: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ONLY_CHANGES\n  pages: ReadonlyArray<string>\n}\n\ninterface DevPagesManifestUpdateAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE\n  data: [\n    {\n      devPagesManifest: true\n    },\n  ]\n}\n\nexport interface TurbopackConnectedAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n  data: { sessionId: number }\n}\n\nexport interface AppIsrManifestAction {\n  action: HMR_ACTIONS_SENT_TO_BROWSER.APP_ISR_MANIFEST\n  data: Record<string, boolean>\n}\n\nexport type HMR_ACTION_TYPES =\n  | TurbopackMessageAction\n  | TurbopackConnectedAction\n  | BuildingAction\n  | SyncAction\n  | BuiltAction\n  | AddedPageAction\n  | RemovedPageAction\n  | ReloadPageAction\n  | ServerComponentChangesAction\n  | ClientChangesAction\n  | MiddlewareChangesAction\n  | ServerOnlyChangesAction\n  | DevPagesManifestUpdateAction\n  | ServerErrorAction\n  | AppIsrManifestAction\n\nexport type TurbopackMsgToBrowser =\n  | { type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE; data: any }\n  | {\n      type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n      data: { sessionId: number }\n    }\n\nexport interface NextJsHotReloaderInterface {\n  turbopackProject?: Project\n  activeWebpackConfigs?: Array<Awaited<ReturnType<typeof getBaseWebpackConfig>>>\n  serverStats: webpack.Stats | null\n  edgeServerStats: webpack.Stats | null\n  run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlObject\n  ): Promise<{ finished?: true }>\n\n  setHmrServerError(error: Error | null): void\n  clearHmrServerError(): void\n  start(): Promise<void>\n  stop(): Promise<void>\n  send(action: HMR_ACTION_TYPES): void\n  getCompilationErrors(page: string): Promise<any[]>\n  onHMR(\n    req: IncomingMessage,\n    _socket: Duplex,\n    head: Buffer,\n    onUpgrade: (client: { send(data: string): void }) => void\n  ): void\n  invalidate({\n    reloadAfterInvalidation,\n  }: {\n    reloadAfterInvalidation: boolean\n  }): Promise<void> | void\n  buildFallbackError(): Promise<void>\n  ensurePage({\n    page,\n    clientOnly,\n    appPaths,\n    definition,\n    isApp,\n    url,\n  }: {\n    page: string\n    clientOnly: boolean\n    appPaths?: ReadonlyArray<string> | null\n    isApp?: boolean\n    definition: RouteDefinition | undefined\n    url?: string\n  }): Promise<void>\n}\n"],"names":["HMR_ACTIONS_SENT_TO_BROWSER"],"mappings":";;;;UAUkBA,2BAAAA;;;;;;;;;;;;;;;;GAAAA,+BAAAA,CAAAA,8BAAAA,CAAAA,CAAAA","ignoreList":[0]}},
    {"offset": {"line": 6764, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6770, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/server/dev/extract-modules-from-turbopack-message.ts"],"sourcesContent":["import type { Update as TurbopackUpdate } from '../../build/swc/types'\n\nexport function extractModulesFromTurbopackMessage(\n  data: TurbopackUpdate | TurbopackUpdate[]\n) {\n  const updatedModules: Set<string> = new Set()\n\n  const updates = Array.isArray(data) ? data : [data]\n  for (const update of updates) {\n    // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n    if (\n      update.type !== 'partial' ||\n      update.instruction.type !== 'ChunkListUpdate' ||\n      update.instruction.merged === undefined\n    ) {\n      continue\n    }\n\n    for (const mergedUpdate of update.instruction.merged) {\n      for (const name of Object.keys(mergedUpdate.entries)) {\n        const res = /(.*)\\s+\\[.*/.exec(name)\n        if (res === null) {\n          console.error(\n            '[Turbopack HMR] Expected module to match pattern: ' + name\n          )\n          continue\n        }\n\n        updatedModules.add(res[1])\n      }\n    }\n  }\n\n  return [...updatedModules]\n}\n"],"names":["extractModulesFromTurbopackMessage","data","updatedModules","Set","updates","Array","isArray","update","type","instruction","merged","undefined","mergedUpdate","name","Object","keys","entries","res","exec","console","error","add"],"mappings":";;;AAEO,SAASA,mCACdC,IAAyC;IAEzC,MAAMC,iBAA8B,IAAIC;IAExC,MAAMC,UAAUC,MAAMC,OAAO,CAACL,QAAQA,OAAO;QAACA;KAAK;IACnD,KAAK,MAAMM,UAAUH,QAAS;QAC5B,sFAAsF;QACtF,IACEG,OAAOC,IAAI,KAAK,aAChBD,OAAOE,WAAW,CAACD,IAAI,KAAK,qBAC5BD,OAAOE,WAAW,CAACC,MAAM,KAAKC,WAC9B;YACA;QACF;QAEA,KAAK,MAAMC,gBAAgBL,OAAOE,WAAW,CAACC,MAAM,CAAE;YACpD,KAAK,MAAMG,QAAQC,OAAOC,IAAI,CAACH,aAAaI,OAAO,EAAG;gBACpD,MAAMC,MAAM,cAAcC,IAAI,CAACL;gBAC/B,IAAII,QAAQ,MAAM;oBAChBE,QAAQC,KAAK,CACX,uDAAuDP;oBAEzD;gBACF;gBAEAX,eAAemB,GAAG,CAACJ,GAAG,CAAC,EAAE;YAC3B;QACF;IACF;IAEA,OAAO;WAAIf;KAAe;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 6798, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}